[11:49:24] /workspace/home/codes/tvm/src/relay/backend/vm/compiler.cc:916: LOWER START

[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass RemoveUnusedFunctions
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) {
  nn.softmax(%x)
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass ToBasicBlockNormalForm
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) {
  nn.softmax(%x)
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass Legalize
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  nn.softmax(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass Legalize
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  nn.softmax(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass sequential
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  nn.softmax(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass Legalize
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  nn.softmax(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass EtaExpand
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  nn.softmax(%x)
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass SimplifyInference
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  nn.softmax(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass SimplifyExpr
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  nn.softmax(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass Inline
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  nn.softmax(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass DeadCodeElimination
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  nn.softmax(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass InlinePrimitives
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  nn.softmax(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass FoldConstant
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  nn.softmax(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass FoldConstant
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  nn.softmax(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass FoldScaleAxis
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  nn.softmax(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass FoldConstant
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  nn.softmax(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass FuseOps
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  %0 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  %0(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass ToANormalForm
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  let %x1 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  let %x2 = %x1(%x);
  %x2
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass InferType
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  let %x1: fn (Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  let %x2: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %x1(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */;
  %x2
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass LambdaLift
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  let %x1: fn (Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  let %x2: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %x1(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */;
  %x2
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass Inline
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  %0 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  let %x1: fn (Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %0;
  let %x2: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %0(%x);
  %x2
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass DeadCodeElimination
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  %0 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  let %x1: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %0(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */;
  %x1
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass InlinePrimitives
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  %0 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  let %x1: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %0(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */;
  %x1
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass InlineGlobals
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  %0 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  let %x1: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %0(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */;
  %x1
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass RemoveUnusedFunctions
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  %0 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  let %x1: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %0(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */;
  %x1
}


[11:49:24] /workspace/home/codes/tvm/src/driver/driver_api.cc:139: LOWER INFERBOUND BEFORE
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0, ): range(min=0, ext=4)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0, range(min=0, ext=4)): range(min=0, ext=4)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, 3]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, 3]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[11:49:24] /workspace/home/codes/tvm/src/driver/driver_api.cc:149: Func before opt
[11:49:24] /workspace/home/codes/tvm/src/driver/driver_api.cc:150: primfn(placeholder_1: handle, compute_1: handle) -> ()
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  attr [compute] "realize_scope" = "";
  realize(compute, [0:4], True {
    for (i0: int32, 0, 4) {
      compute[i0] = placeholder[i0]
    }
  })
}
[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectPrefetch
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  attr [compute] "realize_scope" = "";
  realize(compute, [0:4], True {
    for (i0: int32, 0, 4) {
      compute[i0] = placeholder[i0]
    }
  })
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.StorageFlatten
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16Promote
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16CastElimination
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16TypeLowering
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16Legalize
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.NarrowDataType
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LoopPartition
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.VectorizeLoop
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectVirtualThread
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectDoubleBuffer
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.StorageRewrite
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.UnrollLoop
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.RemoveNoOp
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.RewriteUnsafeSelect
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass ManifestAlloc
type Storage {
  
}

def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  let %in_shape_0: Tensor[(4), int64] = vm.shape_of(%x, meta[relay.attrs.ShapeOfAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %storage_0: Storage[] = memory.alloc_storage(32 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][0]) /* ty=Storage[] */;
  let %tensor_0: Tensor[(4), int64] = memory.alloc_tensor(%storage_0, 0 /* ty=int64 */, meta[relay.Constant][0] /* ty=Tensor[(1), int64] */, meta[relay.attrs.AllocTensorAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %shape_func_out_0: Tensor[(4), int64] = %tensor_0;
  %0 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  %1 = (%in_shape_0,);
  %2 = (%shape_func_out_0,);
  let %shape_func: () = vm.shape_func(%0, %1, %2, meta[relay.attrs.ShapeFuncAttrs][0]) /* ty=() */;
  %3 = add(32 /* ty=int64 */, 7 /* ty=int64 */) /* ty=int64 */;
  %4 = prod(%shape_func_out_0) /* ty=int64 */;
  %5 = divide(%3, 8 /* ty=int64 */) /* ty=int64 */;
  %6 = multiply(%4, %5) /* ty=int64 */;
  let %storage_01: Storage[] = memory.alloc_storage(%6, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][1]) /* ty=Storage[] */;
  let %out_0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = memory.alloc_tensor(%storage_01, 0 /* ty=int64 */, %shape_func_out_0, meta[relay.attrs.AllocTensorAttrs][1]) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */;
  %7 = (%x,);
  %8 = (%out_0,);
  let %x1: () = vm.invoke_tvm_op(%0, %7, %8) /* ty=() */;
  let %x2: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %out_0;
  %x2
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass FuseOps
type Storage {
  
}

def @main() -> int64 {
  %0 = fn (%p0: int64, %p1: int64, Primitive=1) -> int64 {
    add(%p0, %p1) /* ty=int64 */
  };
  %0(32 /* ty=int64 */, 7 /* ty=int64 */) /* ty=int64 */
}

[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass ToANormalForm
type Storage {
  
}

def @main() -> int64 {
  let %x = 32 /* ty=int64 */;
  let %x1 = 7 /* ty=int64 */;
  let %x2 = fn (%p0: int64, %p1: int64, Primitive=1) -> int64 {
    add(%p0, %p1) /* ty=int64 */
  };
  let %x3 = %x2(%x, %x1);
  %x3
}

[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass InferType
type Storage {
  
}

def @main() -> int64 {
  let %x: int64 = 32 /* ty=int64 */;
  let %x1: int64 = 7 /* ty=int64 */;
  let %x2: fn (int64, int64) -> int64 = fn (%p0: int64, %p1: int64, Primitive=1) -> int64 {
    add(%p0, %p1) /* ty=int64 */
  };
  let %x3: int64 = %x2(%x, %x1) /* ty=int64 */;
  %x3
}

[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass EtaExpand
type Storage {
  
}

def @main() -> int64 {
  let %x: int64 = 32 /* ty=int64 */;
  let %x1: int64 = 7 /* ty=int64 */;
  let %x2: fn (int64, int64) -> int64 = fn (%p0: int64, %p1: int64, Primitive=1) -> int64 {
    add(%p0, %p1)
  };
  let %x3: int64 = %x2(%x, %x1);
  %x3
}

[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass InferType
type Storage {
  
}

def @main() -> int64 {
  let %x: int64 = 32 /* ty=int64 */;
  let %x1: int64 = 7 /* ty=int64 */;
  let %x2: fn (int64, int64) -> int64 = fn (%p0: int64, %p1: int64, Primitive=1) -> int64 {
    add(%p0, %p1) /* ty=int64 */
  };
  let %x3: int64 = %x2(%x, %x1) /* ty=int64 */;
  %x3
}

[11:49:24] /workspace/home/codes/tvm/src/relay/backend/compile_engine.cc:767: POS1
[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectPrefetch
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  attr [T_add] "realize_scope" = "";
  realize(T_add, [], True {
    T_add[] = (placeholder[] + placeholder_1[])
  })
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.StorageFlatten
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16Promote
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16CastElimination
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16TypeLowering
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16Legalize
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.NarrowDataType
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LoopPartition
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.VectorizeLoop
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectVirtualThread
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectDoubleBuffer
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.StorageRewrite
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.UnrollLoop
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.RemoveNoOp
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.RewriteUnsafeSelect
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.HoistIfThenElse
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/relay/backend/compile_engine.cc:778: POS4
[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerReduction
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.PlanAndUpdateBufferAllocationLocation
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.ConvertBlocksToOpaque
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.CompactBufferAllocation
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.FlattenBuffer
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16Promote
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16CastElimination
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16TypeLowering
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16Legalize
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.NarrowDataType
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LoopPartition
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.VectorizeLoop
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectVirtualThread
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectDoubleBuffer
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.StorageRewrite
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.UnrollLoop
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.RemoveNoOp
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.RewriteUnsafeSelect
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.HoistIfThenElse
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.VerifyMemory
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass Apply
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True, "target": meta[Target][0], "tir.is_entry_func": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.ThreadSync
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True, "target": meta[Target][0], "tir.is_entry_func": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.ThreadSync
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True, "target": meta[Target][0], "tir.is_entry_func": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InferFragment
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True, "target": meta[Target][0], "tir.is_entry_func": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerThreadAllreduce
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True, "target": meta[Target][0], "tir.is_entry_func": True}
  buffers = {T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.MakePackedAPI
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_add", "tir.is_entry_func": True, "calling_conv": 1} {
  assert((num_args == 3), "fused_add: num_args should be 3")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let arg2: handle = @tir.tvm_struct_get(args, 2, 12, dtype=handle)
  let arg2.code: int32 = (int32*)arg_type_ids[2]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let T_add: Pointer(int64) = @tir.tvm_struct_get(arg2, 0, 1, dtype=handle)
  attr [T_add] "storage_alignment" = 128;
  let arg2.shape: handle = @tir.tvm_struct_get(arg2, 0, 2, dtype=handle)
  let arg2.strides: handle = @tir.tvm_struct_get(arg2, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_add: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_add: Expect arg[1] to be pointer")
  assert(((((arg2.code == 3) || (arg2.code == 13)) || (arg2.code == 7)) || (arg2.code == 4)), "fused_add: Expect arg[2] to be pointer")
  attr ["default"] "device_id" = dev_id;
  attr ["default"] "device_type" = 1;
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg2, 0, 7, dtype=uint16) == 1u16)), "arg2.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg2, 0, 8, dtype=uint64)), "Argument arg2.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg2, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg2, 0, 10, dtype=int32)), "Argument arg2.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg2, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg2, 0, 9, dtype=int32)), "Argument arg2.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg2, 0, 9))")
  attr [0] "compute_scope" = "fused_add_compute_";
  T_add[0] = ((int64*)placeholder[0] + (int64*)placeholder_1[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.SplitHostDevice
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": (nullptr), "tir.noalias": True, "global_symbol": "fused_add", "tir.is_entry_func": True, "calling_conv": 1} {
  assert((num_args == 3), "fused_add: num_args should be 3")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let arg2: handle = @tir.tvm_struct_get(args, 2, 12, dtype=handle)
  let arg2.code: int32 = (int32*)arg_type_ids[2]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let T_add: Pointer(int64) = @tir.tvm_struct_get(arg2, 0, 1, dtype=handle)
  attr [T_add] "storage_alignment" = 128;
  let arg2.shape: handle = @tir.tvm_struct_get(arg2, 0, 2, dtype=handle)
  let arg2.strides: handle = @tir.tvm_struct_get(arg2, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_add: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_add: Expect arg[1] to be pointer")
  assert(((((arg2.code == 3) || (arg2.code == 13)) || (arg2.code == 7)) || (arg2.code == 4)), "fused_add: Expect arg[2] to be pointer")
  attr ["default"] "device_id" = dev_id;
  attr ["default"] "device_type" = 1;
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg2, 0, 7, dtype=uint16) == 1u16)), "arg2.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg2, 0, 8, dtype=uint64)), "Argument arg2.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg2, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg2, 0, 10, dtype=int32)), "Argument arg2.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg2, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg2, 0, 9, dtype=int32)), "Argument arg2.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg2, 0, 9))")
  attr [0] "compute_scope" = "fused_add_compute_";
  T_add[0] = ((int64*)placeholder[0] + (int64*)placeholder_1[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass Filter

[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerWarpMemory

[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify

[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerDeviceStorageAccessInfo

[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerCustomDatatypes

[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerIntrin

[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass Filter
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": (nullptr), "tir.noalias": True, "global_symbol": "fused_add", "tir.is_entry_func": True, "calling_conv": 1} {
  assert((num_args == 3), "fused_add: num_args should be 3")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let arg2: handle = @tir.tvm_struct_get(args, 2, 12, dtype=handle)
  let arg2.code: int32 = (int32*)arg_type_ids[2]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let T_add: Pointer(int64) = @tir.tvm_struct_get(arg2, 0, 1, dtype=handle)
  attr [T_add] "storage_alignment" = 128;
  let arg2.shape: handle = @tir.tvm_struct_get(arg2, 0, 2, dtype=handle)
  let arg2.strides: handle = @tir.tvm_struct_get(arg2, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_add: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_add: Expect arg[1] to be pointer")
  assert(((((arg2.code == 3) || (arg2.code == 13)) || (arg2.code == 7)) || (arg2.code == 4)), "fused_add: Expect arg[2] to be pointer")
  attr ["default"] "device_id" = dev_id;
  attr ["default"] "device_type" = 1;
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg2, 0, 7, dtype=uint16) == 1u16)), "arg2.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg2, 0, 8, dtype=uint64)), "Argument arg2.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg2, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg2, 0, 10, dtype=int32)), "Argument arg2.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg2, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg2, 0, 9, dtype=int32)), "Argument arg2.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg2, 0, 9))")
  attr [0] "compute_scope" = "fused_add_compute_";
  T_add[0] = ((int64*)placeholder[0] + (int64*)placeholder_1[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass Apply
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_add", "tir.is_entry_func": True, "calling_conv": 1} {
  assert((num_args == 3), "fused_add: num_args should be 3")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let arg2: handle = @tir.tvm_struct_get(args, 2, 12, dtype=handle)
  let arg2.code: int32 = (int32*)arg_type_ids[2]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let T_add: Pointer(int64) = @tir.tvm_struct_get(arg2, 0, 1, dtype=handle)
  attr [T_add] "storage_alignment" = 128;
  let arg2.shape: handle = @tir.tvm_struct_get(arg2, 0, 2, dtype=handle)
  let arg2.strides: handle = @tir.tvm_struct_get(arg2, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_add: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_add: Expect arg[1] to be pointer")
  assert(((((arg2.code == 3) || (arg2.code == 13)) || (arg2.code == 7)) || (arg2.code == 4)), "fused_add: Expect arg[2] to be pointer")
  attr ["default"] "device_id" = dev_id;
  attr ["default"] "device_type" = 1;
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg2, 0, 7, dtype=uint16) == 1u16)), "arg2.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg2, 0, 8, dtype=uint64)), "Argument arg2.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg2, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg2, 0, 10, dtype=int32)), "Argument arg2.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg2, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg2, 0, 9, dtype=int32)), "Argument arg2.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg2, 0, 9))")
  attr [0] "compute_scope" = "fused_add_compute_";
  T_add[0] = ((int64*)placeholder[0] + (int64*)placeholder_1[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerTVMBuiltin
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_add", "tir.is_entry_func": True, "calling_conv": 1} {
  assert((num_args == 3), "fused_add: num_args should be 3")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let arg2: handle = @tir.tvm_struct_get(args, 2, 12, dtype=handle)
  let arg2.code: int32 = (int32*)arg_type_ids[2]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let T_add: Pointer(int64) = @tir.tvm_struct_get(arg2, 0, 1, dtype=handle)
  attr [T_add] "storage_alignment" = 128;
  let arg2.shape: handle = @tir.tvm_struct_get(arg2, 0, 2, dtype=handle)
  let arg2.strides: handle = @tir.tvm_struct_get(arg2, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_add: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_add: Expect arg[1] to be pointer")
  assert(((((arg2.code == 3) || (arg2.code == 13)) || (arg2.code == 7)) || (arg2.code == 4)), "fused_add: Expect arg[2] to be pointer")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg2, 0, 7, dtype=uint16) == 1u16)), "arg2.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg2, 0, 8, dtype=uint64)), "Argument arg2.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg2, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg2, 0, 10, dtype=int32)), "Argument arg2.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg2, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg2, 0, 9, dtype=int32)), "Argument arg2.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg2, 0, 9))")
  attr [0] "compute_scope" = "fused_add_compute_";
  T_add[0] = ((int64*)placeholder[0] + (int64*)placeholder_1[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerDeviceStorageAccessInfo
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_add", "tir.is_entry_func": True, "calling_conv": 1} {
  assert((num_args == 3), "fused_add: num_args should be 3")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let arg2: handle = @tir.tvm_struct_get(args, 2, 12, dtype=handle)
  let arg2.code: int32 = (int32*)arg_type_ids[2]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let T_add: Pointer(int64) = @tir.tvm_struct_get(arg2, 0, 1, dtype=handle)
  attr [T_add] "storage_alignment" = 128;
  let arg2.shape: handle = @tir.tvm_struct_get(arg2, 0, 2, dtype=handle)
  let arg2.strides: handle = @tir.tvm_struct_get(arg2, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_add: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_add: Expect arg[1] to be pointer")
  assert(((((arg2.code == 3) || (arg2.code == 13)) || (arg2.code == 7)) || (arg2.code == 4)), "fused_add: Expect arg[2] to be pointer")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg2, 0, 7, dtype=uint16) == 1u16)), "arg2.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg2, 0, 8, dtype=uint64)), "Argument arg2.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg2, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg2, 0, 10, dtype=int32)), "Argument arg2.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg2, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg2, 0, 9, dtype=int32)), "Argument arg2.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg2, 0, 9))")
  attr [0] "compute_scope" = "fused_add_compute_";
  T_add[0] = ((int64*)placeholder[0] + (int64*)placeholder_1[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerCustomDatatypes
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_add", "tir.is_entry_func": True, "calling_conv": 1} {
  assert((num_args == 3), "fused_add: num_args should be 3")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let arg2: handle = @tir.tvm_struct_get(args, 2, 12, dtype=handle)
  let arg2.code: int32 = (int32*)arg_type_ids[2]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let T_add: Pointer(int64) = @tir.tvm_struct_get(arg2, 0, 1, dtype=handle)
  attr [T_add] "storage_alignment" = 128;
  let arg2.shape: handle = @tir.tvm_struct_get(arg2, 0, 2, dtype=handle)
  let arg2.strides: handle = @tir.tvm_struct_get(arg2, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_add: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_add: Expect arg[1] to be pointer")
  assert(((((arg2.code == 3) || (arg2.code == 13)) || (arg2.code == 7)) || (arg2.code == 4)), "fused_add: Expect arg[2] to be pointer")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg2, 0, 7, dtype=uint16) == 1u16)), "arg2.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg2, 0, 8, dtype=uint64)), "Argument arg2.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg2, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg2, 0, 10, dtype=int32)), "Argument arg2.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg2, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg2, 0, 9, dtype=int32)), "Argument arg2.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg2, 0, 9))")
  attr [0] "compute_scope" = "fused_add_compute_";
  T_add[0] = ((int64*)placeholder[0] + (int64*)placeholder_1[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerIntrin
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_add", "tir.is_entry_func": True, "calling_conv": 1} {
  assert((num_args == 3), "fused_add: num_args should be 3")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let arg2: handle = @tir.tvm_struct_get(args, 2, 12, dtype=handle)
  let arg2.code: int32 = (int32*)arg_type_ids[2]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let T_add: Pointer(int64) = @tir.tvm_struct_get(arg2, 0, 1, dtype=handle)
  attr [T_add] "storage_alignment" = 128;
  let arg2.shape: handle = @tir.tvm_struct_get(arg2, 0, 2, dtype=handle)
  let arg2.strides: handle = @tir.tvm_struct_get(arg2, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_add: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_add: Expect arg[1] to be pointer")
  assert(((((arg2.code == 3) || (arg2.code == 13)) || (arg2.code == 7)) || (arg2.code == 4)), "fused_add: Expect arg[2] to be pointer")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg2, 0, 7, dtype=uint16) == 1u16)), "arg2.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg2, 0, 8, dtype=uint64)), "Argument arg2.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg2, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg2, 0, 10, dtype=int32)), "Argument arg2.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg2, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg2, 0, 9, dtype=int32)), "Argument arg2.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg2, 0, 9))")
  attr [0] "compute_scope" = "fused_add_compute_";
  T_add[0] = ((int64*)placeholder[0] + (int64*)placeholder_1[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.CombineContextCall
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_add", "tir.is_entry_func": True, "calling_conv": 1} {
  assert((num_args == 3), "fused_add: num_args should be 3")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let arg2: handle = @tir.tvm_struct_get(args, 2, 12, dtype=handle)
  let arg2.code: int32 = (int32*)arg_type_ids[2]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let T_add: Pointer(int64) = @tir.tvm_struct_get(arg2, 0, 1, dtype=handle)
  attr [T_add] "storage_alignment" = 128;
  let arg2.shape: handle = @tir.tvm_struct_get(arg2, 0, 2, dtype=handle)
  let arg2.strides: handle = @tir.tvm_struct_get(arg2, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_add: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_add: Expect arg[1] to be pointer")
  assert(((((arg2.code == 3) || (arg2.code == 13)) || (arg2.code == 7)) || (arg2.code == 4)), "fused_add: Expect arg[2] to be pointer")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg2, 0, 7, dtype=uint16) == 1u16)), "arg2.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg2, 0, 8, dtype=uint64)), "Argument arg2.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg2, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg2, 0, 10, dtype=int32)), "Argument arg2.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg2, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg2, 0, 9, dtype=int32)), "Argument arg2.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg2, 0, 9))")
  attr [0] "compute_scope" = "fused_add_compute_";
  T_add[0] = ((int64*)placeholder[0] + (int64*)placeholder_1[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass FuseOps
type Storage {
  
}

def @main() -> int64 {
  %0 = fn (%p0: int64, %p1: int64, Primitive=1) -> int64 {
    divide(%p0, %p1) /* ty=int64 */
  };
  %0(39 /* ty=int64 */, 8 /* ty=int64 */) /* ty=int64 */
}

[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass ToANormalForm
type Storage {
  
}

def @main() -> int64 {
  let %x = 39 /* ty=int64 */;
  let %x1 = 8 /* ty=int64 */;
  let %x2 = fn (%p0: int64, %p1: int64, Primitive=1) -> int64 {
    divide(%p0, %p1) /* ty=int64 */
  };
  let %x3 = %x2(%x, %x1);
  %x3
}

[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass InferType
type Storage {
  
}

def @main() -> int64 {
  let %x: int64 = 39 /* ty=int64 */;
  let %x1: int64 = 8 /* ty=int64 */;
  let %x2: fn (int64, int64) -> int64 = fn (%p0: int64, %p1: int64, Primitive=1) -> int64 {
    divide(%p0, %p1) /* ty=int64 */
  };
  let %x3: int64 = %x2(%x, %x1) /* ty=int64 */;
  %x3
}

[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass EtaExpand
type Storage {
  
}

def @main() -> int64 {
  let %x: int64 = 39 /* ty=int64 */;
  let %x1: int64 = 8 /* ty=int64 */;
  let %x2: fn (int64, int64) -> int64 = fn (%p0: int64, %p1: int64, Primitive=1) -> int64 {
    divide(%p0, %p1)
  };
  let %x3: int64 = %x2(%x, %x1);
  %x3
}

[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass InferType
type Storage {
  
}

def @main() -> int64 {
  let %x: int64 = 39 /* ty=int64 */;
  let %x1: int64 = 8 /* ty=int64 */;
  let %x2: fn (int64, int64) -> int64 = fn (%p0: int64, %p1: int64, Primitive=1) -> int64 {
    divide(%p0, %p1) /* ty=int64 */
  };
  let %x3: int64 = %x2(%x, %x1) /* ty=int64 */;
  %x3
}

[11:49:24] /workspace/home/codes/tvm/src/relay/backend/compile_engine.cc:767: POS1
[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectPrefetch
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  attr [T_divide] "realize_scope" = "";
  realize(T_divide, [], True {
    T_divide[] = (placeholder[] / placeholder_1[])
  })
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.StorageFlatten
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16Promote
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16CastElimination
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16TypeLowering
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16Legalize
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.NarrowDataType
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LoopPartition
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.VectorizeLoop
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectVirtualThread
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectDoubleBuffer
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.StorageRewrite
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.UnrollLoop
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.RemoveNoOp
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.RewriteUnsafeSelect
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.HoistIfThenElse
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/relay/backend/compile_engine.cc:778: POS4
[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerReduction
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.PlanAndUpdateBufferAllocationLocation
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.ConvertBlocksToOpaque
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.CompactBufferAllocation
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.FlattenBuffer
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16Promote
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16CastElimination
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16TypeLowering
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16Legalize
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.NarrowDataType
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LoopPartition
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.VectorizeLoop
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectVirtualThread
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectDoubleBuffer
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.StorageRewrite
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.UnrollLoop
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.RemoveNoOp
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.RewriteUnsafeSelect
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.HoistIfThenElse
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.VerifyMemory
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass Apply
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True, "target": meta[Target][0], "tir.is_entry_func": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.ThreadSync
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True, "target": meta[Target][0], "tir.is_entry_func": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.ThreadSync
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True, "target": meta[Target][0], "tir.is_entry_func": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InferFragment
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True, "target": meta[Target][0], "tir.is_entry_func": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerThreadAllreduce
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True, "target": meta[Target][0], "tir.is_entry_func": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.MakePackedAPI
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_divide", "tir.is_entry_func": True, "calling_conv": 1} {
  assert((num_args == 3), "fused_divide: num_args should be 3")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let arg2: handle = @tir.tvm_struct_get(args, 2, 12, dtype=handle)
  let arg2.code: int32 = (int32*)arg_type_ids[2]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let T_divide: Pointer(int64) = @tir.tvm_struct_get(arg2, 0, 1, dtype=handle)
  attr [T_divide] "storage_alignment" = 128;
  let arg2.shape: handle = @tir.tvm_struct_get(arg2, 0, 2, dtype=handle)
  let arg2.strides: handle = @tir.tvm_struct_get(arg2, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_divide: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_divide: Expect arg[1] to be pointer")
  assert(((((arg2.code == 3) || (arg2.code == 13)) || (arg2.code == 7)) || (arg2.code == 4)), "fused_divide: Expect arg[2] to be pointer")
  attr ["default"] "device_id" = dev_id;
  attr ["default"] "device_type" = 1;
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg2, 0, 7, dtype=uint16) == 1u16)), "arg2.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg2, 0, 8, dtype=uint64)), "Argument arg2.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg2, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg2, 0, 10, dtype=int32)), "Argument arg2.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg2, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg2, 0, 9, dtype=int32)), "Argument arg2.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg2, 0, 9))")
  attr [0] "compute_scope" = "fused_divide_compute_";
  T_divide[0] = ((int64*)placeholder[0] / (int64*)placeholder_1[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.SplitHostDevice
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": (nullptr), "tir.noalias": True, "global_symbol": "fused_divide", "tir.is_entry_func": True, "calling_conv": 1} {
  assert((num_args == 3), "fused_divide: num_args should be 3")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let arg2: handle = @tir.tvm_struct_get(args, 2, 12, dtype=handle)
  let arg2.code: int32 = (int32*)arg_type_ids[2]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let T_divide: Pointer(int64) = @tir.tvm_struct_get(arg2, 0, 1, dtype=handle)
  attr [T_divide] "storage_alignment" = 128;
  let arg2.shape: handle = @tir.tvm_struct_get(arg2, 0, 2, dtype=handle)
  let arg2.strides: handle = @tir.tvm_struct_get(arg2, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_divide: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_divide: Expect arg[1] to be pointer")
  assert(((((arg2.code == 3) || (arg2.code == 13)) || (arg2.code == 7)) || (arg2.code == 4)), "fused_divide: Expect arg[2] to be pointer")
  attr ["default"] "device_id" = dev_id;
  attr ["default"] "device_type" = 1;
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg2, 0, 7, dtype=uint16) == 1u16)), "arg2.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg2, 0, 8, dtype=uint64)), "Argument arg2.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg2, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg2, 0, 10, dtype=int32)), "Argument arg2.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg2, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg2, 0, 9, dtype=int32)), "Argument arg2.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg2, 0, 9))")
  attr [0] "compute_scope" = "fused_divide_compute_";
  T_divide[0] = ((int64*)placeholder[0] / (int64*)placeholder_1[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass Filter

[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerWarpMemory

[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify

[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerDeviceStorageAccessInfo

[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerCustomDatatypes

[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerIntrin

[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass Filter
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": (nullptr), "tir.noalias": True, "global_symbol": "fused_divide", "tir.is_entry_func": True, "calling_conv": 1} {
  assert((num_args == 3), "fused_divide: num_args should be 3")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let arg2: handle = @tir.tvm_struct_get(args, 2, 12, dtype=handle)
  let arg2.code: int32 = (int32*)arg_type_ids[2]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let T_divide: Pointer(int64) = @tir.tvm_struct_get(arg2, 0, 1, dtype=handle)
  attr [T_divide] "storage_alignment" = 128;
  let arg2.shape: handle = @tir.tvm_struct_get(arg2, 0, 2, dtype=handle)
  let arg2.strides: handle = @tir.tvm_struct_get(arg2, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_divide: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_divide: Expect arg[1] to be pointer")
  assert(((((arg2.code == 3) || (arg2.code == 13)) || (arg2.code == 7)) || (arg2.code == 4)), "fused_divide: Expect arg[2] to be pointer")
  attr ["default"] "device_id" = dev_id;
  attr ["default"] "device_type" = 1;
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg2, 0, 7, dtype=uint16) == 1u16)), "arg2.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg2, 0, 8, dtype=uint64)), "Argument arg2.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg2, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg2, 0, 10, dtype=int32)), "Argument arg2.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg2, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg2, 0, 9, dtype=int32)), "Argument arg2.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg2, 0, 9))")
  attr [0] "compute_scope" = "fused_divide_compute_";
  T_divide[0] = ((int64*)placeholder[0] / (int64*)placeholder_1[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass Apply
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_divide", "tir.is_entry_func": True, "calling_conv": 1} {
  assert((num_args == 3), "fused_divide: num_args should be 3")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let arg2: handle = @tir.tvm_struct_get(args, 2, 12, dtype=handle)
  let arg2.code: int32 = (int32*)arg_type_ids[2]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let T_divide: Pointer(int64) = @tir.tvm_struct_get(arg2, 0, 1, dtype=handle)
  attr [T_divide] "storage_alignment" = 128;
  let arg2.shape: handle = @tir.tvm_struct_get(arg2, 0, 2, dtype=handle)
  let arg2.strides: handle = @tir.tvm_struct_get(arg2, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_divide: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_divide: Expect arg[1] to be pointer")
  assert(((((arg2.code == 3) || (arg2.code == 13)) || (arg2.code == 7)) || (arg2.code == 4)), "fused_divide: Expect arg[2] to be pointer")
  attr ["default"] "device_id" = dev_id;
  attr ["default"] "device_type" = 1;
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg2, 0, 7, dtype=uint16) == 1u16)), "arg2.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg2, 0, 8, dtype=uint64)), "Argument arg2.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg2, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg2, 0, 10, dtype=int32)), "Argument arg2.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg2, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg2, 0, 9, dtype=int32)), "Argument arg2.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg2, 0, 9))")
  attr [0] "compute_scope" = "fused_divide_compute_";
  T_divide[0] = ((int64*)placeholder[0] / (int64*)placeholder_1[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerTVMBuiltin
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_divide", "tir.is_entry_func": True, "calling_conv": 1} {
  assert((num_args == 3), "fused_divide: num_args should be 3")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let arg2: handle = @tir.tvm_struct_get(args, 2, 12, dtype=handle)
  let arg2.code: int32 = (int32*)arg_type_ids[2]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let T_divide: Pointer(int64) = @tir.tvm_struct_get(arg2, 0, 1, dtype=handle)
  attr [T_divide] "storage_alignment" = 128;
  let arg2.shape: handle = @tir.tvm_struct_get(arg2, 0, 2, dtype=handle)
  let arg2.strides: handle = @tir.tvm_struct_get(arg2, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_divide: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_divide: Expect arg[1] to be pointer")
  assert(((((arg2.code == 3) || (arg2.code == 13)) || (arg2.code == 7)) || (arg2.code == 4)), "fused_divide: Expect arg[2] to be pointer")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg2, 0, 7, dtype=uint16) == 1u16)), "arg2.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg2, 0, 8, dtype=uint64)), "Argument arg2.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg2, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg2, 0, 10, dtype=int32)), "Argument arg2.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg2, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg2, 0, 9, dtype=int32)), "Argument arg2.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg2, 0, 9))")
  attr [0] "compute_scope" = "fused_divide_compute_";
  T_divide[0] = ((int64*)placeholder[0] / (int64*)placeholder_1[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerDeviceStorageAccessInfo
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_divide", "tir.is_entry_func": True, "calling_conv": 1} {
  assert((num_args == 3), "fused_divide: num_args should be 3")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let arg2: handle = @tir.tvm_struct_get(args, 2, 12, dtype=handle)
  let arg2.code: int32 = (int32*)arg_type_ids[2]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let T_divide: Pointer(int64) = @tir.tvm_struct_get(arg2, 0, 1, dtype=handle)
  attr [T_divide] "storage_alignment" = 128;
  let arg2.shape: handle = @tir.tvm_struct_get(arg2, 0, 2, dtype=handle)
  let arg2.strides: handle = @tir.tvm_struct_get(arg2, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_divide: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_divide: Expect arg[1] to be pointer")
  assert(((((arg2.code == 3) || (arg2.code == 13)) || (arg2.code == 7)) || (arg2.code == 4)), "fused_divide: Expect arg[2] to be pointer")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg2, 0, 7, dtype=uint16) == 1u16)), "arg2.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg2, 0, 8, dtype=uint64)), "Argument arg2.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg2, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg2, 0, 10, dtype=int32)), "Argument arg2.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg2, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg2, 0, 9, dtype=int32)), "Argument arg2.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg2, 0, 9))")
  attr [0] "compute_scope" = "fused_divide_compute_";
  T_divide[0] = ((int64*)placeholder[0] / (int64*)placeholder_1[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerCustomDatatypes
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_divide", "tir.is_entry_func": True, "calling_conv": 1} {
  assert((num_args == 3), "fused_divide: num_args should be 3")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let arg2: handle = @tir.tvm_struct_get(args, 2, 12, dtype=handle)
  let arg2.code: int32 = (int32*)arg_type_ids[2]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let T_divide: Pointer(int64) = @tir.tvm_struct_get(arg2, 0, 1, dtype=handle)
  attr [T_divide] "storage_alignment" = 128;
  let arg2.shape: handle = @tir.tvm_struct_get(arg2, 0, 2, dtype=handle)
  let arg2.strides: handle = @tir.tvm_struct_get(arg2, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_divide: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_divide: Expect arg[1] to be pointer")
  assert(((((arg2.code == 3) || (arg2.code == 13)) || (arg2.code == 7)) || (arg2.code == 4)), "fused_divide: Expect arg[2] to be pointer")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg2, 0, 7, dtype=uint16) == 1u16)), "arg2.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg2, 0, 8, dtype=uint64)), "Argument arg2.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg2, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg2, 0, 10, dtype=int32)), "Argument arg2.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg2, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg2, 0, 9, dtype=int32)), "Argument arg2.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg2, 0, 9))")
  attr [0] "compute_scope" = "fused_divide_compute_";
  T_divide[0] = ((int64*)placeholder[0] / (int64*)placeholder_1[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerIntrin
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_divide", "tir.is_entry_func": True, "calling_conv": 1} {
  assert((num_args == 3), "fused_divide: num_args should be 3")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let arg2: handle = @tir.tvm_struct_get(args, 2, 12, dtype=handle)
  let arg2.code: int32 = (int32*)arg_type_ids[2]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let T_divide: Pointer(int64) = @tir.tvm_struct_get(arg2, 0, 1, dtype=handle)
  attr [T_divide] "storage_alignment" = 128;
  let arg2.shape: handle = @tir.tvm_struct_get(arg2, 0, 2, dtype=handle)
  let arg2.strides: handle = @tir.tvm_struct_get(arg2, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_divide: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_divide: Expect arg[1] to be pointer")
  assert(((((arg2.code == 3) || (arg2.code == 13)) || (arg2.code == 7)) || (arg2.code == 4)), "fused_divide: Expect arg[2] to be pointer")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg2, 0, 7, dtype=uint16) == 1u16)), "arg2.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg2, 0, 8, dtype=uint64)), "Argument arg2.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg2, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg2, 0, 10, dtype=int32)), "Argument arg2.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg2, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg2, 0, 9, dtype=int32)), "Argument arg2.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg2, 0, 9))")
  attr [0] "compute_scope" = "fused_divide_compute_";
  T_divide[0] = ((int64*)placeholder[0] / (int64*)placeholder_1[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.CombineContextCall
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_divide", "tir.is_entry_func": True, "calling_conv": 1} {
  assert((num_args == 3), "fused_divide: num_args should be 3")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let arg2: handle = @tir.tvm_struct_get(args, 2, 12, dtype=handle)
  let arg2.code: int32 = (int32*)arg_type_ids[2]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let T_divide: Pointer(int64) = @tir.tvm_struct_get(arg2, 0, 1, dtype=handle)
  attr [T_divide] "storage_alignment" = 128;
  let arg2.shape: handle = @tir.tvm_struct_get(arg2, 0, 2, dtype=handle)
  let arg2.strides: handle = @tir.tvm_struct_get(arg2, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_divide: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_divide: Expect arg[1] to be pointer")
  assert(((((arg2.code == 3) || (arg2.code == 13)) || (arg2.code == 7)) || (arg2.code == 4)), "fused_divide: Expect arg[2] to be pointer")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg2, 0, 7, dtype=uint16) == 1u16)), "arg2.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg2, 0, 8, dtype=uint64)), "Argument arg2.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg2, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg2, 0, 10, dtype=int32)), "Argument arg2.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg2, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg2, 0, 9, dtype=int32)), "Argument arg2.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg2, 0, 9))")
  attr [0] "compute_scope" = "fused_divide_compute_";
  T_divide[0] = ((int64*)placeholder[0] / (int64*)placeholder_1[0])
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass FoldConstant
type Storage {
  
}

def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  let %in_shape_0: Tensor[(4), int64] = vm.shape_of(%x, meta[relay.attrs.ShapeOfAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %storage_0: Storage[] = memory.alloc_storage(32 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][0]) /* ty=Storage[] */;
  let %tensor_0: Tensor[(4), int64] = memory.alloc_tensor(%storage_0, 0 /* ty=int64 */, meta[relay.Constant][0] /* ty=Tensor[(1), int64] */, meta[relay.attrs.AllocTensorAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %shape_func_out_0: Tensor[(4), int64] = %tensor_0;
  %0 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  %1 = (%in_shape_0,);
  %2 = (%shape_func_out_0,);
  let %shape_func: () = vm.shape_func(%0, %1, %2, meta[relay.attrs.ShapeFuncAttrs][0]) /* ty=() */;
  %3 = prod(%shape_func_out_0) /* ty=int64 */;
  %4 = multiply(%3, 4 /* ty=int64 */) /* ty=int64 */;
  let %storage_01: Storage[] = memory.alloc_storage(%4, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][1]) /* ty=Storage[] */;
  let %out_0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = memory.alloc_tensor(%storage_01, 0 /* ty=int64 */, %shape_func_out_0, meta[relay.attrs.AllocTensorAttrs][1]) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */;
  %5 = (%x,);
  %6 = (%out_0,);
  let %x1: () = vm.invoke_tvm_op(%0, %5, %6) /* ty=() */;
  let %x2: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %out_0;
  %x2
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass FuseOps
type Storage {
  
}

def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  let %in_shape_0: Tensor[(4), int64] = vm.shape_of(%x, meta[relay.attrs.ShapeOfAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %storage_0: Storage[] = memory.alloc_storage(32 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][0]) /* ty=Storage[] */;
  let %tensor_0: Tensor[(4), int64] = memory.alloc_tensor(%storage_0, 0 /* ty=int64 */, meta[relay.Constant][0] /* ty=Tensor[(1), int64] */, meta[relay.attrs.AllocTensorAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %shape_func_out_0: Tensor[(4), int64] = %tensor_0;
  %0 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  %1 = (%in_shape_0,);
  %2 = (%shape_func_out_0,);
  let %shape_func: () = vm.shape_func(%0, %1, %2, meta[relay.attrs.ShapeFuncAttrs][0]) /* ty=() */;
  %3 = fn (%p02: Tensor[(4), int64], Primitive=1) -> int64 {
    prod(%p02) /* ty=int64 */
  };
  %4 = %3(%shape_func_out_0) /* ty=int64 */;
  %5 = fn (%p01: int64, Primitive=1) -> int64 {
    multiply(%p01, 4 /* ty=int64 */) /* ty=int64 */
  };
  %6 = %5(%4) /* ty=int64 */;
  let %storage_01: Storage[] = memory.alloc_storage(%6, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][1]) /* ty=Storage[] */;
  let %out_0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = memory.alloc_tensor(%storage_01, 0 /* ty=int64 */, %shape_func_out_0, meta[relay.attrs.AllocTensorAttrs][1]) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */;
  %7 = (%x,);
  %8 = (%out_0,);
  let %x1: () = vm.invoke_tvm_op(%0, %7, %8) /* ty=() */;
  let %x2: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %out_0;
  %x2
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass ManifestAlloc
type Storage {
  
}

def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  let %in_shape_0: Tensor[(4), int64] = vm.shape_of(%x, meta[relay.attrs.ShapeOfAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %storage_0: Storage[] = memory.alloc_storage(32 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][0]) /* ty=Storage[] */;
  let %tensor_0: Tensor[(4), int64] = memory.alloc_tensor(%storage_0, 0 /* ty=int64 */, meta[relay.Constant][0] /* ty=Tensor[(1), int64] */, meta[relay.attrs.AllocTensorAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %shape_func_out_0: Tensor[(4), int64] = %tensor_0;
  %0 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  %1 = (%in_shape_0,);
  %2 = (%shape_func_out_0,);
  let %shape_func: () = vm.shape_func(%0, %1, %2, meta[relay.attrs.ShapeFuncAttrs][0]) /* ty=() */;
  let %storage_01: Storage[] = memory.alloc_storage(8 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][1]) /* ty=Storage[] */;
  let %tensor_01: int64 = memory.alloc_tensor(%storage_01, 0 /* ty=int64 */, meta[relay.Constant][1] /* ty=Tensor[(0), int64] */, meta[relay.attrs.AllocTensorAttrs][1]) /* ty=int64 */;
  %3 = fn (%p01: Tensor[(4), int64], Primitive=1) -> int64 {
    prod(%p01) /* ty=int64 */
  };
  %4 = (%shape_func_out_0,);
  %5 = (%tensor_01,);
  let %x1: () = vm.invoke_tvm_op(%3, %4, %5) /* ty=() */;
  let %storage_02: Storage[] = memory.alloc_storage(8 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][2]) /* ty=Storage[] */;
  let %tensor_02: int64 = memory.alloc_tensor(%storage_02, 0 /* ty=int64 */, meta[relay.Constant][2] /* ty=Tensor[(0), int64] */, meta[relay.attrs.AllocTensorAttrs][2]) /* ty=int64 */;
  %6 = fn (%p02: int64, Primitive=1) -> int64 {
    multiply(%p02, 4 /* ty=int64 */) /* ty=int64 */
  };
  %7 = (%tensor_01,);
  %8 = (%tensor_02,);
  let %x2: () = vm.invoke_tvm_op(%6, %7, %8) /* ty=() */;
  let %storage_03: Storage[] = memory.alloc_storage(%tensor_02, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][3]) /* ty=Storage[] */;
  let %out_0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = memory.alloc_tensor(%storage_03, 0 /* ty=int64 */, %shape_func_out_0, meta[relay.attrs.AllocTensorAttrs][3]) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */;
  %9 = (%x,);
  %10 = (%out_0,);
  let %x3: () = vm.invoke_tvm_op(%0, %9, %10) /* ty=() */;
  let %x4: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %out_0;
  %x4
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass FuseOps
type Storage {
  
}

def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  let %in_shape_0: Tensor[(4), int64] = vm.shape_of(%x, meta[relay.attrs.ShapeOfAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %storage_0: Storage[] = memory.alloc_storage(32 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][0]) /* ty=Storage[] */;
  let %tensor_0: Tensor[(4), int64] = memory.alloc_tensor(%storage_0, 0 /* ty=int64 */, meta[relay.Constant][0] /* ty=Tensor[(1), int64] */, meta[relay.attrs.AllocTensorAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %shape_func_out_0: Tensor[(4), int64] = %tensor_0;
  %0 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  %1 = (%in_shape_0,);
  %2 = (%shape_func_out_0,);
  let %shape_func: () = vm.shape_func(%0, %1, %2, meta[relay.attrs.ShapeFuncAttrs][0]) /* ty=() */;
  let %storage_01: Storage[] = memory.alloc_storage(8 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][1]) /* ty=Storage[] */;
  let %tensor_01: int64 = memory.alloc_tensor(%storage_01, 0 /* ty=int64 */, meta[relay.Constant][1] /* ty=Tensor[(0), int64] */, meta[relay.attrs.AllocTensorAttrs][1]) /* ty=int64 */;
  %3 = fn (%p01: Tensor[(4), int64], Primitive=1) -> int64 {
    prod(%p01) /* ty=int64 */
  };
  %4 = (%shape_func_out_0,);
  %5 = (%tensor_01,);
  let %x1: () = vm.invoke_tvm_op(%3, %4, %5) /* ty=() */;
  let %storage_02: Storage[] = memory.alloc_storage(8 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][2]) /* ty=Storage[] */;
  let %tensor_02: int64 = memory.alloc_tensor(%storage_02, 0 /* ty=int64 */, meta[relay.Constant][2] /* ty=Tensor[(0), int64] */, meta[relay.attrs.AllocTensorAttrs][2]) /* ty=int64 */;
  %6 = fn (%p02: int64, Primitive=1) -> int64 {
    multiply(%p02, 4 /* ty=int64 */) /* ty=int64 */
  };
  %7 = (%tensor_01,);
  %8 = (%tensor_02,);
  let %x2: () = vm.invoke_tvm_op(%6, %7, %8) /* ty=() */;
  let %storage_03: Storage[] = memory.alloc_storage(%tensor_02, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][3]) /* ty=Storage[] */;
  let %out_0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = memory.alloc_tensor(%storage_03, 0 /* ty=int64 */, %shape_func_out_0, meta[relay.attrs.AllocTensorAttrs][3]) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */;
  %9 = (%x,);
  %10 = (%out_0,);
  let %x3: () = vm.invoke_tvm_op(%0, %9, %10) /* ty=() */;
  let %x4: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %out_0;
  %x4
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass FoldConstant
type Storage {
  
}

def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  let %in_shape_0: Tensor[(4), int64] = vm.shape_of(%x, meta[relay.attrs.ShapeOfAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %storage_0: Storage[] = memory.alloc_storage(32 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][0]) /* ty=Storage[] */;
  let %tensor_0: Tensor[(4), int64] = memory.alloc_tensor(%storage_0, 0 /* ty=int64 */, meta[relay.Constant][0] /* ty=Tensor[(1), int64] */, meta[relay.attrs.AllocTensorAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %shape_func_out_0: Tensor[(4), int64] = %tensor_0;
  %0 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  %1 = (%in_shape_0,);
  %2 = (%shape_func_out_0,);
  let %shape_func: () = vm.shape_func(%0, %1, %2, meta[relay.attrs.ShapeFuncAttrs][0]) /* ty=() */;
  let %storage_01: Storage[] = memory.alloc_storage(8 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][1]) /* ty=Storage[] */;
  let %tensor_01: int64 = memory.alloc_tensor(%storage_01, 0 /* ty=int64 */, meta[relay.Constant][1] /* ty=Tensor[(0), int64] */, meta[relay.attrs.AllocTensorAttrs][1]) /* ty=int64 */;
  %3 = fn (%p01: Tensor[(4), int64], Primitive=1) -> int64 {
    prod(%p01) /* ty=int64 */
  };
  %4 = (%shape_func_out_0,);
  %5 = (%tensor_01,);
  let %x1: () = vm.invoke_tvm_op(%3, %4, %5) /* ty=() */;
  let %storage_02: Storage[] = memory.alloc_storage(8 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][2]) /* ty=Storage[] */;
  let %tensor_02: int64 = memory.alloc_tensor(%storage_02, 0 /* ty=int64 */, meta[relay.Constant][2] /* ty=Tensor[(0), int64] */, meta[relay.attrs.AllocTensorAttrs][2]) /* ty=int64 */;
  %6 = fn (%p02: int64, Primitive=1) -> int64 {
    multiply(%p02, 4 /* ty=int64 */) /* ty=int64 */
  };
  %7 = (%tensor_01,);
  %8 = (%tensor_02,);
  let %x2: () = vm.invoke_tvm_op(%6, %7, %8) /* ty=() */;
  let %storage_03: Storage[] = memory.alloc_storage(%tensor_02, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][3]) /* ty=Storage[] */;
  let %out_0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = memory.alloc_tensor(%storage_03, 0 /* ty=int64 */, %shape_func_out_0, meta[relay.attrs.AllocTensorAttrs][3]) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */;
  %9 = (%x,);
  %10 = (%out_0,);
  let %x3: () = vm.invoke_tvm_op(%0, %9, %10) /* ty=() */;
  let %x4: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %out_0;
  %x4
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass FuseOps
type Storage {
  
}

def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  let %in_shape_0: Tensor[(4), int64] = vm.shape_of(%x, meta[relay.attrs.ShapeOfAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %storage_0: Storage[] = memory.alloc_storage(32 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][0]) /* ty=Storage[] */;
  let %tensor_0: Tensor[(4), int64] = memory.alloc_tensor(%storage_0, 0 /* ty=int64 */, meta[relay.Constant][0] /* ty=Tensor[(1), int64] */, meta[relay.attrs.AllocTensorAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %shape_func_out_0: Tensor[(4), int64] = %tensor_0;
  %0 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  %1 = (%in_shape_0,);
  %2 = (%shape_func_out_0,);
  let %shape_func: () = vm.shape_func(%0, %1, %2, meta[relay.attrs.ShapeFuncAttrs][0]) /* ty=() */;
  let %storage_01: Storage[] = memory.alloc_storage(8 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][1]) /* ty=Storage[] */;
  let %tensor_01: int64 = memory.alloc_tensor(%storage_01, 0 /* ty=int64 */, meta[relay.Constant][1] /* ty=Tensor[(0), int64] */, meta[relay.attrs.AllocTensorAttrs][1]) /* ty=int64 */;
  %3 = fn (%p01: Tensor[(4), int64], Primitive=1) -> int64 {
    prod(%p01) /* ty=int64 */
  };
  %4 = (%shape_func_out_0,);
  %5 = (%tensor_01,);
  let %x1: () = vm.invoke_tvm_op(%3, %4, %5) /* ty=() */;
  let %storage_02: Storage[] = memory.alloc_storage(8 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][2]) /* ty=Storage[] */;
  let %tensor_02: int64 = memory.alloc_tensor(%storage_02, 0 /* ty=int64 */, meta[relay.Constant][2] /* ty=Tensor[(0), int64] */, meta[relay.attrs.AllocTensorAttrs][2]) /* ty=int64 */;
  %6 = fn (%p02: int64, Primitive=1) -> int64 {
    multiply(%p02, 4 /* ty=int64 */) /* ty=int64 */
  };
  %7 = (%tensor_01,);
  %8 = (%tensor_02,);
  let %x2: () = vm.invoke_tvm_op(%6, %7, %8) /* ty=() */;
  let %storage_03: Storage[] = memory.alloc_storage(%tensor_02, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][3]) /* ty=Storage[] */;
  let %out_0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = memory.alloc_tensor(%storage_03, 0 /* ty=int64 */, %shape_func_out_0, meta[relay.attrs.AllocTensorAttrs][3]) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */;
  %9 = (%x,);
  %10 = (%out_0,);
  let %x3: () = vm.invoke_tvm_op(%0, %9, %10) /* ty=() */;
  let %x4: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %out_0;
  %x4
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass ManifestAlloc
type Storage {
  
}

def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  let %in_shape_0: Tensor[(4), int64] = vm.shape_of(%x, meta[relay.attrs.ShapeOfAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %storage_0: Storage[] = memory.alloc_storage(32 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][0]) /* ty=Storage[] */;
  let %tensor_0: Tensor[(4), int64] = memory.alloc_tensor(%storage_0, 0 /* ty=int64 */, meta[relay.Constant][0] /* ty=Tensor[(1), int64] */, meta[relay.attrs.AllocTensorAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %shape_func_out_0: Tensor[(4), int64] = %tensor_0;
  %0 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  %1 = (%in_shape_0,);
  %2 = (%shape_func_out_0,);
  let %shape_func: () = vm.shape_func(%0, %1, %2, meta[relay.attrs.ShapeFuncAttrs][0]) /* ty=() */;
  let %storage_01: Storage[] = memory.alloc_storage(8 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][1]) /* ty=Storage[] */;
  let %tensor_01: int64 = memory.alloc_tensor(%storage_01, 0 /* ty=int64 */, meta[relay.Constant][1] /* ty=Tensor[(0), int64] */, meta[relay.attrs.AllocTensorAttrs][1]) /* ty=int64 */;
  %3 = fn (%p01: Tensor[(4), int64], Primitive=1) -> int64 {
    prod(%p01) /* ty=int64 */
  };
  %4 = (%shape_func_out_0,);
  %5 = (%tensor_01,);
  let %x1: () = vm.invoke_tvm_op(%3, %4, %5) /* ty=() */;
  let %storage_02: Storage[] = memory.alloc_storage(8 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][2]) /* ty=Storage[] */;
  let %tensor_02: int64 = memory.alloc_tensor(%storage_02, 0 /* ty=int64 */, meta[relay.Constant][2] /* ty=Tensor[(0), int64] */, meta[relay.attrs.AllocTensorAttrs][2]) /* ty=int64 */;
  %6 = fn (%p02: int64, Primitive=1) -> int64 {
    multiply(%p02, 4 /* ty=int64 */) /* ty=int64 */
  };
  %7 = (%tensor_01,);
  %8 = (%tensor_02,);
  let %x2: () = vm.invoke_tvm_op(%6, %7, %8) /* ty=() */;
  let %storage_03: Storage[] = memory.alloc_storage(%tensor_02, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][3]) /* ty=Storage[] */;
  let %out_0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = memory.alloc_tensor(%storage_03, 0 /* ty=int64 */, %shape_func_out_0, meta[relay.attrs.AllocTensorAttrs][3]) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */;
  %9 = (%x,);
  %10 = (%out_0,);
  let %x3: () = vm.invoke_tvm_op(%0, %9, %10) /* ty=() */;
  let %x4: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %out_0;
  %x4
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass FoldConstant
type Storage {
  
}

def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  let %in_shape_0: Tensor[(4), int64] = vm.shape_of(%x, meta[relay.attrs.ShapeOfAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %storage_0: Storage[] = memory.alloc_storage(32 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][0]) /* ty=Storage[] */;
  let %tensor_0: Tensor[(4), int64] = memory.alloc_tensor(%storage_0, 0 /* ty=int64 */, meta[relay.Constant][0] /* ty=Tensor[(1), int64] */, meta[relay.attrs.AllocTensorAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %shape_func_out_0: Tensor[(4), int64] = %tensor_0;
  %0 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  %1 = (%in_shape_0,);
  %2 = (%shape_func_out_0,);
  let %shape_func: () = vm.shape_func(%0, %1, %2, meta[relay.attrs.ShapeFuncAttrs][0]) /* ty=() */;
  let %storage_01: Storage[] = memory.alloc_storage(8 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][1]) /* ty=Storage[] */;
  let %tensor_01: int64 = memory.alloc_tensor(%storage_01, 0 /* ty=int64 */, meta[relay.Constant][1] /* ty=Tensor[(0), int64] */, meta[relay.attrs.AllocTensorAttrs][1]) /* ty=int64 */;
  %3 = fn (%p01: Tensor[(4), int64], Primitive=1) -> int64 {
    prod(%p01) /* ty=int64 */
  };
  %4 = (%shape_func_out_0,);
  %5 = (%tensor_01,);
  let %x1: () = vm.invoke_tvm_op(%3, %4, %5) /* ty=() */;
  let %storage_02: Storage[] = memory.alloc_storage(8 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][2]) /* ty=Storage[] */;
  let %tensor_02: int64 = memory.alloc_tensor(%storage_02, 0 /* ty=int64 */, meta[relay.Constant][2] /* ty=Tensor[(0), int64] */, meta[relay.attrs.AllocTensorAttrs][2]) /* ty=int64 */;
  %6 = fn (%p02: int64, Primitive=1) -> int64 {
    multiply(%p02, 4 /* ty=int64 */) /* ty=int64 */
  };
  %7 = (%tensor_01,);
  %8 = (%tensor_02,);
  let %x2: () = vm.invoke_tvm_op(%6, %7, %8) /* ty=() */;
  let %storage_03: Storage[] = memory.alloc_storage(%tensor_02, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][3]) /* ty=Storage[] */;
  let %out_0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = memory.alloc_tensor(%storage_03, 0 /* ty=int64 */, %shape_func_out_0, meta[relay.attrs.AllocTensorAttrs][3]) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */;
  %9 = (%x,);
  %10 = (%out_0,);
  let %x3: () = vm.invoke_tvm_op(%0, %9, %10) /* ty=() */;
  let %x4: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %out_0;
  %x4
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass sequential
type Storage {
  
}

def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  let %in_shape_0: Tensor[(4), int64] = vm.shape_of(%x, meta[relay.attrs.ShapeOfAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %storage_0: Storage[] = memory.alloc_storage(32 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][0]) /* ty=Storage[] */;
  let %tensor_0: Tensor[(4), int64] = memory.alloc_tensor(%storage_0, 0 /* ty=int64 */, meta[relay.Constant][0] /* ty=Tensor[(1), int64] */, meta[relay.attrs.AllocTensorAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %shape_func_out_0: Tensor[(4), int64] = %tensor_0;
  %0 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  %1 = (%in_shape_0,);
  %2 = (%shape_func_out_0,);
  let %shape_func: () = vm.shape_func(%0, %1, %2, meta[relay.attrs.ShapeFuncAttrs][0]) /* ty=() */;
  let %storage_01: Storage[] = memory.alloc_storage(8 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][1]) /* ty=Storage[] */;
  let %tensor_01: int64 = memory.alloc_tensor(%storage_01, 0 /* ty=int64 */, meta[relay.Constant][1] /* ty=Tensor[(0), int64] */, meta[relay.attrs.AllocTensorAttrs][1]) /* ty=int64 */;
  %3 = fn (%p01: Tensor[(4), int64], Primitive=1) -> int64 {
    prod(%p01) /* ty=int64 */
  };
  %4 = (%shape_func_out_0,);
  %5 = (%tensor_01,);
  let %x1: () = vm.invoke_tvm_op(%3, %4, %5) /* ty=() */;
  let %storage_02: Storage[] = memory.alloc_storage(8 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][2]) /* ty=Storage[] */;
  let %tensor_02: int64 = memory.alloc_tensor(%storage_02, 0 /* ty=int64 */, meta[relay.Constant][2] /* ty=Tensor[(0), int64] */, meta[relay.attrs.AllocTensorAttrs][2]) /* ty=int64 */;
  %6 = fn (%p02: int64, Primitive=1) -> int64 {
    multiply(%p02, 4 /* ty=int64 */) /* ty=int64 */
  };
  %7 = (%tensor_01,);
  %8 = (%tensor_02,);
  let %x2: () = vm.invoke_tvm_op(%6, %7, %8) /* ty=() */;
  let %storage_03: Storage[] = memory.alloc_storage(%tensor_02, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][3]) /* ty=Storage[] */;
  let %out_0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = memory.alloc_tensor(%storage_03, 0 /* ty=int64 */, %shape_func_out_0, meta[relay.attrs.AllocTensorAttrs][3]) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */;
  %9 = (%x,);
  %10 = (%out_0,);
  let %x3: () = vm.invoke_tvm_op(%0, %9, %10) /* ty=() */;
  let %x4: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %out_0;
  %x4
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass InferType
type Storage {
  
}

def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  let %in_shape_0: Tensor[(4), int64] = vm.shape_of(%x, meta[relay.attrs.ShapeOfAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %storage_0: Storage[] = memory.alloc_storage(32 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][0]) /* ty=Storage[] */;
  let %tensor_0: Tensor[(4), int64] = memory.alloc_tensor(%storage_0, 0 /* ty=int64 */, meta[relay.Constant][0] /* ty=Tensor[(1), int64] */, meta[relay.attrs.AllocTensorAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %shape_func_out_0: Tensor[(4), int64] = %tensor_0;
  %0 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  %1 = (%in_shape_0,);
  %2 = (%shape_func_out_0,);
  let %shape_func: () = vm.shape_func(%0, %1, %2, meta[relay.attrs.ShapeFuncAttrs][0]) /* ty=() */;
  let %storage_01: Storage[] = memory.alloc_storage(8 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][1]) /* ty=Storage[] */;
  let %tensor_01: int64 = memory.alloc_tensor(%storage_01, 0 /* ty=int64 */, meta[relay.Constant][1] /* ty=Tensor[(0), int64] */, meta[relay.attrs.AllocTensorAttrs][1]) /* ty=int64 */;
  %3 = fn (%p01: Tensor[(4), int64], Primitive=1) -> int64 {
    prod(%p01) /* ty=int64 */
  };
  %4 = (%shape_func_out_0,);
  %5 = (%tensor_01,);
  let %x1: () = vm.invoke_tvm_op(%3, %4, %5) /* ty=() */;
  let %storage_02: Storage[] = memory.alloc_storage(8 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][2]) /* ty=Storage[] */;
  let %tensor_02: int64 = memory.alloc_tensor(%storage_02, 0 /* ty=int64 */, meta[relay.Constant][2] /* ty=Tensor[(0), int64] */, meta[relay.attrs.AllocTensorAttrs][2]) /* ty=int64 */;
  %6 = fn (%p02: int64, Primitive=1) -> int64 {
    multiply(%p02, 4 /* ty=int64 */) /* ty=int64 */
  };
  %7 = (%tensor_01,);
  %8 = (%tensor_02,);
  let %x2: () = vm.invoke_tvm_op(%6, %7, %8) /* ty=() */;
  let %storage_03: Storage[] = memory.alloc_storage(%tensor_02, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][3]) /* ty=Storage[] */;
  let %out_0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = memory.alloc_tensor(%storage_03, 0 /* ty=int64 */, %shape_func_out_0, meta[relay.attrs.AllocTensorAttrs][3]) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */;
  %9 = (%x,);
  %10 = (%out_0,);
  let %x3: () = vm.invoke_tvm_op(%0, %9, %10) /* ty=() */;
  let %x4: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %out_0;
  %x4
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass LabelOps
type Storage {
  
}

def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], hash="0f7fbaf77c33d48b") -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  let %in_shape_0: Tensor[(4), int64] = vm.shape_of(%x, meta[relay.attrs.ShapeOfAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %storage_0: Storage[] = memory.alloc_storage(32 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][0]) /* ty=Storage[] */;
  let %tensor_0: Tensor[(4), int64] = memory.alloc_tensor(%storage_0, 0 /* ty=int64 */, meta[relay.Constant][0] /* ty=Tensor[(1), int64] */, meta[relay.attrs.AllocTensorAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %shape_func_out_0: Tensor[(4), int64] = %tensor_0;
  %0 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1, hash="f9a165078ab8ab77") -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  %1 = (%in_shape_0,);
  %2 = (%shape_func_out_0,);
  let %shape_func: () = vm.shape_func(%0, %1, %2, meta[relay.attrs.ShapeFuncAttrs][0]) /* ty=() */;
  let %storage_01: Storage[] = memory.alloc_storage(8 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][1]) /* ty=Storage[] */;
  let %tensor_01: int64 = memory.alloc_tensor(%storage_01, 0 /* ty=int64 */, meta[relay.Constant][1] /* ty=Tensor[(0), int64] */, meta[relay.attrs.AllocTensorAttrs][1]) /* ty=int64 */;
  %3 = fn (%p01: Tensor[(4), int64], Primitive=1, hash="75ec56f3169a1497") -> int64 {
    prod(%p01) /* ty=int64 */
  };
  %4 = (%shape_func_out_0,);
  %5 = (%tensor_01,);
  let %x1: () = vm.invoke_tvm_op(%3, %4, %5) /* ty=() */;
  let %storage_02: Storage[] = memory.alloc_storage(8 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][2]) /* ty=Storage[] */;
  let %tensor_02: int64 = memory.alloc_tensor(%storage_02, 0 /* ty=int64 */, meta[relay.Constant][2] /* ty=Tensor[(0), int64] */, meta[relay.attrs.AllocTensorAttrs][2]) /* ty=int64 */;
  %6 = fn (%p02: int64, Primitive=1, hash="e2e2680f0ff08f46") -> int64 {
    multiply(%p02, 4 /* ty=int64 */) /* ty=int64 */
  };
  %7 = (%tensor_01,);
  %8 = (%tensor_02,);
  let %x2: () = vm.invoke_tvm_op(%6, %7, %8) /* ty=() */;
  let %storage_03: Storage[] = memory.alloc_storage(%tensor_02, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][3]) /* ty=Storage[] */;
  let %out_0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = memory.alloc_tensor(%storage_03, 0 /* ty=int64 */, %shape_func_out_0, meta[relay.attrs.AllocTensorAttrs][3]) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */;
  %9 = (%x,);
  %10 = (%out_0,);
  let %x3: () = vm.invoke_tvm_op(%0, %9, %10) /* ty=() */;
  let %x4: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %out_0;
  %x4
}


[11:49:24] /workspace/home/codes/tvm/src/driver/driver_api.cc:139: LOWER INFERBOUND BEFORE
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0, ): range(min=0, ext=4)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0, range(min=0, ext=4)): range(min=0, ext=4)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, 3]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, 3]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[11:49:24] /workspace/home/codes/tvm/src/driver/driver_api.cc:149: Func before opt
[11:49:24] /workspace/home/codes/tvm/src/driver/driver_api.cc:150: primfn(placeholder_1: handle, compute_1: handle) -> ()
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  attr [compute] "realize_scope" = "";
  realize(compute, [0:4], True {
    for (i0: int32, 0, 4) {
      compute[i0] = placeholder[i0]
    }
  })
}
[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectPrefetch
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  attr [compute] "realize_scope" = "";
  realize(compute, [0:4], True {
    for (i0: int32, 0, 4) {
      compute[i0] = placeholder[i0]
    }
  })
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.StorageFlatten
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16Promote
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16CastElimination
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16TypeLowering
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16Legalize
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.NarrowDataType
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LoopPartition
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.VectorizeLoop
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectVirtualThread
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectDoubleBuffer
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.StorageRewrite
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.UnrollLoop
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.RemoveNoOp
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.RewriteUnsafeSelect
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[11:49:24] /workspace/home/codes/tvm/src/relay/backend/vm/compiler.cc:548: Lower Function Start
[11:49:24] /workspace/home/codes/tvm/src/relay/backend/vm/compiler.cc:549: fn (%p0: Tensor[(4), int64], Primitive=1, hash="75ec56f3169a1497") -> int64 {
  prod(%p0) /* ty=int64 */
}
[11:49:24] /workspace/home/codes/tvm/src/relay/backend/compile_engine.cc:767: POS1
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(k0, ): range(min=0, ext=4)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(k0, range(min=0, ext=4)): range(min=0, ext=4)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(singleton, range(min=0, ext=1)): range(min=0, ext=1)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert singleton: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k0: int32, IntervalSet[0, 3]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k0: int32, IntervalSet[0, 3]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert singleton: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k0: int32, IntervalSet[0, 3]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k0: int32, IntervalSet[0, 3]
[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectPrefetch
primfn(placeholder_1: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, placeholder_red_1: placeholder_red} {
  attr [placeholder_red] "realize_scope" = "";
  realize(placeholder_red, [], True {
    placeholder_red[] = 1i64
    for (k0: int32, 0, 4) {
      placeholder_red[] = (placeholder_red[]*placeholder[k0])
    }
  })
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.StorageFlatten
primfn(placeholder_1: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_2[k0])
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16Promote
primfn(placeholder_1: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_2[k0])
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16CastElimination
primfn(placeholder_1: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_2[k0])
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16TypeLowering
primfn(placeholder_1: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_2[k0])
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16Legalize
primfn(placeholder_1: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_2[k0])
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.NarrowDataType
primfn(placeholder_1: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_2[k0])
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify
primfn(placeholder_1: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_2[k0])
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LoopPartition
primfn(placeholder_1: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_2[k0])
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.VectorizeLoop
primfn(placeholder_1: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_2[k0])
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectVirtualThread
primfn(placeholder_1: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_2[k0])
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectDoubleBuffer
primfn(placeholder_1: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_2[k0])
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.StorageRewrite
primfn(placeholder_1: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_2[k0])
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.UnrollLoop
primfn(placeholder_1: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_2[k0])
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify
primfn(placeholder_1: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_2[k0])
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.RemoveNoOp
primfn(placeholder_1: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_2[k0])
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.RewriteUnsafeSelect
primfn(placeholder_1: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_2[k0])
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.HoistIfThenElse
primfn(placeholder_1: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_2[k0])
  }
}


[11:49:24] /workspace/home/codes/tvm/src/relay/backend/compile_engine.cc:778: POS4
[11:49:24] /workspace/home/codes/tvm/src/relay/backend/vm/compiler.cc:551: Lower Function End
[11:49:24] /workspace/home/codes/tvm/src/relay/backend/vm/compiler.cc:548: Lower Function Start
[11:49:24] /workspace/home/codes/tvm/src/relay/backend/vm/compiler.cc:549: fn (%p0: int64, Primitive=1, hash="e2e2680f0ff08f46") -> int64 {
  multiply(%p0, 4 /* ty=int64 */) /* ty=int64 */
}
[11:49:24] /workspace/home/codes/tvm/src/relay/backend/compile_engine.cc:767: POS1
[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectPrefetch
primfn(placeholder_1: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_1: placeholder, T_multiply_1: T_multiply} {
  attr [T_multiply] "realize_scope" = "";
  realize(T_multiply, [], True {
    T_multiply[] = (placeholder[]*4i64)
  })
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.StorageFlatten
primfn(placeholder_1: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_1: placeholder, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_2[0]*4i64)
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16Promote
primfn(placeholder_1: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_1: placeholder, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_2[0]*4i64)
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16CastElimination
primfn(placeholder_1: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_1: placeholder, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_2[0]*4i64)
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16TypeLowering
primfn(placeholder_1: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_1: placeholder, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_2[0]*4i64)
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16Legalize
primfn(placeholder_1: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_1: placeholder, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_2[0]*4i64)
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.NarrowDataType
primfn(placeholder_1: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_1: placeholder, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_2[0]*4i64)
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify
primfn(placeholder_1: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_1: placeholder, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_2[0]*4i64)
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LoopPartition
primfn(placeholder_1: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_1: placeholder, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_2[0]*4i64)
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.VectorizeLoop
primfn(placeholder_1: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_1: placeholder, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_2[0]*4i64)
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectVirtualThread
primfn(placeholder_1: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_1: placeholder, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_2[0]*4i64)
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectDoubleBuffer
primfn(placeholder_1: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_1: placeholder, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_2[0]*4i64)
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.StorageRewrite
primfn(placeholder_1: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_1: placeholder, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_2[0]*4i64)
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.UnrollLoop
primfn(placeholder_1: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_1: placeholder, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_2[0]*4i64)
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify
primfn(placeholder_1: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_1: placeholder, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_2[0]*4i64)
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.RemoveNoOp
primfn(placeholder_1: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_1: placeholder, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_2[0]*4i64)
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.RewriteUnsafeSelect
primfn(placeholder_1: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_1: placeholder, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_2[0]*4i64)
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.HoistIfThenElse
primfn(placeholder_1: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_1: placeholder, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_2[0]*4i64)
}


[11:49:24] /workspace/home/codes/tvm/src/relay/backend/compile_engine.cc:778: POS4
[11:49:24] /workspace/home/codes/tvm/src/relay/backend/vm/compiler.cc:551: Lower Function End
[11:49:24] /workspace/home/codes/tvm/src/relay/backend/vm/compiler.cc:548: Lower Function Start
[11:49:24] /workspace/home/codes/tvm/src/relay/backend/vm/compiler.cc:549: fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1, hash="f9a165078ab8ab77") -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
}

[11:49:24] /workspace/home/codes/tvm/src/relay/backend/compile_engine.cc:767: POS1
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0: int32]: IntervalSet[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (0 >= floordiv(floordiv(i0.i1.fused.i2.fused: int32, d2: int32), d1: int32))
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i1: int32]: IntervalSet[floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (0 >= floormod(floordiv(i0.i1.fused.i2.fused: int32, d2: int32), d1: int32))
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i2: int32]: IntervalSet[floormod(i0.i1.fused.i2.fused, d2), floormod(i0.i1.fused.i2.fused, d2)]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (0 >= floormod(i0.i1.fused.i2.fused: int32, d2: int32))
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0: int32]: IntervalSet[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (0 >= floordiv(floordiv(i0.i1.fused.i2.fused: int32, d2: int32), d1: int32))
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i1: int32]: IntervalSet[floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (0 >= floormod(floordiv(i0.i1.fused.i2.fused: int32, d2: int32), d1: int32))
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i2: int32]: IntervalSet[floormod(i0.i1.fused.i2.fused, d2), floormod(i0.i1.fused.i2.fused, d2)]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (0 >= floormod(i0.i1.fused.i2.fused: int32, d2: int32))
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var k: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d3, d3], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ k: int32]: IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove ((d3: int32 - 1) <= (d3 - 1))
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0: int32]: IntervalSet[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (0 >= floordiv(floordiv(i0.i1.fused.i2.fused: int32, d2: int32), d1: int32))
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i1: int32]: IntervalSet[floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (0 >= floormod(floordiv(i0.i1.fused.i2.fused: int32, d2: int32), d1: int32))
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i2: int32]: IntervalSet[floormod(i0.i1.fused.i2.fused, d2), floormod(i0.i1.fused.i2.fused, d2)]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (0 >= floormod(i0.i1.fused.i2.fused: int32, d2: int32))
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i3: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d3, d3], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i3: int32]: IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove ((d3: int32 - 1) <= (d3 - 1))
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0: int32]: IntervalSet[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (0 >= floordiv(floordiv(i0.i1.fused.i2.fused: int32, d2: int32), d1: int32))
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i1: int32]: IntervalSet[floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (0 >= floormod(floordiv(i0.i1.fused.i2.fused: int32, d2: int32), d1: int32))
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i2: int32]: IntervalSet[floormod(i0.i1.fused.i2.fused, d2), floormod(i0.i1.fused.i2.fused, d2)]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (0 >= floormod(i0.i1.fused.i2.fused: int32, d2: int32))
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i1, ): range(min=0, ext=1)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(k, range(min=0, ext=d3)): range(min=0, ext=d3)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0, ): range(min=0, ext=1)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i2, range(min=0, ext=d2)): range(min=floormod(i0.i1.fused.i2.fused, d2), ext=1)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i1, range(min=0, ext=d1)): range(min=floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), ext=1)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0, range(min=0, ext=d0)): range(min=floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), ext=1)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0, ): range(min=0, ext=1)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0.i1.fused.i2.fused, ): range(min=0, ext=((d0*d1)*d2))
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i1, range(min=0, ext=d1)): range(min=floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), ext=1)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i1, range(min=0, ext=d1)): range(min=0, ext=d1)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(k, range(min=0, ext=d3)): range(min=0, ext=d3)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i2, ): range(min=0, ext=1)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0, range(min=0, ext=d0)): range(min=0, ext=d0)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i2, range(min=0, ext=d2)): range(min=floormod(i0.i1.fused.i2.fused, d2), ext=1)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i2, ): range(min=0, ext=1)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i3, ): range(min=0, ext=d3)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i2, range(min=0, ext=d2)): range(min=0, ext=d2)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i2, ): range(min=0, ext=1)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i3, range(min=0, ext=d3)): range(min=0, ext=d3)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i3, range(min=0, ext=d3)): range(min=0, ext=d3)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i1, ): range(min=0, ext=1)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0, range(min=0, ext=d0)): range(min=floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), ext=1)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(k, ): range(min=0, ext=d3)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i3, ): range(min=0, ext=d3)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0, range(min=0, ext=d0)): range(min=floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), ext=1)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i1, range(min=0, ext=d1)): range(min=floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), ext=1)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i2, range(min=0, ext=d2)): range(min=floormod(i0.i1.fused.i2.fused, d2), ext=1)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0.i1.fused, ): range(min=0, ext=(d0*d1))
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0, ): range(min=0, ext=1)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(k, ): range(min=0, ext=d3)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i1, ): range(min=0, ext=1)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, (d2 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[floormod(i0.i1.fused.i2.fused, d2), floormod(i0.i1.fused.i2.fused, d2)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i3: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i3: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, (d1 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused: int32, IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i3: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i3: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[floormod(i0.i1.fused.i2.fused, d2), floormod(i0.i1.fused.i2.fused, d2)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused: int32, IntervalSet[0, ((d0*d1) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[floormod(i0.i1.fused.i2.fused, d2), floormod(i0.i1.fused.i2.fused, d2)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, (d0 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove (d0: int32 == d0)
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove (d1: int32 == d1)
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove (d2: int32 == d2)
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove (d3: int32 == d3)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, (d2 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[floormod(i0.i1.fused.i2.fused, d2), floormod(i0.i1.fused.i2.fused, d2)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i3: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i3: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, (d1 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused: int32, IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i3: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i3: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[floormod(i0.i1.fused.i2.fused, d2), floormod(i0.i1.fused.i2.fused, d2)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused: int32, IntervalSet[0, ((d0*d1) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[floormod(i0.i1.fused.i2.fused, d2), floormod(i0.i1.fused.i2.fused, d2)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, (d0 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (0 == floordiv(floordiv(i0.i1.fused.i2.fused: int32, d2: int32), d1: int32))
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:570: ===== FOR VAR i0: int32
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:571: RAW value: floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), RAW vmin: 0, RAW extent: d0
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:572: ISET_MAP IntervalSet[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), d1), floordiv(select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0), d1)), select((d1 >= 0), floordiv(select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0), d1), floordiv(select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), d1))]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:576: value: floordiv(floordiv(i0.i1.fused.i2.fused: int32, d2: int32), d1: int32), vmin: select((d1: int32 >= 0), floordiv(select((d2: int32 >= 0), 0, floordiv((((d0: int32*d1)*d2) - 1), d2)), d1), floordiv(select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0), d1)), vmax: select((d1: int32 >= 0), floordiv(select((d2: int32 >= 0), floordiv((((d0: int32*d1)*d2) - 1), d2), 0), d1), floordiv(select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), d1))
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (select((d1: int32 >= 0), floordiv(select((d2: int32 >= 0), 0, floordiv((((d0: int32*d1)*d2) - 1), d2)), d1), floordiv(select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0), d1)) >= 0)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:580: min likely!
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (select((d1: int32 >= 0), floordiv(select((d2: int32 >= 0), floordiv((((d0: int32*d1)*d2) - 1), d2), 0), d1), floordiv(select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), d1)) < d0)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:584: max likely!
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (0 == floormod(floordiv(i0.i1.fused.i2.fused: int32, d2: int32), d1: int32))
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:570: ===== FOR VAR i1: int32
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:571: RAW value: floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), RAW vmin: 0, RAW extent: d1
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:572: ISET_MAP IntervalSet[floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d1: int32, Bound: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d1 >= 0), d1, (0 - d1)) - 1)), (select((d1 >= 0), d1, (0 - d1)) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:576: value: floormod(floordiv(i0.i1.fused.i2.fused: int32, d2: int32), d1: int32), vmin: (0 - (select((d1: int32 >= 0), d1, (0 - d1)) - 1)), vmax: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove ((0 - (select((d1: int32 >= 0), d1, (0 - d1)) - 1)) >= 0)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:580: min likely!
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove ((select((d1: int32 >= 0), d1, (0 - d1)) - 1) < d1)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:584: max likely!
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (0 == floormod(i0.i1.fused.i2.fused: int32, d2: int32))
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:570: ===== FOR VAR i2: int32
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:571: RAW value: floormod(i0.i1.fused.i2.fused, d2), RAW vmin: 0, RAW extent: d2
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:572: ISET_MAP IntervalSet[floormod(i0.i1.fused.i2.fused, d2), floormod(i0.i1.fused.i2.fused, d2)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d2: int32, Bound: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d2 >= 0), d2, (0 - d2)) - 1)), (select((d2 >= 0), d2, (0 - d2)) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:576: value: floormod(i0.i1.fused.i2.fused: int32, d2: int32), vmin: (0 - (select((d2: int32 >= 0), d2, (0 - d2)) - 1)), vmax: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove ((0 - (select((d2: int32 >= 0), d2, (0 - d2)) - 1)) >= 0)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:580: min likely!
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove ((select((d2: int32 >= 0), d2, (0 - d2)) - 1) < d2)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:584: max likely!
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove (d3: int32 == d3)
[11:49:24] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floordiv(floordiv(i0.i1.fused.i2.fused: int32, d2: int32), d1: int32) >= 0)
[11:49:24] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floordiv(floordiv(i0.i1.fused.i2.fused: int32, d2: int32), d1: int32) < d0: int32)
[11:49:24] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floormod(floordiv(i0.i1.fused.i2.fused: int32, d2: int32), d1: int32) >= 0)
[11:49:24] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floormod(floordiv(i0.i1.fused.i2.fused: int32, d2: int32), d1: int32) < d1)
[11:49:24] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floormod(i0.i1.fused.i2.fused: int32, d2: int32) >= 0)
[11:49:24] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floormod(i0.i1.fused.i2.fused: int32, d2: int32) < d2)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, (d2 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[floormod(i0.i1.fused.i2.fused, d2), floormod(i0.i1.fused.i2.fused, d2)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i3: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i3: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, (d1 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused: int32, IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i3: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i3: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[floormod(i0.i1.fused.i2.fused, d2), floormod(i0.i1.fused.i2.fused, d2)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused: int32, IntervalSet[0, ((d0*d1) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[floormod(i0.i1.fused.i2.fused, d2), floormod(i0.i1.fused.i2.fused, d2)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, (d0 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, (d2 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[floormod(i0.i1.fused.i2.fused, d2), floormod(i0.i1.fused.i2.fused, d2)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i3: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i3: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, (d1 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused: int32, IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i3: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i3: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[floormod(i0.i1.fused.i2.fused, d2), floormod(i0.i1.fused.i2.fused, d2)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused: int32, IntervalSet[0, ((d0*d1) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[floormod(i0.i1.fused.i2.fused, d2), floormod(i0.i1.fused.i2.fused, d2)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, (d0 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (0 == floordiv(floordiv(i0.i1.fused.i2.fused: int32, d2: int32), d1: int32))
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:570: ===== FOR VAR i0: int32
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:571: RAW value: floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), RAW vmin: 0, RAW extent: d0
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:572: ISET_MAP IntervalSet[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), d1), floordiv(select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0), d1)), select((d1 >= 0), floordiv(select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0), d1), floordiv(select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), d1))]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:576: value: floordiv(floordiv(i0.i1.fused.i2.fused: int32, d2: int32), d1: int32), vmin: select((d1: int32 >= 0), floordiv(select((d2: int32 >= 0), 0, floordiv((((d0: int32*d1)*d2) - 1), d2)), d1), floordiv(select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0), d1)), vmax: select((d1: int32 >= 0), floordiv(select((d2: int32 >= 0), floordiv((((d0: int32*d1)*d2) - 1), d2), 0), d1), floordiv(select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), d1))
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (select((d1: int32 >= 0), floordiv(select((d2: int32 >= 0), 0, floordiv((((d0: int32*d1)*d2) - 1), d2)), d1), floordiv(select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0), d1)) >= 0)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:580: min likely!
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (select((d1: int32 >= 0), floordiv(select((d2: int32 >= 0), floordiv((((d0: int32*d1)*d2) - 1), d2), 0), d1), floordiv(select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), d1)) < d0)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:584: max likely!
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (0 == floormod(floordiv(i0.i1.fused.i2.fused: int32, d2: int32), d1: int32))
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:570: ===== FOR VAR i1: int32
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:571: RAW value: floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), RAW vmin: 0, RAW extent: d1
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:572: ISET_MAP IntervalSet[floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d1: int32, Bound: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d1 >= 0), d1, (0 - d1)) - 1)), (select((d1 >= 0), d1, (0 - d1)) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:576: value: floormod(floordiv(i0.i1.fused.i2.fused: int32, d2: int32), d1: int32), vmin: (0 - (select((d1: int32 >= 0), d1, (0 - d1)) - 1)), vmax: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove ((0 - (select((d1: int32 >= 0), d1, (0 - d1)) - 1)) >= 0)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:580: min likely!
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove ((select((d1: int32 >= 0), d1, (0 - d1)) - 1) < d1)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:584: max likely!
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (0 == floormod(i0.i1.fused.i2.fused: int32, d2: int32))
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:570: ===== FOR VAR i2: int32
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:571: RAW value: floormod(i0.i1.fused.i2.fused, d2), RAW vmin: 0, RAW extent: d2
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:572: ISET_MAP IntervalSet[floormod(i0.i1.fused.i2.fused, d2), floormod(i0.i1.fused.i2.fused, d2)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d2: int32, Bound: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d2 >= 0), d2, (0 - d2)) - 1)), (select((d2 >= 0), d2, (0 - d2)) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:576: value: floormod(i0.i1.fused.i2.fused: int32, d2: int32), vmin: (0 - (select((d2: int32 >= 0), d2, (0 - d2)) - 1)), vmax: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove ((0 - (select((d2: int32 >= 0), d2, (0 - d2)) - 1)) >= 0)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:580: min likely!
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove ((select((d2: int32 >= 0), d2, (0 - d2)) - 1) < d2)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:584: max likely!
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove (d3: int32 == d3)
[11:49:24] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floordiv(floordiv(i0.i1.fused.i2.fused: int32, d2: int32), d1: int32) >= 0)
[11:49:24] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floordiv(floordiv(i0.i1.fused.i2.fused: int32, d2: int32), d1: int32) < d0: int32)
[11:49:24] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floormod(floordiv(i0.i1.fused.i2.fused: int32, d2: int32), d1: int32) >= 0)
[11:49:24] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floormod(floordiv(i0.i1.fused.i2.fused: int32, d2: int32), d1: int32) < d1)
[11:49:24] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floormod(i0.i1.fused.i2.fused: int32, d2: int32) >= 0)
[11:49:24] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floormod(i0.i1.fused.i2.fused: int32, d2: int32) < d2)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, (d2 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[floormod(i0.i1.fused.i2.fused, d2), floormod(i0.i1.fused.i2.fused, d2)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i3: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i3: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, (d1 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused: int32, IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i3: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i3: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[floormod(i0.i1.fused.i2.fused, d2), floormod(i0.i1.fused.i2.fused, d2)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused: int32, IntervalSet[0, ((d0*d1) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[floormod(i0.i1.fused.i2.fused, d2), floormod(i0.i1.fused.i2.fused, d2)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, (d0 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (0 == floordiv(floordiv(i0.i1.fused.i2.fused: int32, d2: int32), d1: int32))
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:570: ===== FOR VAR i0: int32
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:571: RAW value: floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), RAW vmin: 0, RAW extent: d0
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:572: ISET_MAP IntervalSet[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), d1), floordiv(select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0), d1)), select((d1 >= 0), floordiv(select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0), d1), floordiv(select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), d1))]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:576: value: floordiv(floordiv(i0.i1.fused.i2.fused: int32, d2: int32), d1: int32), vmin: select((d1: int32 >= 0), floordiv(select((d2: int32 >= 0), 0, floordiv((((d0: int32*d1)*d2) - 1), d2)), d1), floordiv(select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0), d1)), vmax: select((d1: int32 >= 0), floordiv(select((d2: int32 >= 0), floordiv((((d0: int32*d1)*d2) - 1), d2), 0), d1), floordiv(select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), d1))
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (select((d1: int32 >= 0), floordiv(select((d2: int32 >= 0), 0, floordiv((((d0: int32*d1)*d2) - 1), d2)), d1), floordiv(select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0), d1)) >= 0)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:580: min likely!
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (select((d1: int32 >= 0), floordiv(select((d2: int32 >= 0), floordiv((((d0: int32*d1)*d2) - 1), d2), 0), d1), floordiv(select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), d1)) < d0)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:584: max likely!
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (0 == floormod(floordiv(i0.i1.fused.i2.fused: int32, d2: int32), d1: int32))
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:570: ===== FOR VAR i1: int32
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:571: RAW value: floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), RAW vmin: 0, RAW extent: d1
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:572: ISET_MAP IntervalSet[floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d1: int32, Bound: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d1 >= 0), d1, (0 - d1)) - 1)), (select((d1 >= 0), d1, (0 - d1)) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:576: value: floormod(floordiv(i0.i1.fused.i2.fused: int32, d2: int32), d1: int32), vmin: (0 - (select((d1: int32 >= 0), d1, (0 - d1)) - 1)), vmax: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove ((0 - (select((d1: int32 >= 0), d1, (0 - d1)) - 1)) >= 0)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:580: min likely!
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove ((select((d1: int32 >= 0), d1, (0 - d1)) - 1) < d1)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:584: max likely!
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (0 == floormod(i0.i1.fused.i2.fused: int32, d2: int32))
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:570: ===== FOR VAR i2: int32
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:571: RAW value: floormod(i0.i1.fused.i2.fused, d2), RAW vmin: 0, RAW extent: d2
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:572: ISET_MAP IntervalSet[floormod(i0.i1.fused.i2.fused, d2), floormod(i0.i1.fused.i2.fused, d2)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d2: int32, Bound: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d2 >= 0), d2, (0 - d2)) - 1)), (select((d2 >= 0), d2, (0 - d2)) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:576: value: floormod(i0.i1.fused.i2.fused: int32, d2: int32), vmin: (0 - (select((d2: int32 >= 0), d2, (0 - d2)) - 1)), vmax: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove ((0 - (select((d2: int32 >= 0), d2, (0 - d2)) - 1)) >= 0)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:580: min likely!
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove ((select((d2: int32 >= 0), d2, (0 - d2)) - 1) < d2)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:584: max likely!
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove (d3: int32 == d3)
[11:49:24] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floordiv(floordiv(i0.i1.fused.i2.fused: int32, d2: int32), d1: int32) >= 0)
[11:49:24] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floordiv(floordiv(i0.i1.fused.i2.fused: int32, d2: int32), d1: int32) < d0: int32)
[11:49:24] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floormod(floordiv(i0.i1.fused.i2.fused: int32, d2: int32), d1: int32) >= 0)
[11:49:24] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floormod(floordiv(i0.i1.fused.i2.fused: int32, d2: int32), d1: int32) < d1)
[11:49:24] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floormod(i0.i1.fused.i2.fused: int32, d2: int32) >= 0)
[11:49:24] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floormod(i0.i1.fused.i2.fused: int32, d2: int32) < d2)
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, (d2 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[floormod(i0.i1.fused.i2.fused, d2), floormod(i0.i1.fused.i2.fused, d2)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i3: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i3: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, (d1 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused: int32, IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i3: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i3: int32, IntervalSet[0, (d3 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[floormod(i0.i1.fused.i2.fused, d2), floormod(i0.i1.fused.i2.fused, d2)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused: int32, IntervalSet[0, ((d0*d1) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, 0]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[floormod(i0.i1.fused.i2.fused, d2), floormod(i0.i1.fused.i2.fused, d2)]
[11:49:24] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, (d0 - 1)]
[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectPrefetch
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  attr [T_softmax_norm] "realize_scope" = "";
  realize(T_softmax_norm, [0:d0, 0:d1, 0:d2, 0:d3], True {
    for (i0.i1.fused.i2.fused: int32, 0, ((d0*d1)*d2)) "parallel" {
      attr [T_softmax_maxelem: Buffer(T_softmax_maxelem_1: Pointer(float32), float32, [d0, d1, d2], [])] "realize_scope" = "";
      realize(T_softmax_maxelem, [floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1):(floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) + 1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1):(floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) + 1), floormod(i0.i1.fused.i2.fused, d2):(floormod(i0.i1.fused.i2.fused, d2) + 1)], True {
         {
          T_softmax_maxelem[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(i0.i1.fused.i2.fused, d2)] = -3.40282e+38f32
          for (k: int32, 0, d3) {
            if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
              if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0), dtype=bool) {
                if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
                  if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1), dtype=bool) {
                    if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) >= 0), dtype=bool) {
                      if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) < d2), dtype=bool) {
                        T_softmax_maxelem[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(i0.i1.fused.i2.fused, d2)] = max(T_softmax_maxelem[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(i0.i1.fused.i2.fused, d2)], placeholder[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(i0.i1.fused.i2.fused, d2), k])
                      }
                    }
                  }
                }
              }
            }
          }
        }
        attr [T_softmax_exp: Buffer(T_softmax_exp_1: Pointer(float32), float32, [d0, d1, d2, d3], [])] "realize_scope" = "";
        realize(T_softmax_exp, [floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1):(floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) + 1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1):(floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) + 1), floormod(i0.i1.fused.i2.fused, d2):(floormod(i0.i1.fused.i2.fused, d2) + 1), 0:d3], True {
          for (i3: int32, 0, d3) {
            if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
              if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0), dtype=bool) {
                if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
                  if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1), dtype=bool) {
                    if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) >= 0), dtype=bool) {
                      if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) < d2), dtype=bool) {
                        T_softmax_exp[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(i0.i1.fused.i2.fused, d2), i3] = @tir.exp((placeholder[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(i0.i1.fused.i2.fused, d2), i3] - T_softmax_maxelem[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(i0.i1.fused.i2.fused, d2)]), dtype=float32)
                      }
                    }
                  }
                }
              }
            }
          }
          attr [T_softmax_expsum: Buffer(T_softmax_expsum_1: Pointer(float32), float32, [d0, d1, d2], [])] "realize_scope" = "";
          realize(T_softmax_expsum, [floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1):(floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) + 1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1):(floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) + 1), floormod(i0.i1.fused.i2.fused, d2):(floormod(i0.i1.fused.i2.fused, d2) + 1)], True {
             {
              T_softmax_expsum[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(i0.i1.fused.i2.fused, d2)] = 0f32
              for (k_1: int32, 0, d3) {
                if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
                  if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0), dtype=bool) {
                    if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
                      if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1), dtype=bool) {
                        if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) >= 0), dtype=bool) {
                          if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) < d2), dtype=bool) {
                            T_softmax_expsum[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(i0.i1.fused.i2.fused, d2)] = (T_softmax_expsum[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(i0.i1.fused.i2.fused, d2)] + T_softmax_exp[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(i0.i1.fused.i2.fused, d2), k_1])
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            for (i3_1: int32, 0, d3) {
              T_softmax_norm[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(i0.i1.fused.i2.fused, d2), i3_1] = (T_softmax_exp[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(i0.i1.fused.i2.fused, d2), i3_1] / T_softmax_expsum[floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(floordiv(i0.i1.fused.i2.fused, d2), d1), floormod(i0.i1.fused.i2.fused, d2)])
            }
          })
        })
      })
    }
  })
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.StorageFlatten
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  for (i0.i1.fused.i2.fused: int32, 0, ((d0*d1)*d2)) "parallel" {
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_maxelem, float32, [1, 1, 1]) {
       {
        T_softmax_maxelem[0] = -3.40282e+38f32
        for (k: int32, 0, d3) {
          if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
            if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0), dtype=bool) {
              if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
                if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1), dtype=bool) {
                  if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) >= 0), dtype=bool) {
                    if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) < d2), dtype=bool) {
                      T_softmax_maxelem[0] = max((float32*)T_softmax_maxelem[0], (float32*)placeholder_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (k*stride_7))])
                    }
                  }
                }
              }
            }
          }
        }
      }
      attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
      allocate(T_softmax_exp, float32, [1, 1, 1, d3]) {
        for (i3: int32, 0, d3) {
          if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
            if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0), dtype=bool) {
              if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
                if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1), dtype=bool) {
                  if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) >= 0), dtype=bool) {
                    if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) < d2), dtype=bool) {
                      T_softmax_exp[i3] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (i3*stride_7))] - (float32*)T_softmax_maxelem[0]), dtype=float32)
                    }
                  }
                }
              }
            }
          }
        }
        attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
        allocate(T_softmax_expsum, float32, [1, 1, 1]) {
           {
            T_softmax_expsum[0] = 0f32
            for (k_1: int32, 0, d3) {
              if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
                if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0), dtype=bool) {
                  if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
                    if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1), dtype=bool) {
                      if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) >= 0), dtype=bool) {
                        if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) < d2), dtype=bool) {
                          T_softmax_expsum[0] = ((float32*)T_softmax_expsum[0] + (float32*)T_softmax_exp[k_1])
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          for (i3_1: int32, 0, d3) {
            T_softmax_norm_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_1)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_2)) + (i3_1*stride_3))] = ((float32*)T_softmax_exp[i3_1] / (float32*)T_softmax_expsum[0])
          }
        }
      }
    }
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16Promote
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  for (i0.i1.fused.i2.fused: int32, 0, ((d0*d1)*d2)) "parallel" {
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_maxelem, float32, [1, 1, 1]) {
       {
        T_softmax_maxelem[0] = -3.40282e+38f32
        for (k: int32, 0, d3) {
          if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
            if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0), dtype=bool) {
              if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
                if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1), dtype=bool) {
                  if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) >= 0), dtype=bool) {
                    if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) < d2), dtype=bool) {
                      T_softmax_maxelem[0] = max((float32*)T_softmax_maxelem[0], (float32*)placeholder_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (k*stride_7))])
                    }
                  }
                }
              }
            }
          }
        }
      }
      attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
      allocate(T_softmax_exp, float32, [1, 1, 1, d3]) {
        for (i3: int32, 0, d3) {
          if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
            if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0), dtype=bool) {
              if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
                if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1), dtype=bool) {
                  if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) >= 0), dtype=bool) {
                    if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) < d2), dtype=bool) {
                      T_softmax_exp[i3] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (i3*stride_7))] - (float32*)T_softmax_maxelem[0]), dtype=float32)
                    }
                  }
                }
              }
            }
          }
        }
        attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
        allocate(T_softmax_expsum, float32, [1, 1, 1]) {
           {
            T_softmax_expsum[0] = 0f32
            for (k_1: int32, 0, d3) {
              if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
                if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0), dtype=bool) {
                  if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
                    if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1), dtype=bool) {
                      if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) >= 0), dtype=bool) {
                        if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) < d2), dtype=bool) {
                          T_softmax_expsum[0] = ((float32*)T_softmax_expsum[0] + (float32*)T_softmax_exp[k_1])
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          for (i3_1: int32, 0, d3) {
            T_softmax_norm_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_1)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_2)) + (i3_1*stride_3))] = ((float32*)T_softmax_exp[i3_1] / (float32*)T_softmax_expsum[0])
          }
        }
      }
    }
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16CastElimination
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  for (i0.i1.fused.i2.fused: int32, 0, ((d0*d1)*d2)) "parallel" {
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_maxelem, float32, [1, 1, 1]) {
       {
        T_softmax_maxelem[0] = -3.40282e+38f32
        for (k: int32, 0, d3) {
          if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
            if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0), dtype=bool) {
              if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
                if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1), dtype=bool) {
                  if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) >= 0), dtype=bool) {
                    if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) < d2), dtype=bool) {
                      T_softmax_maxelem[0] = max((float32*)T_softmax_maxelem[0], (float32*)placeholder_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (k*stride_7))])
                    }
                  }
                }
              }
            }
          }
        }
      }
      attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
      allocate(T_softmax_exp, float32, [1, 1, 1, d3]) {
        for (i3: int32, 0, d3) {
          if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
            if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0), dtype=bool) {
              if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
                if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1), dtype=bool) {
                  if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) >= 0), dtype=bool) {
                    if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) < d2), dtype=bool) {
                      T_softmax_exp[i3] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (i3*stride_7))] - (float32*)T_softmax_maxelem[0]), dtype=float32)
                    }
                  }
                }
              }
            }
          }
        }
        attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
        allocate(T_softmax_expsum, float32, [1, 1, 1]) {
           {
            T_softmax_expsum[0] = 0f32
            for (k_1: int32, 0, d3) {
              if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
                if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0), dtype=bool) {
                  if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
                    if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1), dtype=bool) {
                      if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) >= 0), dtype=bool) {
                        if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) < d2), dtype=bool) {
                          T_softmax_expsum[0] = ((float32*)T_softmax_expsum[0] + (float32*)T_softmax_exp[k_1])
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          for (i3_1: int32, 0, d3) {
            T_softmax_norm_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_1)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_2)) + (i3_1*stride_3))] = ((float32*)T_softmax_exp[i3_1] / (float32*)T_softmax_expsum[0])
          }
        }
      }
    }
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16TypeLowering
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  for (i0.i1.fused.i2.fused: int32, 0, ((d0*d1)*d2)) "parallel" {
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_maxelem, float32, [1, 1, 1]) {
       {
        T_softmax_maxelem[0] = -3.40282e+38f32
        for (k: int32, 0, d3) {
          if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
            if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0), dtype=bool) {
              if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
                if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1), dtype=bool) {
                  if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) >= 0), dtype=bool) {
                    if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) < d2), dtype=bool) {
                      T_softmax_maxelem[0] = max((float32*)T_softmax_maxelem[0], (float32*)placeholder_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (k*stride_7))])
                    }
                  }
                }
              }
            }
          }
        }
      }
      attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
      allocate(T_softmax_exp, float32, [1, 1, 1, d3]) {
        for (i3: int32, 0, d3) {
          if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
            if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0), dtype=bool) {
              if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
                if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1), dtype=bool) {
                  if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) >= 0), dtype=bool) {
                    if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) < d2), dtype=bool) {
                      T_softmax_exp[i3] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (i3*stride_7))] - (float32*)T_softmax_maxelem[0]), dtype=float32)
                    }
                  }
                }
              }
            }
          }
        }
        attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
        allocate(T_softmax_expsum, float32, [1, 1, 1]) {
           {
            T_softmax_expsum[0] = 0f32
            for (k_1: int32, 0, d3) {
              if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
                if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0), dtype=bool) {
                  if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
                    if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1), dtype=bool) {
                      if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) >= 0), dtype=bool) {
                        if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) < d2), dtype=bool) {
                          T_softmax_expsum[0] = ((float32*)T_softmax_expsum[0] + (float32*)T_softmax_exp[k_1])
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          for (i3_1: int32, 0, d3) {
            T_softmax_norm_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_1)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_2)) + (i3_1*stride_3))] = ((float32*)T_softmax_exp[i3_1] / (float32*)T_softmax_expsum[0])
          }
        }
      }
    }
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16Legalize
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  for (i0.i1.fused.i2.fused: int32, 0, ((d0*d1)*d2)) "parallel" {
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_maxelem, float32, [1, 1, 1]) {
       {
        T_softmax_maxelem[0] = -3.40282e+38f32
        for (k: int32, 0, d3) {
          if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
            if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0), dtype=bool) {
              if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
                if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1), dtype=bool) {
                  if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) >= 0), dtype=bool) {
                    if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) < d2), dtype=bool) {
                      T_softmax_maxelem[0] = max((float32*)T_softmax_maxelem[0], (float32*)placeholder_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (k*stride_7))])
                    }
                  }
                }
              }
            }
          }
        }
      }
      attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
      allocate(T_softmax_exp, float32, [1, 1, 1, d3]) {
        for (i3: int32, 0, d3) {
          if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
            if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0), dtype=bool) {
              if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
                if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1), dtype=bool) {
                  if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) >= 0), dtype=bool) {
                    if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) < d2), dtype=bool) {
                      T_softmax_exp[i3] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (i3*stride_7))] - (float32*)T_softmax_maxelem[0]), dtype=float32)
                    }
                  }
                }
              }
            }
          }
        }
        attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
        allocate(T_softmax_expsum, float32, [1, 1, 1]) {
           {
            T_softmax_expsum[0] = 0f32
            for (k_1: int32, 0, d3) {
              if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
                if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0), dtype=bool) {
                  if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
                    if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1), dtype=bool) {
                      if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) >= 0), dtype=bool) {
                        if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) < d2), dtype=bool) {
                          T_softmax_expsum[0] = ((float32*)T_softmax_expsum[0] + (float32*)T_softmax_exp[k_1])
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          for (i3_1: int32, 0, d3) {
            T_softmax_norm_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_1)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_2)) + (i3_1*stride_3))] = ((float32*)T_softmax_exp[i3_1] / (float32*)T_softmax_expsum[0])
          }
        }
      }
    }
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.NarrowDataType
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  for (i0.i1.fused.i2.fused: int32, 0, ((d0*d1)*d2)) "parallel" {
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_maxelem, float32, [1, 1, 1]) {
       {
        T_softmax_maxelem[0] = -3.40282e+38f32
        for (k: int32, 0, d3) {
          if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
            if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0), dtype=bool) {
              if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
                if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1), dtype=bool) {
                  if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) >= 0), dtype=bool) {
                    if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) < d2), dtype=bool) {
                      T_softmax_maxelem[0] = max((float32*)T_softmax_maxelem[0], (float32*)placeholder_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (k*stride_7))])
                    }
                  }
                }
              }
            }
          }
        }
      }
      attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
      allocate(T_softmax_exp, float32, [1, 1, 1, d3]) {
        for (i3: int32, 0, d3) {
          if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
            if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0), dtype=bool) {
              if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
                if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1), dtype=bool) {
                  if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) >= 0), dtype=bool) {
                    if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) < d2), dtype=bool) {
                      T_softmax_exp[i3] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (i3*stride_7))] - (float32*)T_softmax_maxelem[0]), dtype=float32)
                    }
                  }
                }
              }
            }
          }
        }
        attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
        allocate(T_softmax_expsum, float32, [1, 1, 1]) {
           {
            T_softmax_expsum[0] = 0f32
            for (k_1: int32, 0, d3) {
              if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
                if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0), dtype=bool) {
                  if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) >= 0), dtype=bool) {
                    if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1), dtype=bool) {
                      if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) >= 0), dtype=bool) {
                        if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) < d2), dtype=bool) {
                          T_softmax_expsum[0] = ((float32*)T_softmax_expsum[0] + (float32*)T_softmax_exp[k_1])
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          for (i3_1: int32, 0, d3) {
            T_softmax_norm_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_1)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_2)) + (i3_1*stride_3))] = ((float32*)T_softmax_exp[i3_1] / (float32*)T_softmax_expsum[0])
          }
        }
      }
    }
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  for (i0.i1.fused.i2.fused: int32, 0, ((d0*d1)*d2)) "parallel" {
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_maxelem, float32, [1, 1, 1]) {
       {
        T_softmax_maxelem[0] = -3.40282e+38f32
        for (k: int32, 0, d3) {
          if @tir.likely((0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)), dtype=bool) {
            if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0), dtype=bool) {
              if @tir.likely((0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)), dtype=bool) {
                if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1), dtype=bool) {
                  if @tir.likely((0 <= floormod(i0.i1.fused.i2.fused, d2)), dtype=bool) {
                    if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) < d2), dtype=bool) {
                      T_softmax_maxelem[0] = max((float32*)T_softmax_maxelem[0], (float32*)placeholder_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (k*stride_7))])
                    }
                  }
                }
              }
            }
          }
        }
      }
      attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
      allocate(T_softmax_exp, float32, [1, 1, 1, d3]) {
        for (i3: int32, 0, d3) {
          if @tir.likely((0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)), dtype=bool) {
            if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0), dtype=bool) {
              if @tir.likely((0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)), dtype=bool) {
                if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1), dtype=bool) {
                  if @tir.likely((0 <= floormod(i0.i1.fused.i2.fused, d2)), dtype=bool) {
                    if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) < d2), dtype=bool) {
                      T_softmax_exp[i3] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (i3*stride_7))] - (float32*)T_softmax_maxelem[0]), dtype=float32)
                    }
                  }
                }
              }
            }
          }
        }
        attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
        allocate(T_softmax_expsum, float32, [1, 1, 1]) {
           {
            T_softmax_expsum[0] = 0f32
            for (k_1: int32, 0, d3) {
              if @tir.likely((0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)), dtype=bool) {
                if @tir.likely((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0), dtype=bool) {
                  if @tir.likely((0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)), dtype=bool) {
                    if @tir.likely((floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1), dtype=bool) {
                      if @tir.likely((0 <= floormod(i0.i1.fused.i2.fused, d2)), dtype=bool) {
                        if @tir.likely((floormod(i0.i1.fused.i2.fused, d2) < d2), dtype=bool) {
                          T_softmax_expsum[0] = ((float32*)T_softmax_expsum[0] + (float32*)T_softmax_exp[k_1])
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          for (i3_1: int32, 0, d3) {
            T_softmax_norm_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_1)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_2)) + (i3_1*stride_3))] = ((float32*)T_softmax_exp[i3_1] / (float32*)T_softmax_expsum[0])
          }
        }
      }
    }
  }
}


[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), d1), floordiv(select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0), d1)), select((d1 >= 0), floordiv(select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0), d1), floordiv(select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), d1))]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), d1), floordiv(select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0), d1)), select((d1 >= 0), floordiv(select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0), d1), floordiv(select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), d1))]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), d1), floordiv(select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0), d1)), select((d1 >= 0), floordiv(select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0), d1), floordiv(select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), d1))]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), d1), floordiv(select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0), d1)), select((d1 >= 0), floordiv(select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0), d1), floordiv(select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), d1))]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d1: int32, Bound: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d1 >= 0), d1, (0 - d1)) - 1)), (select((d1 >= 0), d1, (0 - d1)) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d1: int32, Bound: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d1 >= 0), d1, (0 - d1)) - 1)), (select((d1 >= 0), d1, (0 - d1)) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d1, d1], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d1: int32, Bound: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d1 >= 0), d1, (0 - d1)) - 1)), (select((d1 >= 0), d1, (0 - d1)) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d1: int32, Bound: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d1 >= 0), d1, (0 - d1)) - 1)), (select((d1 >= 0), d1, (0 - d1)) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d2: int32, Bound: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d2 >= 0), d2, (0 - d2)) - 1)), (select((d2 >= 0), d2, (0 - d2)) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d2: int32, Bound: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d2 >= 0), d2, (0 - d2)) - 1)), (select((d2 >= 0), d2, (0 - d2)) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d2, d2], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d2: int32, Bound: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d2 >= 0), d2, (0 - d2)) - 1)), (select((d2 >= 0), d2, (0 - d2)) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d2: int32, Bound: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d2 >= 0), d2, (0 - d2)) - 1)), (select((d2 >= 0), d2, (0 - d2)) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), d1), floordiv(select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0), d1)), select((d1 >= 0), floordiv(select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0), d1), floordiv(select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), d1))]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), d1), floordiv(select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0), d1)), select((d1 >= 0), floordiv(select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0), d1), floordiv(select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), d1))]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), d1), floordiv(select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0), d1)), select((d1 >= 0), floordiv(select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0), d1), floordiv(select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), d1))]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), d1), floordiv(select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0), d1)), select((d1 >= 0), floordiv(select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0), d1), floordiv(select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), d1))]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d1: int32, Bound: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d1 >= 0), d1, (0 - d1)) - 1)), (select((d1 >= 0), d1, (0 - d1)) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d1: int32, Bound: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d1 >= 0), d1, (0 - d1)) - 1)), (select((d1 >= 0), d1, (0 - d1)) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d1, d1], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d1: int32, Bound: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d1 >= 0), d1, (0 - d1)) - 1)), (select((d1 >= 0), d1, (0 - d1)) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d1: int32, Bound: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d1 >= 0), d1, (0 - d1)) - 1)), (select((d1 >= 0), d1, (0 - d1)) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d2: int32, Bound: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d2 >= 0), d2, (0 - d2)) - 1)), (select((d2 >= 0), d2, (0 - d2)) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d2: int32, Bound: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d2 >= 0), d2, (0 - d2)) - 1)), (select((d2 >= 0), d2, (0 - d2)) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d2, d2], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d2: int32, Bound: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d2 >= 0), d2, (0 - d2)) - 1)), (select((d2 >= 0), d2, (0 - d2)) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d2: int32, Bound: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d2 >= 0), d2, (0 - d2)) - 1)), (select((d2 >= 0), d2, (0 - d2)) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), d1), floordiv(select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0), d1)), select((d1 >= 0), floordiv(select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0), d1), floordiv(select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), d1))]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), d1), floordiv(select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0), d1)), select((d1 >= 0), floordiv(select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0), d1), floordiv(select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), d1))]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), d1), floordiv(select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0), d1)), select((d1 >= 0), floordiv(select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0), d1), floordiv(select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), d1))]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), d1), floordiv(select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0), d1)), select((d1 >= 0), floordiv(select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0), d1), floordiv(select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), d1))]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d1: int32, Bound: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d1 >= 0), d1, (0 - d1)) - 1)), (select((d1 >= 0), d1, (0 - d1)) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d1: int32, Bound: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d1 >= 0), d1, (0 - d1)) - 1)), (select((d1 >= 0), d1, (0 - d1)) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d1, d1], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d1: int32, Bound: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d1 >= 0), d1, (0 - d1)) - 1)), (select((d1 >= 0), d1, (0 - d1)) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(i0.i1.fused.i2.fused, d2), floordiv(i0.i1.fused.i2.fused, d2)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((((d0*d1)*d2) - 1), d2)), select((d2 >= 0), floordiv((((d0*d1)*d2) - 1), d2), 0)], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d1: int32, Bound: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d1 >= 0), d1, (0 - d1)) - 1)), (select((d1 >= 0), d1, (0 - d1)) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d2: int32, Bound: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d2 >= 0), d2, (0 - d2)) - 1)), (select((d2 >= 0), d2, (0 - d2)) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d2: int32, Bound: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d2 >= 0), d2, (0 - d2)) - 1)), (select((d2 >= 0), d2, (0 - d2)) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d2, d2], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d2: int32, Bound: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d2 >= 0), d2, (0 - d2)) - 1)), (select((d2 >= 0), d2, (0 - d2)) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[i0.i1.fused.i2.fused, i0.i1.fused.i2.fused], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0.i1.fused.i2.fused: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0.i1.fused.i2.fused: int32]: IntervalSet[0, (((d0*d1)*d2) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (((d0*d1)*d2) - 1)], b after eval: IntervalSet[d2, d2]
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d2: int32, Bound: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[11:49:24] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d2 >= 0), d2, (0 - d2)) - 1)), (select((d2 >= 0), d2, (0 - d2)) - 1)]
[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LoopPartition
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  for (i0.i1.fused.i2.fused: int32, 0, ((d0*d1)*d2)) "parallel" {
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_maxelem, float32, [1, 1, 1]) {
       {
        T_softmax_maxelem[0] = -3.40282e+38f32
        for (k: int32, 0, d3) {
          if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
              if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
                  if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                    if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                      T_softmax_maxelem[0] = max((float32*)T_softmax_maxelem[0], (float32*)placeholder_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (k*stride_7))])
                    }
                  }
                }
              }
            }
          }
        }
      }
      attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
      allocate(T_softmax_exp, float32, [1, 1, 1, d3]) {
        for (i3: int32, 0, d3) {
          if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
              if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
                  if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                    if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                      T_softmax_exp[i3] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (i3*stride_7))] - (float32*)T_softmax_maxelem[0]), dtype=float32)
                    }
                  }
                }
              }
            }
          }
        }
        attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
        allocate(T_softmax_expsum, float32, [1, 1, 1]) {
           {
            T_softmax_expsum[0] = 0f32
            for (k_1: int32, 0, d3) {
              if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
                  if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                    if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
                      if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                        if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                          T_softmax_expsum[0] = ((float32*)T_softmax_expsum[0] + (float32*)T_softmax_exp[k_1])
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          for (i3_1: int32, 0, d3) {
            T_softmax_norm_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_1)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_2)) + (i3_1*stride_3))] = ((float32*)T_softmax_exp[i3_1] / (float32*)T_softmax_expsum[0])
          }
        }
      }
    }
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.VectorizeLoop
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  for (i0.i1.fused.i2.fused: int32, 0, ((d0*d1)*d2)) "parallel" {
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_maxelem, float32, [1, 1, 1]) {
       {
        T_softmax_maxelem[0] = -3.40282e+38f32
        for (k: int32, 0, d3) {
          if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
              if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
                  if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                    if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                      T_softmax_maxelem[0] = max((float32*)T_softmax_maxelem[0], (float32*)placeholder_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (k*stride_7))])
                    }
                  }
                }
              }
            }
          }
        }
      }
      attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
      allocate(T_softmax_exp, float32, [1, 1, 1, d3]) {
        for (i3: int32, 0, d3) {
          if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
              if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
                  if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                    if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                      T_softmax_exp[i3] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (i3*stride_7))] - (float32*)T_softmax_maxelem[0]), dtype=float32)
                    }
                  }
                }
              }
            }
          }
        }
        attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
        allocate(T_softmax_expsum, float32, [1, 1, 1]) {
           {
            T_softmax_expsum[0] = 0f32
            for (k_1: int32, 0, d3) {
              if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
                  if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                    if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
                      if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                        if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                          T_softmax_expsum[0] = ((float32*)T_softmax_expsum[0] + (float32*)T_softmax_exp[k_1])
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          for (i3_1: int32, 0, d3) {
            T_softmax_norm_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_1)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_2)) + (i3_1*stride_3))] = ((float32*)T_softmax_exp[i3_1] / (float32*)T_softmax_expsum[0])
          }
        }
      }
    }
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectVirtualThread
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  for (i0.i1.fused.i2.fused: int32, 0, ((d0*d1)*d2)) "parallel" {
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_maxelem, float32, [1, 1, 1]) {
       {
        T_softmax_maxelem[0] = -3.40282e+38f32
        for (k: int32, 0, d3) {
          if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
              if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
                  if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                    if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                      T_softmax_maxelem[0] = max((float32*)T_softmax_maxelem[0], (float32*)placeholder_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (k*stride_7))])
                    }
                  }
                }
              }
            }
          }
        }
      }
      attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
      allocate(T_softmax_exp, float32, [1, 1, 1, d3]) {
        for (i3: int32, 0, d3) {
          if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
              if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
                  if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                    if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                      T_softmax_exp[i3] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (i3*stride_7))] - (float32*)T_softmax_maxelem[0]), dtype=float32)
                    }
                  }
                }
              }
            }
          }
        }
        attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
        allocate(T_softmax_expsum, float32, [1, 1, 1]) {
           {
            T_softmax_expsum[0] = 0f32
            for (k_1: int32, 0, d3) {
              if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
                  if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                    if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
                      if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                        if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                          T_softmax_expsum[0] = ((float32*)T_softmax_expsum[0] + (float32*)T_softmax_exp[k_1])
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          for (i3_1: int32, 0, d3) {
            T_softmax_norm_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_1)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_2)) + (i3_1*stride_3))] = ((float32*)T_softmax_exp[i3_1] / (float32*)T_softmax_expsum[0])
          }
        }
      }
    }
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectDoubleBuffer
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  for (i0.i1.fused.i2.fused: int32, 0, ((d0*d1)*d2)) "parallel" {
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_maxelem, float32, [1, 1, 1]) {
       {
        T_softmax_maxelem[0] = -3.40282e+38f32
        for (k: int32, 0, d3) {
          if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
              if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
                  if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                    if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                      T_softmax_maxelem[0] = max((float32*)T_softmax_maxelem[0], (float32*)placeholder_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (k*stride_7))])
                    }
                  }
                }
              }
            }
          }
        }
      }
      attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
      allocate(T_softmax_exp, float32, [1, 1, 1, d3]) {
        for (i3: int32, 0, d3) {
          if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
              if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
                  if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                    if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                      T_softmax_exp[i3] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (i3*stride_7))] - (float32*)T_softmax_maxelem[0]), dtype=float32)
                    }
                  }
                }
              }
            }
          }
        }
        attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
        allocate(T_softmax_expsum, float32, [1, 1, 1]) {
           {
            T_softmax_expsum[0] = 0f32
            for (k_1: int32, 0, d3) {
              if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
                  if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                    if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
                      if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                        if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                          T_softmax_expsum[0] = ((float32*)T_softmax_expsum[0] + (float32*)T_softmax_exp[k_1])
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          for (i3_1: int32, 0, d3) {
            T_softmax_norm_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_1)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_2)) + (i3_1*stride_3))] = ((float32*)T_softmax_exp[i3_1] / (float32*)T_softmax_expsum[0])
          }
        }
      }
    }
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.StorageRewrite
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  for (i0.i1.fused.i2.fused: int32, 0, ((d0*d1)*d2)) "parallel" {
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_maxelem, float32, [1]);
    attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_exp, float32, [d3]);
    attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_expsum, float32, [1]) {
       {
        T_softmax_maxelem[0] = -3.40282e+38f32
        for (k: int32, 0, d3) {
          if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
              if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
                  if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                    if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                      T_softmax_maxelem[0] = max((float32*)T_softmax_maxelem[0], (float32*)placeholder_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (k*stride_7))])
                    }
                  }
                }
              }
            }
          }
        }
      }
       {
        for (i3: int32, 0, d3) {
          if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
              if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
                  if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                    if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                      T_softmax_exp[i3] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (i3*stride_7))] - (float32*)T_softmax_maxelem[0]), dtype=float32)
                    }
                  }
                }
              }
            }
          }
        }
         {
           {
            T_softmax_expsum[0] = 0f32
            for (k_1: int32, 0, d3) {
              if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
                  if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                    if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
                      if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                        if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                          T_softmax_expsum[0] = ((float32*)T_softmax_expsum[0] + (float32*)T_softmax_exp[k_1])
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          for (i3_1: int32, 0, d3) {
            T_softmax_norm_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_1)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_2)) + (i3_1*stride_3))] = ((float32*)T_softmax_exp[i3_1] / (float32*)T_softmax_expsum[0])
          }
        }
      }
    }
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.UnrollLoop
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  for (i0.i1.fused.i2.fused: int32, 0, ((d0*d1)*d2)) "parallel" {
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_maxelem, float32, [1]);
    attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_exp, float32, [d3]);
    attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_expsum, float32, [1]) {
       {
        T_softmax_maxelem[0] = -3.40282e+38f32
        for (k: int32, 0, d3) {
          if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
              if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
                  if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                    if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                      T_softmax_maxelem[0] = max((float32*)T_softmax_maxelem[0], (float32*)placeholder_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (k*stride_7))])
                    }
                  }
                }
              }
            }
          }
        }
      }
       {
        for (i3: int32, 0, d3) {
          if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
              if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
                  if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                    if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                      T_softmax_exp[i3] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (i3*stride_7))] - (float32*)T_softmax_maxelem[0]), dtype=float32)
                    }
                  }
                }
              }
            }
          }
        }
         {
           {
            T_softmax_expsum[0] = 0f32
            for (k_1: int32, 0, d3) {
              if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
                  if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                    if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
                      if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                        if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                          T_softmax_expsum[0] = ((float32*)T_softmax_expsum[0] + (float32*)T_softmax_exp[k_1])
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          for (i3_1: int32, 0, d3) {
            T_softmax_norm_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_1)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_2)) + (i3_1*stride_3))] = ((float32*)T_softmax_exp[i3_1] / (float32*)T_softmax_expsum[0])
          }
        }
      }
    }
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  for (i0.i1.fused.i2.fused: int32, 0, ((d0*d1)*d2)) "parallel" {
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_maxelem, float32, [1]);
    attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_exp, float32, [d3]);
    attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_expsum, float32, [1]) {
       {
        T_softmax_maxelem[0] = -3.40282e+38f32
        for (k: int32, 0, d3) {
          if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
              if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
                  if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                    if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                      T_softmax_maxelem[0] = max((float32*)T_softmax_maxelem[0], (float32*)placeholder_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (k*stride_7))])
                    }
                  }
                }
              }
            }
          }
        }
      }
       {
        for (i3: int32, 0, d3) {
          if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
              if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
                  if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                    if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                      T_softmax_exp[i3] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (i3*stride_7))] - (float32*)T_softmax_maxelem[0]), dtype=float32)
                    }
                  }
                }
              }
            }
          }
        }
         {
           {
            T_softmax_expsum[0] = 0f32
            for (k_1: int32, 0, d3) {
              if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
                  if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                    if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
                      if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                        if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                          T_softmax_expsum[0] = ((float32*)T_softmax_expsum[0] + (float32*)T_softmax_exp[k_1])
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          for (i3_1: int32, 0, d3) {
            T_softmax_norm_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_1)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_2)) + (i3_1*stride_3))] = ((float32*)T_softmax_exp[i3_1] / (float32*)T_softmax_expsum[0])
          }
        }
      }
    }
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.RemoveNoOp
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  for (i0.i1.fused.i2.fused: int32, 0, ((d0*d1)*d2)) "parallel" {
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_maxelem, float32, [1]);
    attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_exp, float32, [d3]);
    attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_expsum, float32, [1]) {
      T_softmax_maxelem[0] = -3.40282e+38f32
      for (k: int32, 0, d3) {
        if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
          if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
            if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
              if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
                if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                  if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                    T_softmax_maxelem[0] = max((float32*)T_softmax_maxelem[0], (float32*)placeholder_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (k*stride_7))])
                  }
                }
              }
            }
          }
        }
      }
      for (i3: int32, 0, d3) {
        if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
          if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
            if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
              if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
                if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                  if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                    T_softmax_exp[i3] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (i3*stride_7))] - (float32*)T_softmax_maxelem[0]), dtype=float32)
                  }
                }
              }
            }
          }
        }
      }
      T_softmax_expsum[0] = 0f32
      for (k_1: int32, 0, d3) {
        if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
          if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
            if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
              if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
                if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                  if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                    T_softmax_expsum[0] = ((float32*)T_softmax_expsum[0] + (float32*)T_softmax_exp[k_1])
                  }
                }
              }
            }
          }
        }
      }
      for (i3_1: int32, 0, d3) {
        T_softmax_norm_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_1)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_2)) + (i3_1*stride_3))] = ((float32*)T_softmax_exp[i3_1] / (float32*)T_softmax_expsum[0])
      }
    }
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.RewriteUnsafeSelect
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  for (i0.i1.fused.i2.fused: int32, 0, ((d0*d1)*d2)) "parallel" {
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_maxelem, float32, [1]);
    attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_exp, float32, [d3]);
    attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_expsum, float32, [1]) {
      T_softmax_maxelem[0] = -3.40282e+38f32
      for (k: int32, 0, d3) {
        if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
          if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
            if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
              if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
                if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                  if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                    T_softmax_maxelem[0] = max((float32*)T_softmax_maxelem[0], (float32*)placeholder_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (k*stride_7))])
                  }
                }
              }
            }
          }
        }
      }
      for (i3: int32, 0, d3) {
        if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
          if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
            if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
              if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
                if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                  if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                    T_softmax_exp[i3] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (i3*stride_7))] - (float32*)T_softmax_maxelem[0]), dtype=float32)
                  }
                }
              }
            }
          }
        }
      }
      T_softmax_expsum[0] = 0f32
      for (k_1: int32, 0, d3) {
        if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
          if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
            if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
              if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
                if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                  if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                    T_softmax_expsum[0] = ((float32*)T_softmax_expsum[0] + (float32*)T_softmax_exp[k_1])
                  }
                }
              }
            }
          }
        }
      }
      for (i3_1: int32, 0, d3) {
        T_softmax_norm_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_1)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_2)) + (i3_1*stride_3))] = ((float32*)T_softmax_exp[i3_1] / (float32*)T_softmax_expsum[0])
      }
    }
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.HoistIfThenElse
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  for (i0.i1.fused.i2.fused: int32, 0, ((d0*d1)*d2)) "parallel" {
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_maxelem, float32, [1]);
    attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_exp, float32, [d3]);
    attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_expsum, float32, [1]) {
      T_softmax_maxelem[0] = -3.40282e+38f32
      if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
        if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
          if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
              if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                  for (k: int32, 0, d3) {
                    T_softmax_maxelem[0] = max((float32*)T_softmax_maxelem[0], (float32*)placeholder_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (k*stride_7))])
                  }
                }
              }
            }
          }
        }
      }
      if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
        if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
          if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
              if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                  for (i3: int32, 0, d3) {
                    T_softmax_exp[i3] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (i3*stride_7))] - (float32*)T_softmax_maxelem[0]), dtype=float32)
                  }
                }
              }
            }
          }
        }
      }
      T_softmax_expsum[0] = 0f32
      if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
        if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
          if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
              if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                  for (k_1: int32, 0, d3) {
                    T_softmax_expsum[0] = ((float32*)T_softmax_expsum[0] + (float32*)T_softmax_exp[k_1])
                  }
                }
              }
            }
          }
        }
      }
      for (i3_1: int32, 0, d3) {
        T_softmax_norm_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_1)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_2)) + (i3_1*stride_3))] = ((float32*)T_softmax_exp[i3_1] / (float32*)T_softmax_expsum[0])
      }
    }
  }
}


[11:49:24] /workspace/home/codes/tvm/src/relay/backend/compile_engine.cc:778: POS4
[11:49:24] /workspace/home/codes/tvm/src/relay/backend/vm/compiler.cc:551: Lower Function End
[11:49:24] /workspace/home/codes/tvm/src/relay/backend/vm/compiler.cc:982: LOWER END

[11:49:24] /workspace/home/codes/tvm/src/relay/backend/vm/compiler.cc:1157: CODEGEN START

[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass BindTarget
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}

primfn(placeholder_4: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder_3: Buffer(placeholder_5: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_4: placeholder_3, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_5[k0])
  }
}

primfn(placeholder_7: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder_6: Buffer(placeholder_8: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_7: placeholder_6, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_8[0]*4i64)
}

primfn(placeholder_10: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder_9: Buffer(placeholder_11: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_10: placeholder_9, T_softmax_norm_1: T_softmax_norm} {
  for (i0.i1.fused.i2.fused: int32, 0, ((d0*d1)*d2)) "parallel" {
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_maxelem, float32, [1]);
    attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_exp, float32, [d3]);
    attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_expsum, float32, [1]) {
      T_softmax_maxelem[0] = -3.40282e+38f32
      if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
        if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
          if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
              if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                  for (k: int32, 0, d3) {
                    T_softmax_maxelem[0] = max((float32*)T_softmax_maxelem[0], (float32*)placeholder_11[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (k*stride_7))])
                  }
                }
              }
            }
          }
        }
      }
      if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
        if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
          if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
              if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                  for (i3: int32, 0, d3) {
                    T_softmax_exp[i3] = @tir.exp(((float32*)placeholder_11[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (i3*stride_7))] - (float32*)T_softmax_maxelem[0]), dtype=float32)
                  }
                }
              }
            }
          }
        }
      }
      T_softmax_expsum[0] = 0f32
      if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
        if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
          if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
              if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                  for (k_1: int32, 0, d3) {
                    T_softmax_expsum[0] = ((float32*)T_softmax_expsum[0] + (float32*)T_softmax_exp[k_1])
                  }
                }
              }
            }
          }
        }
      }
      for (i3_1: int32, 0, d3) {
        T_softmax_norm_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_1)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_2)) + (i3_1*stride_3))] = ((float32*)T_softmax_exp[i3_1] / (float32*)T_softmax_expsum[0])
      }
    }
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.VerifyMemory
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}

primfn(placeholder_4: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder_3: Buffer(placeholder_5: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_4: placeholder_3, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_5[k0])
  }
}

primfn(placeholder_7: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder_6: Buffer(placeholder_8: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_7: placeholder_6, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_8[0]*4i64)
}

primfn(placeholder_10: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder_9: Buffer(placeholder_11: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_10: placeholder_9, T_softmax_norm_1: T_softmax_norm} {
  for (i0.i1.fused.i2.fused: int32, 0, ((d0*d1)*d2)) "parallel" {
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_maxelem, float32, [1]);
    attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_exp, float32, [d3]);
    attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_expsum, float32, [1]) {
      T_softmax_maxelem[0] = -3.40282e+38f32
      if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
        if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
          if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
              if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                  for (k: int32, 0, d3) {
                    T_softmax_maxelem[0] = max((float32*)T_softmax_maxelem[0], (float32*)placeholder_11[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (k*stride_7))])
                  }
                }
              }
            }
          }
        }
      }
      if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
        if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
          if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
              if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                  for (i3: int32, 0, d3) {
                    T_softmax_exp[i3] = @tir.exp(((float32*)placeholder_11[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (i3*stride_7))] - (float32*)T_softmax_maxelem[0]), dtype=float32)
                  }
                }
              }
            }
          }
        }
      }
      T_softmax_expsum[0] = 0f32
      if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
        if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
          if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
              if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                  for (k_1: int32, 0, d3) {
                    T_softmax_expsum[0] = ((float32*)T_softmax_expsum[0] + (float32*)T_softmax_exp[k_1])
                  }
                }
              }
            }
          }
        }
      }
      for (i3_1: int32, 0, d3) {
        T_softmax_norm_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_1)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_2)) + (i3_1*stride_3))] = ((float32*)T_softmax_exp[i3_1] / (float32*)T_softmax_expsum[0])
      }
    }
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.ThreadSync
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}

primfn(placeholder_4: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder_3: Buffer(placeholder_5: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_4: placeholder_3, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_5[k0])
  }
}

primfn(placeholder_7: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder_6: Buffer(placeholder_8: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_7: placeholder_6, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_8[0]*4i64)
}

primfn(placeholder_10: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder_9: Buffer(placeholder_11: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_10: placeholder_9, T_softmax_norm_1: T_softmax_norm} {
  for (i0.i1.fused.i2.fused: int32, 0, ((d0*d1)*d2)) "parallel" {
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_maxelem, float32, [1]);
    attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_exp, float32, [d3]);
    attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_expsum, float32, [1]) {
      T_softmax_maxelem[0] = -3.40282e+38f32
      if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
        if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
          if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
              if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                  for (k: int32, 0, d3) {
                    T_softmax_maxelem[0] = max((float32*)T_softmax_maxelem[0], (float32*)placeholder_11[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (k*stride_7))])
                  }
                }
              }
            }
          }
        }
      }
      if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
        if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
          if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
              if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                  for (i3: int32, 0, d3) {
                    T_softmax_exp[i3] = @tir.exp(((float32*)placeholder_11[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (i3*stride_7))] - (float32*)T_softmax_maxelem[0]), dtype=float32)
                  }
                }
              }
            }
          }
        }
      }
      T_softmax_expsum[0] = 0f32
      if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
        if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
          if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
              if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                  for (k_1: int32, 0, d3) {
                    T_softmax_expsum[0] = ((float32*)T_softmax_expsum[0] + (float32*)T_softmax_exp[k_1])
                  }
                }
              }
            }
          }
        }
      }
      for (i3_1: int32, 0, d3) {
        T_softmax_norm_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_1)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_2)) + (i3_1*stride_3))] = ((float32*)T_softmax_exp[i3_1] / (float32*)T_softmax_expsum[0])
      }
    }
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.ThreadSync
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}

primfn(placeholder_4: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder_3: Buffer(placeholder_5: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_4: placeholder_3, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_5[k0])
  }
}

primfn(placeholder_7: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder_6: Buffer(placeholder_8: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_7: placeholder_6, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_8[0]*4i64)
}

primfn(placeholder_10: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder_9: Buffer(placeholder_11: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_10: placeholder_9, T_softmax_norm_1: T_softmax_norm} {
  for (i0.i1.fused.i2.fused: int32, 0, ((d0*d1)*d2)) "parallel" {
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_maxelem, float32, [1]);
    attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_exp, float32, [d3]);
    attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_expsum, float32, [1]) {
      T_softmax_maxelem[0] = -3.40282e+38f32
      if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
        if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
          if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
              if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                  for (k: int32, 0, d3) {
                    T_softmax_maxelem[0] = max((float32*)T_softmax_maxelem[0], (float32*)placeholder_11[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (k*stride_7))])
                  }
                }
              }
            }
          }
        }
      }
      if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
        if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
          if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
              if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                  for (i3: int32, 0, d3) {
                    T_softmax_exp[i3] = @tir.exp(((float32*)placeholder_11[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (i3*stride_7))] - (float32*)T_softmax_maxelem[0]), dtype=float32)
                  }
                }
              }
            }
          }
        }
      }
      T_softmax_expsum[0] = 0f32
      if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
        if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
          if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
              if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                  for (k_1: int32, 0, d3) {
                    T_softmax_expsum[0] = ((float32*)T_softmax_expsum[0] + (float32*)T_softmax_exp[k_1])
                  }
                }
              }
            }
          }
        }
      }
      for (i3_1: int32, 0, d3) {
        T_softmax_norm_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_1)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_2)) + (i3_1*stride_3))] = ((float32*)T_softmax_exp[i3_1] / (float32*)T_softmax_expsum[0])
      }
    }
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InferFragment
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}

primfn(placeholder_4: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder_3: Buffer(placeholder_5: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_4: placeholder_3, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_5[k0])
  }
}

primfn(placeholder_7: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder_6: Buffer(placeholder_8: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_7: placeholder_6, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_8[0]*4i64)
}

primfn(placeholder_10: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder_9: Buffer(placeholder_11: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_10: placeholder_9, T_softmax_norm_1: T_softmax_norm} {
  for (i0.i1.fused.i2.fused: int32, 0, ((d0*d1)*d2)) "parallel" {
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_maxelem, float32, [1]);
    attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_exp, float32, [d3]);
    attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_expsum, float32, [1]) {
      T_softmax_maxelem[0] = -3.40282e+38f32
      if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
        if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
          if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
              if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                  for (k: int32, 0, d3) {
                    T_softmax_maxelem[0] = max((float32*)T_softmax_maxelem[0], (float32*)placeholder_11[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (k*stride_7))])
                  }
                }
              }
            }
          }
        }
      }
      if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
        if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
          if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
              if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                  for (i3: int32, 0, d3) {
                    T_softmax_exp[i3] = @tir.exp(((float32*)placeholder_11[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (i3*stride_7))] - (float32*)T_softmax_maxelem[0]), dtype=float32)
                  }
                }
              }
            }
          }
        }
      }
      T_softmax_expsum[0] = 0f32
      if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
        if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
          if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
              if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                  for (k_1: int32, 0, d3) {
                    T_softmax_expsum[0] = ((float32*)T_softmax_expsum[0] + (float32*)T_softmax_exp[k_1])
                  }
                }
              }
            }
          }
        }
      }
      for (i3_1: int32, 0, d3) {
        T_softmax_norm_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_1)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_2)) + (i3_1*stride_3))] = ((float32*)T_softmax_exp[i3_1] / (float32*)T_softmax_expsum[0])
      }
    }
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerThreadAllreduce
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}

primfn(placeholder_4: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder_3: Buffer(placeholder_5: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_4: placeholder_3, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_5[k0])
  }
}

primfn(placeholder_7: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder_6: Buffer(placeholder_8: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_7: placeholder_6, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_8[0]*4i64)
}

primfn(placeholder_10: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder_9: Buffer(placeholder_11: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_10: placeholder_9, T_softmax_norm_1: T_softmax_norm} {
  for (i0.i1.fused.i2.fused: int32, 0, ((d0*d1)*d2)) "parallel" {
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_maxelem, float32, [1]);
    attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_exp, float32, [d3]);
    attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_expsum, float32, [1]) {
      T_softmax_maxelem[0] = -3.40282e+38f32
      if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
        if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
          if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
              if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                  for (k: int32, 0, d3) {
                    T_softmax_maxelem[0] = max((float32*)T_softmax_maxelem[0], (float32*)placeholder_11[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (k*stride_7))])
                  }
                }
              }
            }
          }
        }
      }
      if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
        if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
          if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
              if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                  for (i3: int32, 0, d3) {
                    T_softmax_exp[i3] = @tir.exp(((float32*)placeholder_11[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_4) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_5)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_6)) + (i3*stride_7))] - (float32*)T_softmax_maxelem[0]), dtype=float32)
                  }
                }
              }
            }
          }
        }
      }
      T_softmax_expsum[0] = 0f32
      if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
        if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
          if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
              if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                  for (k_1: int32, 0, d3) {
                    T_softmax_expsum[0] = ((float32*)T_softmax_expsum[0] + (float32*)T_softmax_exp[k_1])
                  }
                }
              }
            }
          }
        }
      }
      for (i3_1: int32, 0, d3) {
        T_softmax_norm_2[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_1)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_2)) + (i3_1*stride_3))] = ((float32*)T_softmax_exp[i3_1] / (float32*)T_softmax_expsum[0])
      }
    }
  }
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.MakePackedAPI
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"global_symbol": "fused_prod", "tir.noalias": True, "target": meta[Target][0], "calling_conv": 1} {
  assert((num_args == 2), "fused_prod: num_args should be 2")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_red: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_red] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_prod: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_prod: Expect arg[1] to be pointer")
  attr ["default"] "device_id" = dev_id;
  attr ["default"] "device_type" = 1;
  assert((1 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((4 == cast(int32, (int64*)arg0.shape[0])), "Argument arg0.shape[0] has an unsatisfied constraint: (4 == int32(arg0.shape[0]))")
   {
    if !@tir.isnullptr(arg0.strides, dtype=bool) {
      assert((1 == cast(int32, (int64*)arg0.strides[0])), "arg0.strides: expected to be compact array")
      0
    }
    assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
    assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
    assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
    assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
    assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
    assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
    attr [0] "compute_scope" = "fused_prod_compute_" {
      placeholder_red[0] = 1i64
      for (k0: int32, 0, 4) {
        placeholder_red[0] = ((int64*)placeholder_red[0]*(int64*)placeholder[k0])
      }
    }
  }
}

primfn(args_1: handle, arg_type_ids_1: handle, num_args_1: int32, out_ret_value_1: handle, out_ret_tcode_1: handle, resource_handle_1: handle) -> int32
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True, "target": meta[Target][0], "calling_conv": 1} {
  assert((num_args_1 == 2), "fused_nn_softmax: num_args should be 2")
  let arg0_1: handle = @tir.tvm_struct_get(args_1, 0, 12, dtype=handle)
  let arg0.code_1: int32 = (int32*)arg_type_ids_1[0]
  let arg1_1: handle = @tir.tvm_struct_get(args_1, 1, 12, dtype=handle)
  let arg1.code_1: int32 = (int32*)arg_type_ids_1[1]
  let placeholder_1: Pointer(float32) = @tir.tvm_struct_get(arg0_1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg0.shape_1: handle = @tir.tvm_struct_get(arg0_1, 0, 2, dtype=handle)
  let d0: int32 = cast(int32, (int64*)arg0.shape_1[0])
  let d1: int32 = cast(int32, (int64*)arg0.shape_1[1])
  let d2: int32 = cast(int32, (int64*)arg0.shape_1[2])
  let d3: int32 = cast(int32, (int64*)arg0.shape_1[3])
  let arg0.strides_1: handle = @tir.tvm_struct_get(arg0_1, 0, 3, dtype=handle)
  let stride: int32 = @tir.if_then_else((d3 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides_1, dtype=bool), 1, cast(int32, (int64*)arg0.strides_1[3]), dtype=int32), dtype=int32)
  let stride_1: int32 = @tir.if_then_else((d2 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides_1, dtype=bool), d3, cast(int32, (int64*)arg0.strides_1[2]), dtype=int32), dtype=int32)
  let stride_2: int32 = @tir.if_then_else((d1 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides_1, dtype=bool), (d3*d2), cast(int32, (int64*)arg0.strides_1[1]), dtype=int32), dtype=int32)
  let stride_3: int32 = @tir.if_then_else((d0 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides_1, dtype=bool), ((d3*d2)*d1), cast(int32, (int64*)arg0.strides_1[0]), dtype=int32), dtype=int32)
  let dev_id_1: int32 = @tir.tvm_struct_get(arg0_1, 0, 9, dtype=int32)
  let T_softmax_norm: Pointer(float32) = @tir.tvm_struct_get(arg1_1, 0, 1, dtype=handle)
  attr [T_softmax_norm] "storage_alignment" = 128;
  let arg1.shape_1: handle = @tir.tvm_struct_get(arg1_1, 0, 2, dtype=handle)
  let arg1.strides_1: handle = @tir.tvm_struct_get(arg1_1, 0, 3, dtype=handle)
  let stride_4: int32 = @tir.if_then_else((d3 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides_1, dtype=bool), 1, cast(int32, (int64*)arg1.strides_1[3]), dtype=int32), dtype=int32)
  let stride_5: int32 = @tir.if_then_else((d2 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides_1, dtype=bool), d3, cast(int32, (int64*)arg1.strides_1[2]), dtype=int32), dtype=int32)
  let stride_6: int32 = @tir.if_then_else((d1 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides_1, dtype=bool), (d3*d2), cast(int32, (int64*)arg1.strides_1[1]), dtype=int32), dtype=int32)
  let stride_7: int32 = @tir.if_then_else((d0 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides_1, dtype=bool), ((d3*d2)*d1), cast(int32, (int64*)arg1.strides_1[0]), dtype=int32), dtype=int32)
  assert(((((arg0.code_1 == 3) || (arg0.code_1 == 13)) || (arg0.code_1 == 7)) || (arg0.code_1 == 4)), "fused_nn_softmax: Expect arg[0] to be pointer")
  assert(((((arg1.code_1 == 3) || (arg1.code_1 == 13)) || (arg1.code_1 == 7)) || (arg1.code_1 == 4)), "fused_nn_softmax: Expect arg[1] to be pointer")
  attr ["default"] "device_id" = dev_id_1;
  attr ["default"] "device_type" = 1;
  assert((4 == @tir.tvm_struct_get(arg0_1, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 4")
  assert((4 == @tir.tvm_struct_get(arg0_1, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 4")
  assert((((@tir.tvm_struct_get(arg0_1, 0, 5, dtype=uint8) == 2u8) && (@tir.tvm_struct_get(arg0_1, 0, 6, dtype=uint8) == 32u8)) && (@tir.tvm_struct_get(arg0_1, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be float32")
  assert((0u64 == @tir.tvm_struct_get(arg0_1, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0_1, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((4 == @tir.tvm_struct_get(arg1_1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 4")
  assert((4 == @tir.tvm_struct_get(arg1_1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 4")
  assert((((@tir.tvm_struct_get(arg1_1, 0, 5, dtype=uint8) == 2u8) && (@tir.tvm_struct_get(arg1_1, 0, 6, dtype=uint8) == 32u8)) && (@tir.tvm_struct_get(arg1_1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be float32")
  assert((d0 == cast(int32, (int64*)arg1.shape_1[0])), "Argument arg1.shape[0] has an unsatisfied constraint: (d0 == int32(arg1.shape[0]))")
  assert((d1 == cast(int32, (int64*)arg1.shape_1[1])), "Argument arg1.shape[1] has an unsatisfied constraint: (d1 == int32(arg1.shape[1]))")
  assert((d2 == cast(int32, (int64*)arg1.shape_1[2])), "Argument arg1.shape[2] has an unsatisfied constraint: (d2 == int32(arg1.shape[2]))")
  assert((d3 == cast(int32, (int64*)arg1.shape_1[3])), "Argument arg1.shape[3] has an unsatisfied constraint: (d3 == int32(arg1.shape[3]))")
  assert((0u64 == @tir.tvm_struct_get(arg1_1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1_1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id_1 == @tir.tvm_struct_get(arg1_1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  attr [0] "compute_scope" = "fused_nn_softmax_compute_";
  for (i0.i1.fused.i2.fused: int32, 0, ((d0*d1)*d2)) "parallel" {
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_maxelem, float32, [1]);
    attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_exp, float32, [d3]);
    attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_expsum, float32, [1]) {
      T_softmax_maxelem[0] = -3.40282e+38f32
      if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
        if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
          if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
              if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                  for (k: int32, 0, d3) {
                    T_softmax_maxelem[0] = max((float32*)T_softmax_maxelem[0], (float32*)placeholder_1[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_3) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_2)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_1)) + (k*stride))])
                  }
                }
              }
            }
          }
        }
      }
      if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
        if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
          if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
              if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                  for (i3: int32, 0, d3) {
                    T_softmax_exp[i3] = @tir.exp(((float32*)placeholder_1[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_3) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_2)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_1)) + (i3*stride))] - (float32*)T_softmax_maxelem[0]), dtype=float32)
                  }
                }
              }
            }
          }
        }
      }
      T_softmax_expsum[0] = 0f32
      if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
        if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
          if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
              if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                  for (k_1: int32, 0, d3) {
                    T_softmax_expsum[0] = ((float32*)T_softmax_expsum[0] + (float32*)T_softmax_exp[k_1])
                  }
                }
              }
            }
          }
        }
      }
      for (i3_1: int32, 0, d3) {
        T_softmax_norm[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_7) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_6)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_5)) + (i3_1*stride_4))] = ((float32*)T_softmax_exp[i3_1] / (float32*)T_softmax_expsum[0])
      }
    }
  }
}

primfn(args_2: handle, arg_type_ids_2: handle, num_args_2: int32, out_ret_value_2: handle, out_ret_tcode_2: handle, resource_handle_2: handle) -> int32
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True, "target": meta[Target][0], "calling_conv": 1} {
  assert((num_args_2 == 2), "shape_func_nn_softmax_1: num_args should be 2")
  let arg0_2: handle = @tir.tvm_struct_get(args_2, 0, 12, dtype=handle)
  let arg0.code_2: int32 = (int32*)arg_type_ids_2[0]
  let arg1_2: handle = @tir.tvm_struct_get(args_2, 1, 12, dtype=handle)
  let arg1.code_2: int32 = (int32*)arg_type_ids_2[1]
  let placeholder_2: Pointer(int64) = @tir.tvm_struct_get(arg0_2, 0, 1, dtype=handle)
  attr [placeholder_2] "storage_alignment" = 128;
  let arg0.shape_2: handle = @tir.tvm_struct_get(arg0_2, 0, 2, dtype=handle)
  let arg0.strides_2: handle = @tir.tvm_struct_get(arg0_2, 0, 3, dtype=handle)
  let dev_id_2: int32 = @tir.tvm_struct_get(arg0_2, 0, 9, dtype=int32)
  let compute: Pointer(int64) = @tir.tvm_struct_get(arg1_2, 0, 1, dtype=handle)
  attr [compute] "storage_alignment" = 128;
  let arg1.shape_2: handle = @tir.tvm_struct_get(arg1_2, 0, 2, dtype=handle)
  let arg1.strides_2: handle = @tir.tvm_struct_get(arg1_2, 0, 3, dtype=handle)
  assert(((((arg0.code_2 == 3) || (arg0.code_2 == 13)) || (arg0.code_2 == 7)) || (arg0.code_2 == 4)), "shape_func_nn_softmax_1: Expect arg[0] to be pointer")
  assert(((((arg1.code_2 == 3) || (arg1.code_2 == 13)) || (arg1.code_2 == 7)) || (arg1.code_2 == 4)), "shape_func_nn_softmax_1: Expect arg[1] to be pointer")
  attr ["default"] "device_id" = dev_id_2;
  attr ["default"] "device_type" = 1;
  assert((1 == @tir.tvm_struct_get(arg0_2, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((1 == @tir.tvm_struct_get(arg0_2, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((((@tir.tvm_struct_get(arg0_2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0_2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0_2, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((4 == cast(int32, (int64*)arg0.shape_2[0])), "Argument arg0.shape[0] has an unsatisfied constraint: (4 == int32(arg0.shape[0]))")
   {
    if !@tir.isnullptr(arg0.strides_2, dtype=bool) {
      assert((1 == cast(int32, (int64*)arg0.strides_2[0])), "arg0.strides: expected to be compact array")
      0
    }
    assert((0u64 == @tir.tvm_struct_get(arg0_2, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg0_2, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
    assert((1 == @tir.tvm_struct_get(arg1_2, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 1")
    assert((1 == @tir.tvm_struct_get(arg1_2, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 1")
    assert((((@tir.tvm_struct_get(arg1_2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1_2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1_2, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
    assert((4 == cast(int32, (int64*)arg1.shape_2[0])), "Argument arg1.shape[0] has an unsatisfied constraint: (4 == int32(arg1.shape[0]))")
     {
      if !@tir.isnullptr(arg1.strides_2, dtype=bool) {
        assert((1 == cast(int32, (int64*)arg1.strides_2[0])), "arg1.strides: expected to be compact array")
        0
      }
      assert((0u64 == @tir.tvm_struct_get(arg1_2, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
      assert((1 == @tir.tvm_struct_get(arg1_2, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
      assert((dev_id_2 == @tir.tvm_struct_get(arg1_2, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
      attr [0] "compute_scope" = "shape_func_nn_softmax_1_compute_";
      for (i0: int32, 0, 4) {
        compute[i0] = (int64*)placeholder_2[i0]
      }
    }
  }
}

primfn(args_3: handle, arg_type_ids_3: handle, num_args_3: int32, out_ret_value_3: handle, out_ret_tcode_3: handle, resource_handle_3: handle) -> int32
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True, "target": meta[Target][0], "calling_conv": 1} {
  assert((num_args_3 == 2), "fused_multiply: num_args should be 2")
  let arg0_3: handle = @tir.tvm_struct_get(args_3, 0, 12, dtype=handle)
  let arg0.code_3: int32 = (int32*)arg_type_ids_3[0]
  let arg1_3: handle = @tir.tvm_struct_get(args_3, 1, 12, dtype=handle)
  let arg1.code_3: int32 = (int32*)arg_type_ids_3[1]
  let placeholder_3: Pointer(int64) = @tir.tvm_struct_get(arg0_3, 0, 1, dtype=handle)
  attr [placeholder_3] "storage_alignment" = 128;
  let arg0.shape_3: handle = @tir.tvm_struct_get(arg0_3, 0, 2, dtype=handle)
  let arg0.strides_3: handle = @tir.tvm_struct_get(arg0_3, 0, 3, dtype=handle)
  let dev_id_3: int32 = @tir.tvm_struct_get(arg0_3, 0, 9, dtype=int32)
  let T_multiply: Pointer(int64) = @tir.tvm_struct_get(arg1_3, 0, 1, dtype=handle)
  attr [T_multiply] "storage_alignment" = 128;
  let arg1.shape_3: handle = @tir.tvm_struct_get(arg1_3, 0, 2, dtype=handle)
  let arg1.strides_3: handle = @tir.tvm_struct_get(arg1_3, 0, 3, dtype=handle)
  assert(((((arg0.code_3 == 3) || (arg0.code_3 == 13)) || (arg0.code_3 == 7)) || (arg0.code_3 == 4)), "fused_multiply: Expect arg[0] to be pointer")
  assert(((((arg1.code_3 == 3) || (arg1.code_3 == 13)) || (arg1.code_3 == 7)) || (arg1.code_3 == 4)), "fused_multiply: Expect arg[1] to be pointer")
  attr ["default"] "device_id" = dev_id_3;
  attr ["default"] "device_type" = 1;
  assert((0 == @tir.tvm_struct_get(arg0_3, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0_3, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0_3, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0_3, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0_3, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0_3, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0_3, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1_3, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1_3, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1_3, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1_3, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1_3, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1_3, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1_3, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id_3 == @tir.tvm_struct_get(arg1_3, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  attr [0] "compute_scope" = "fused_multiply_compute_";
  T_multiply[0] = ((int64*)placeholder_3[0]*4i64)
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.SplitHostDevice
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": (nullptr), "tir.noalias": True, "global_symbol": "fused_prod", "calling_conv": 1} {
  assert((num_args == 2), "fused_prod: num_args should be 2")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_red: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_red] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_prod: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_prod: Expect arg[1] to be pointer")
  attr ["default"] "device_id" = dev_id;
  attr ["default"] "device_type" = 1;
  assert((1 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((4 == cast(int32, (int64*)arg0.shape[0])), "Argument arg0.shape[0] has an unsatisfied constraint: (4 == int32(arg0.shape[0]))")
   {
    if !@tir.isnullptr(arg0.strides, dtype=bool) {
      assert((1 == cast(int32, (int64*)arg0.strides[0])), "arg0.strides: expected to be compact array")
      0
    }
    assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
    assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
    assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
    assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
    assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
    assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
    attr [0] "compute_scope" = "fused_prod_compute_" {
      placeholder_red[0] = 1i64
      for (k0: int32, 0, 4) {
        placeholder_red[0] = ((int64*)placeholder_red[0]*(int64*)placeholder[k0])
      }
    }
  }
}

primfn(args_1: handle, arg_type_ids_1: handle, num_args_1: int32, out_ret_value_1: handle, out_ret_tcode_1: handle, resource_handle_1: handle) -> int32
  attr = {"target": (nullptr), "tir.noalias": True, "global_symbol": "fused_nn_softmax", "calling_conv": 1} {
  assert((num_args_1 == 2), "fused_nn_softmax: num_args should be 2")
  let arg0_1: handle = @tir.tvm_struct_get(args_1, 0, 12, dtype=handle)
  let arg0.code_1: int32 = (int32*)arg_type_ids_1[0]
  let arg1_1: handle = @tir.tvm_struct_get(args_1, 1, 12, dtype=handle)
  let arg1.code_1: int32 = (int32*)arg_type_ids_1[1]
  let placeholder_1: Pointer(float32) = @tir.tvm_struct_get(arg0_1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg0.shape_1: handle = @tir.tvm_struct_get(arg0_1, 0, 2, dtype=handle)
  let d0: int32 = cast(int32, (int64*)arg0.shape_1[0])
  let d1: int32 = cast(int32, (int64*)arg0.shape_1[1])
  let d2: int32 = cast(int32, (int64*)arg0.shape_1[2])
  let d3: int32 = cast(int32, (int64*)arg0.shape_1[3])
  let arg0.strides_1: handle = @tir.tvm_struct_get(arg0_1, 0, 3, dtype=handle)
  let stride: int32 = @tir.if_then_else((d3 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides_1, dtype=bool), 1, cast(int32, (int64*)arg0.strides_1[3]), dtype=int32), dtype=int32)
  let stride_1: int32 = @tir.if_then_else((d2 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides_1, dtype=bool), d3, cast(int32, (int64*)arg0.strides_1[2]), dtype=int32), dtype=int32)
  let stride_2: int32 = @tir.if_then_else((d1 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides_1, dtype=bool), (d3*d2), cast(int32, (int64*)arg0.strides_1[1]), dtype=int32), dtype=int32)
  let stride_3: int32 = @tir.if_then_else((d0 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides_1, dtype=bool), ((d3*d2)*d1), cast(int32, (int64*)arg0.strides_1[0]), dtype=int32), dtype=int32)
  let dev_id_1: int32 = @tir.tvm_struct_get(arg0_1, 0, 9, dtype=int32)
  let T_softmax_norm: Pointer(float32) = @tir.tvm_struct_get(arg1_1, 0, 1, dtype=handle)
  attr [T_softmax_norm] "storage_alignment" = 128;
  let arg1.shape_1: handle = @tir.tvm_struct_get(arg1_1, 0, 2, dtype=handle)
  let arg1.strides_1: handle = @tir.tvm_struct_get(arg1_1, 0, 3, dtype=handle)
  let stride_4: int32 = @tir.if_then_else((d3 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides_1, dtype=bool), 1, cast(int32, (int64*)arg1.strides_1[3]), dtype=int32), dtype=int32)
  let stride_5: int32 = @tir.if_then_else((d2 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides_1, dtype=bool), d3, cast(int32, (int64*)arg1.strides_1[2]), dtype=int32), dtype=int32)
  let stride_6: int32 = @tir.if_then_else((d1 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides_1, dtype=bool), (d3*d2), cast(int32, (int64*)arg1.strides_1[1]), dtype=int32), dtype=int32)
  let stride_7: int32 = @tir.if_then_else((d0 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides_1, dtype=bool), ((d3*d2)*d1), cast(int32, (int64*)arg1.strides_1[0]), dtype=int32), dtype=int32)
  assert(((((arg0.code_1 == 3) || (arg0.code_1 == 13)) || (arg0.code_1 == 7)) || (arg0.code_1 == 4)), "fused_nn_softmax: Expect arg[0] to be pointer")
  assert(((((arg1.code_1 == 3) || (arg1.code_1 == 13)) || (arg1.code_1 == 7)) || (arg1.code_1 == 4)), "fused_nn_softmax: Expect arg[1] to be pointer")
  attr ["default"] "device_id" = dev_id_1;
  attr ["default"] "device_type" = 1;
  assert((4 == @tir.tvm_struct_get(arg0_1, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 4")
  assert((4 == @tir.tvm_struct_get(arg0_1, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 4")
  assert((((@tir.tvm_struct_get(arg0_1, 0, 5, dtype=uint8) == 2u8) && (@tir.tvm_struct_get(arg0_1, 0, 6, dtype=uint8) == 32u8)) && (@tir.tvm_struct_get(arg0_1, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be float32")
  assert((0u64 == @tir.tvm_struct_get(arg0_1, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0_1, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((4 == @tir.tvm_struct_get(arg1_1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 4")
  assert((4 == @tir.tvm_struct_get(arg1_1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 4")
  assert((((@tir.tvm_struct_get(arg1_1, 0, 5, dtype=uint8) == 2u8) && (@tir.tvm_struct_get(arg1_1, 0, 6, dtype=uint8) == 32u8)) && (@tir.tvm_struct_get(arg1_1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be float32")
  assert((d0 == cast(int32, (int64*)arg1.shape_1[0])), "Argument arg1.shape[0] has an unsatisfied constraint: (d0 == int32(arg1.shape[0]))")
  assert((d1 == cast(int32, (int64*)arg1.shape_1[1])), "Argument arg1.shape[1] has an unsatisfied constraint: (d1 == int32(arg1.shape[1]))")
  assert((d2 == cast(int32, (int64*)arg1.shape_1[2])), "Argument arg1.shape[2] has an unsatisfied constraint: (d2 == int32(arg1.shape[2]))")
  assert((d3 == cast(int32, (int64*)arg1.shape_1[3])), "Argument arg1.shape[3] has an unsatisfied constraint: (d3 == int32(arg1.shape[3]))")
  assert((0u64 == @tir.tvm_struct_get(arg1_1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1_1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id_1 == @tir.tvm_struct_get(arg1_1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  attr [0] "compute_scope" = "fused_nn_softmax_compute_";
  for (i0.i1.fused.i2.fused: int32, 0, ((d0*d1)*d2)) "parallel" {
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_maxelem, float32, [1]);
    attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_exp, float32, [d3]);
    attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_expsum, float32, [1]) {
      T_softmax_maxelem[0] = -3.40282e+38f32
      if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
        if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
          if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
              if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                  for (k: int32, 0, d3) {
                    T_softmax_maxelem[0] = max((float32*)T_softmax_maxelem[0], (float32*)placeholder_1[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_3) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_2)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_1)) + (k*stride))])
                  }
                }
              }
            }
          }
        }
      }
      if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
        if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
          if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
              if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                  for (i3: int32, 0, d3) {
                    T_softmax_exp[i3] = @tir.exp(((float32*)placeholder_1[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_3) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_2)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_1)) + (i3*stride))] - (float32*)T_softmax_maxelem[0]), dtype=float32)
                  }
                }
              }
            }
          }
        }
      }
      T_softmax_expsum[0] = 0f32
      if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
        if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
          if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
              if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                  for (k_1: int32, 0, d3) {
                    T_softmax_expsum[0] = ((float32*)T_softmax_expsum[0] + (float32*)T_softmax_exp[k_1])
                  }
                }
              }
            }
          }
        }
      }
      for (i3_1: int32, 0, d3) {
        T_softmax_norm[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_7) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_6)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_5)) + (i3_1*stride_4))] = ((float32*)T_softmax_exp[i3_1] / (float32*)T_softmax_expsum[0])
      }
    }
  }
}

primfn(args_2: handle, arg_type_ids_2: handle, num_args_2: int32, out_ret_value_2: handle, out_ret_tcode_2: handle, resource_handle_2: handle) -> int32
  attr = {"target": (nullptr), "tir.noalias": True, "global_symbol": "shape_func_nn_softmax_1", "calling_conv": 1} {
  assert((num_args_2 == 2), "shape_func_nn_softmax_1: num_args should be 2")
  let arg0_2: handle = @tir.tvm_struct_get(args_2, 0, 12, dtype=handle)
  let arg0.code_2: int32 = (int32*)arg_type_ids_2[0]
  let arg1_2: handle = @tir.tvm_struct_get(args_2, 1, 12, dtype=handle)
  let arg1.code_2: int32 = (int32*)arg_type_ids_2[1]
  let placeholder_2: Pointer(int64) = @tir.tvm_struct_get(arg0_2, 0, 1, dtype=handle)
  attr [placeholder_2] "storage_alignment" = 128;
  let arg0.shape_2: handle = @tir.tvm_struct_get(arg0_2, 0, 2, dtype=handle)
  let arg0.strides_2: handle = @tir.tvm_struct_get(arg0_2, 0, 3, dtype=handle)
  let dev_id_2: int32 = @tir.tvm_struct_get(arg0_2, 0, 9, dtype=int32)
  let compute: Pointer(int64) = @tir.tvm_struct_get(arg1_2, 0, 1, dtype=handle)
  attr [compute] "storage_alignment" = 128;
  let arg1.shape_2: handle = @tir.tvm_struct_get(arg1_2, 0, 2, dtype=handle)
  let arg1.strides_2: handle = @tir.tvm_struct_get(arg1_2, 0, 3, dtype=handle)
  assert(((((arg0.code_2 == 3) || (arg0.code_2 == 13)) || (arg0.code_2 == 7)) || (arg0.code_2 == 4)), "shape_func_nn_softmax_1: Expect arg[0] to be pointer")
  assert(((((arg1.code_2 == 3) || (arg1.code_2 == 13)) || (arg1.code_2 == 7)) || (arg1.code_2 == 4)), "shape_func_nn_softmax_1: Expect arg[1] to be pointer")
  attr ["default"] "device_id" = dev_id_2;
  attr ["default"] "device_type" = 1;
  assert((1 == @tir.tvm_struct_get(arg0_2, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((1 == @tir.tvm_struct_get(arg0_2, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((((@tir.tvm_struct_get(arg0_2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0_2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0_2, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((4 == cast(int32, (int64*)arg0.shape_2[0])), "Argument arg0.shape[0] has an unsatisfied constraint: (4 == int32(arg0.shape[0]))")
   {
    if !@tir.isnullptr(arg0.strides_2, dtype=bool) {
      assert((1 == cast(int32, (int64*)arg0.strides_2[0])), "arg0.strides: expected to be compact array")
      0
    }
    assert((0u64 == @tir.tvm_struct_get(arg0_2, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg0_2, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
    assert((1 == @tir.tvm_struct_get(arg1_2, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 1")
    assert((1 == @tir.tvm_struct_get(arg1_2, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 1")
    assert((((@tir.tvm_struct_get(arg1_2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1_2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1_2, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
    assert((4 == cast(int32, (int64*)arg1.shape_2[0])), "Argument arg1.shape[0] has an unsatisfied constraint: (4 == int32(arg1.shape[0]))")
     {
      if !@tir.isnullptr(arg1.strides_2, dtype=bool) {
        assert((1 == cast(int32, (int64*)arg1.strides_2[0])), "arg1.strides: expected to be compact array")
        0
      }
      assert((0u64 == @tir.tvm_struct_get(arg1_2, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
      assert((1 == @tir.tvm_struct_get(arg1_2, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
      assert((dev_id_2 == @tir.tvm_struct_get(arg1_2, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
      attr [0] "compute_scope" = "shape_func_nn_softmax_1_compute_";
      for (i0: int32, 0, 4) {
        compute[i0] = (int64*)placeholder_2[i0]
      }
    }
  }
}

primfn(args_3: handle, arg_type_ids_3: handle, num_args_3: int32, out_ret_value_3: handle, out_ret_tcode_3: handle, resource_handle_3: handle) -> int32
  attr = {"target": (nullptr), "tir.noalias": True, "global_symbol": "fused_multiply", "calling_conv": 1} {
  assert((num_args_3 == 2), "fused_multiply: num_args should be 2")
  let arg0_3: handle = @tir.tvm_struct_get(args_3, 0, 12, dtype=handle)
  let arg0.code_3: int32 = (int32*)arg_type_ids_3[0]
  let arg1_3: handle = @tir.tvm_struct_get(args_3, 1, 12, dtype=handle)
  let arg1.code_3: int32 = (int32*)arg_type_ids_3[1]
  let placeholder_3: Pointer(int64) = @tir.tvm_struct_get(arg0_3, 0, 1, dtype=handle)
  attr [placeholder_3] "storage_alignment" = 128;
  let arg0.shape_3: handle = @tir.tvm_struct_get(arg0_3, 0, 2, dtype=handle)
  let arg0.strides_3: handle = @tir.tvm_struct_get(arg0_3, 0, 3, dtype=handle)
  let dev_id_3: int32 = @tir.tvm_struct_get(arg0_3, 0, 9, dtype=int32)
  let T_multiply: Pointer(int64) = @tir.tvm_struct_get(arg1_3, 0, 1, dtype=handle)
  attr [T_multiply] "storage_alignment" = 128;
  let arg1.shape_3: handle = @tir.tvm_struct_get(arg1_3, 0, 2, dtype=handle)
  let arg1.strides_3: handle = @tir.tvm_struct_get(arg1_3, 0, 3, dtype=handle)
  assert(((((arg0.code_3 == 3) || (arg0.code_3 == 13)) || (arg0.code_3 == 7)) || (arg0.code_3 == 4)), "fused_multiply: Expect arg[0] to be pointer")
  assert(((((arg1.code_3 == 3) || (arg1.code_3 == 13)) || (arg1.code_3 == 7)) || (arg1.code_3 == 4)), "fused_multiply: Expect arg[1] to be pointer")
  attr ["default"] "device_id" = dev_id_3;
  attr ["default"] "device_type" = 1;
  assert((0 == @tir.tvm_struct_get(arg0_3, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0_3, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0_3, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0_3, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0_3, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0_3, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0_3, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1_3, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1_3, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1_3, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1_3, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1_3, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1_3, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1_3, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id_3 == @tir.tvm_struct_get(arg1_3, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  attr [0] "compute_scope" = "fused_multiply_compute_";
  T_multiply[0] = ((int64*)placeholder_3[0]*4i64)
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass Filter
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": (nullptr), "tir.noalias": True, "global_symbol": "fused_prod", "calling_conv": 1} {
  assert((num_args == 2), "fused_prod: num_args should be 2")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_red: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_red] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_prod: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_prod: Expect arg[1] to be pointer")
  attr ["default"] "device_id" = dev_id;
  attr ["default"] "device_type" = 1;
  assert((1 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((4 == cast(int32, (int64*)arg0.shape[0])), "Argument arg0.shape[0] has an unsatisfied constraint: (4 == int32(arg0.shape[0]))")
   {
    if !@tir.isnullptr(arg0.strides, dtype=bool) {
      assert((1 == cast(int32, (int64*)arg0.strides[0])), "arg0.strides: expected to be compact array")
      0
    }
    assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
    assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
    assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
    assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
    assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
    assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
    attr [0] "compute_scope" = "fused_prod_compute_" {
      placeholder_red[0] = 1i64
      for (k0: int32, 0, 4) {
        placeholder_red[0] = ((int64*)placeholder_red[0]*(int64*)placeholder[k0])
      }
    }
  }
}

primfn(args_1: handle, arg_type_ids_1: handle, num_args_1: int32, out_ret_value_1: handle, out_ret_tcode_1: handle, resource_handle_1: handle) -> int32
  attr = {"target": (nullptr), "tir.noalias": True, "global_symbol": "fused_nn_softmax", "calling_conv": 1} {
  assert((num_args_1 == 2), "fused_nn_softmax: num_args should be 2")
  let arg0_1: handle = @tir.tvm_struct_get(args_1, 0, 12, dtype=handle)
  let arg0.code_1: int32 = (int32*)arg_type_ids_1[0]
  let arg1_1: handle = @tir.tvm_struct_get(args_1, 1, 12, dtype=handle)
  let arg1.code_1: int32 = (int32*)arg_type_ids_1[1]
  let placeholder_1: Pointer(float32) = @tir.tvm_struct_get(arg0_1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg0.shape_1: handle = @tir.tvm_struct_get(arg0_1, 0, 2, dtype=handle)
  let d0: int32 = cast(int32, (int64*)arg0.shape_1[0])
  let d1: int32 = cast(int32, (int64*)arg0.shape_1[1])
  let d2: int32 = cast(int32, (int64*)arg0.shape_1[2])
  let d3: int32 = cast(int32, (int64*)arg0.shape_1[3])
  let arg0.strides_1: handle = @tir.tvm_struct_get(arg0_1, 0, 3, dtype=handle)
  let stride: int32 = @tir.if_then_else((d3 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides_1, dtype=bool), 1, cast(int32, (int64*)arg0.strides_1[3]), dtype=int32), dtype=int32)
  let stride_1: int32 = @tir.if_then_else((d2 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides_1, dtype=bool), d3, cast(int32, (int64*)arg0.strides_1[2]), dtype=int32), dtype=int32)
  let stride_2: int32 = @tir.if_then_else((d1 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides_1, dtype=bool), (d3*d2), cast(int32, (int64*)arg0.strides_1[1]), dtype=int32), dtype=int32)
  let stride_3: int32 = @tir.if_then_else((d0 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides_1, dtype=bool), ((d3*d2)*d1), cast(int32, (int64*)arg0.strides_1[0]), dtype=int32), dtype=int32)
  let dev_id_1: int32 = @tir.tvm_struct_get(arg0_1, 0, 9, dtype=int32)
  let T_softmax_norm: Pointer(float32) = @tir.tvm_struct_get(arg1_1, 0, 1, dtype=handle)
  attr [T_softmax_norm] "storage_alignment" = 128;
  let arg1.shape_1: handle = @tir.tvm_struct_get(arg1_1, 0, 2, dtype=handle)
  let arg1.strides_1: handle = @tir.tvm_struct_get(arg1_1, 0, 3, dtype=handle)
  let stride_4: int32 = @tir.if_then_else((d3 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides_1, dtype=bool), 1, cast(int32, (int64*)arg1.strides_1[3]), dtype=int32), dtype=int32)
  let stride_5: int32 = @tir.if_then_else((d2 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides_1, dtype=bool), d3, cast(int32, (int64*)arg1.strides_1[2]), dtype=int32), dtype=int32)
  let stride_6: int32 = @tir.if_then_else((d1 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides_1, dtype=bool), (d3*d2), cast(int32, (int64*)arg1.strides_1[1]), dtype=int32), dtype=int32)
  let stride_7: int32 = @tir.if_then_else((d0 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides_1, dtype=bool), ((d3*d2)*d1), cast(int32, (int64*)arg1.strides_1[0]), dtype=int32), dtype=int32)
  assert(((((arg0.code_1 == 3) || (arg0.code_1 == 13)) || (arg0.code_1 == 7)) || (arg0.code_1 == 4)), "fused_nn_softmax: Expect arg[0] to be pointer")
  assert(((((arg1.code_1 == 3) || (arg1.code_1 == 13)) || (arg1.code_1 == 7)) || (arg1.code_1 == 4)), "fused_nn_softmax: Expect arg[1] to be pointer")
  attr ["default"] "device_id" = dev_id_1;
  attr ["default"] "device_type" = 1;
  assert((4 == @tir.tvm_struct_get(arg0_1, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 4")
  assert((4 == @tir.tvm_struct_get(arg0_1, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 4")
  assert((((@tir.tvm_struct_get(arg0_1, 0, 5, dtype=uint8) == 2u8) && (@tir.tvm_struct_get(arg0_1, 0, 6, dtype=uint8) == 32u8)) && (@tir.tvm_struct_get(arg0_1, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be float32")
  assert((0u64 == @tir.tvm_struct_get(arg0_1, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0_1, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((4 == @tir.tvm_struct_get(arg1_1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 4")
  assert((4 == @tir.tvm_struct_get(arg1_1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 4")
  assert((((@tir.tvm_struct_get(arg1_1, 0, 5, dtype=uint8) == 2u8) && (@tir.tvm_struct_get(arg1_1, 0, 6, dtype=uint8) == 32u8)) && (@tir.tvm_struct_get(arg1_1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be float32")
  assert((d0 == cast(int32, (int64*)arg1.shape_1[0])), "Argument arg1.shape[0] has an unsatisfied constraint: (d0 == int32(arg1.shape[0]))")
  assert((d1 == cast(int32, (int64*)arg1.shape_1[1])), "Argument arg1.shape[1] has an unsatisfied constraint: (d1 == int32(arg1.shape[1]))")
  assert((d2 == cast(int32, (int64*)arg1.shape_1[2])), "Argument arg1.shape[2] has an unsatisfied constraint: (d2 == int32(arg1.shape[2]))")
  assert((d3 == cast(int32, (int64*)arg1.shape_1[3])), "Argument arg1.shape[3] has an unsatisfied constraint: (d3 == int32(arg1.shape[3]))")
  assert((0u64 == @tir.tvm_struct_get(arg1_1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1_1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id_1 == @tir.tvm_struct_get(arg1_1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  attr [0] "compute_scope" = "fused_nn_softmax_compute_";
  for (i0.i1.fused.i2.fused: int32, 0, ((d0*d1)*d2)) "parallel" {
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_maxelem, float32, [1]);
    attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_exp, float32, [d3]);
    attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_expsum, float32, [1]) {
      T_softmax_maxelem[0] = -3.40282e+38f32
      if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
        if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
          if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
              if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                  for (k: int32, 0, d3) {
                    T_softmax_maxelem[0] = max((float32*)T_softmax_maxelem[0], (float32*)placeholder_1[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_3) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_2)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_1)) + (k*stride))])
                  }
                }
              }
            }
          }
        }
      }
      if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
        if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
          if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
              if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                  for (i3: int32, 0, d3) {
                    T_softmax_exp[i3] = @tir.exp(((float32*)placeholder_1[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_3) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_2)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_1)) + (i3*stride))] - (float32*)T_softmax_maxelem[0]), dtype=float32)
                  }
                }
              }
            }
          }
        }
      }
      T_softmax_expsum[0] = 0f32
      if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
        if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
          if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
              if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                  for (k_1: int32, 0, d3) {
                    T_softmax_expsum[0] = ((float32*)T_softmax_expsum[0] + (float32*)T_softmax_exp[k_1])
                  }
                }
              }
            }
          }
        }
      }
      for (i3_1: int32, 0, d3) {
        T_softmax_norm[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_7) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_6)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_5)) + (i3_1*stride_4))] = ((float32*)T_softmax_exp[i3_1] / (float32*)T_softmax_expsum[0])
      }
    }
  }
}

primfn(args_2: handle, arg_type_ids_2: handle, num_args_2: int32, out_ret_value_2: handle, out_ret_tcode_2: handle, resource_handle_2: handle) -> int32
  attr = {"target": (nullptr), "tir.noalias": True, "global_symbol": "shape_func_nn_softmax_1", "calling_conv": 1} {
  assert((num_args_2 == 2), "shape_func_nn_softmax_1: num_args should be 2")
  let arg0_2: handle = @tir.tvm_struct_get(args_2, 0, 12, dtype=handle)
  let arg0.code_2: int32 = (int32*)arg_type_ids_2[0]
  let arg1_2: handle = @tir.tvm_struct_get(args_2, 1, 12, dtype=handle)
  let arg1.code_2: int32 = (int32*)arg_type_ids_2[1]
  let placeholder_2: Pointer(int64) = @tir.tvm_struct_get(arg0_2, 0, 1, dtype=handle)
  attr [placeholder_2] "storage_alignment" = 128;
  let arg0.shape_2: handle = @tir.tvm_struct_get(arg0_2, 0, 2, dtype=handle)
  let arg0.strides_2: handle = @tir.tvm_struct_get(arg0_2, 0, 3, dtype=handle)
  let dev_id_2: int32 = @tir.tvm_struct_get(arg0_2, 0, 9, dtype=int32)
  let compute: Pointer(int64) = @tir.tvm_struct_get(arg1_2, 0, 1, dtype=handle)
  attr [compute] "storage_alignment" = 128;
  let arg1.shape_2: handle = @tir.tvm_struct_get(arg1_2, 0, 2, dtype=handle)
  let arg1.strides_2: handle = @tir.tvm_struct_get(arg1_2, 0, 3, dtype=handle)
  assert(((((arg0.code_2 == 3) || (arg0.code_2 == 13)) || (arg0.code_2 == 7)) || (arg0.code_2 == 4)), "shape_func_nn_softmax_1: Expect arg[0] to be pointer")
  assert(((((arg1.code_2 == 3) || (arg1.code_2 == 13)) || (arg1.code_2 == 7)) || (arg1.code_2 == 4)), "shape_func_nn_softmax_1: Expect arg[1] to be pointer")
  attr ["default"] "device_id" = dev_id_2;
  attr ["default"] "device_type" = 1;
  assert((1 == @tir.tvm_struct_get(arg0_2, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((1 == @tir.tvm_struct_get(arg0_2, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((((@tir.tvm_struct_get(arg0_2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0_2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0_2, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((4 == cast(int32, (int64*)arg0.shape_2[0])), "Argument arg0.shape[0] has an unsatisfied constraint: (4 == int32(arg0.shape[0]))")
   {
    if !@tir.isnullptr(arg0.strides_2, dtype=bool) {
      assert((1 == cast(int32, (int64*)arg0.strides_2[0])), "arg0.strides: expected to be compact array")
      0
    }
    assert((0u64 == @tir.tvm_struct_get(arg0_2, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg0_2, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
    assert((1 == @tir.tvm_struct_get(arg1_2, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 1")
    assert((1 == @tir.tvm_struct_get(arg1_2, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 1")
    assert((((@tir.tvm_struct_get(arg1_2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1_2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1_2, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
    assert((4 == cast(int32, (int64*)arg1.shape_2[0])), "Argument arg1.shape[0] has an unsatisfied constraint: (4 == int32(arg1.shape[0]))")
     {
      if !@tir.isnullptr(arg1.strides_2, dtype=bool) {
        assert((1 == cast(int32, (int64*)arg1.strides_2[0])), "arg1.strides: expected to be compact array")
        0
      }
      assert((0u64 == @tir.tvm_struct_get(arg1_2, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
      assert((1 == @tir.tvm_struct_get(arg1_2, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
      assert((dev_id_2 == @tir.tvm_struct_get(arg1_2, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
      attr [0] "compute_scope" = "shape_func_nn_softmax_1_compute_";
      for (i0: int32, 0, 4) {
        compute[i0] = (int64*)placeholder_2[i0]
      }
    }
  }
}

primfn(args_3: handle, arg_type_ids_3: handle, num_args_3: int32, out_ret_value_3: handle, out_ret_tcode_3: handle, resource_handle_3: handle) -> int32
  attr = {"target": (nullptr), "tir.noalias": True, "global_symbol": "fused_multiply", "calling_conv": 1} {
  assert((num_args_3 == 2), "fused_multiply: num_args should be 2")
  let arg0_3: handle = @tir.tvm_struct_get(args_3, 0, 12, dtype=handle)
  let arg0.code_3: int32 = (int32*)arg_type_ids_3[0]
  let arg1_3: handle = @tir.tvm_struct_get(args_3, 1, 12, dtype=handle)
  let arg1.code_3: int32 = (int32*)arg_type_ids_3[1]
  let placeholder_3: Pointer(int64) = @tir.tvm_struct_get(arg0_3, 0, 1, dtype=handle)
  attr [placeholder_3] "storage_alignment" = 128;
  let arg0.shape_3: handle = @tir.tvm_struct_get(arg0_3, 0, 2, dtype=handle)
  let arg0.strides_3: handle = @tir.tvm_struct_get(arg0_3, 0, 3, dtype=handle)
  let dev_id_3: int32 = @tir.tvm_struct_get(arg0_3, 0, 9, dtype=int32)
  let T_multiply: Pointer(int64) = @tir.tvm_struct_get(arg1_3, 0, 1, dtype=handle)
  attr [T_multiply] "storage_alignment" = 128;
  let arg1.shape_3: handle = @tir.tvm_struct_get(arg1_3, 0, 2, dtype=handle)
  let arg1.strides_3: handle = @tir.tvm_struct_get(arg1_3, 0, 3, dtype=handle)
  assert(((((arg0.code_3 == 3) || (arg0.code_3 == 13)) || (arg0.code_3 == 7)) || (arg0.code_3 == 4)), "fused_multiply: Expect arg[0] to be pointer")
  assert(((((arg1.code_3 == 3) || (arg1.code_3 == 13)) || (arg1.code_3 == 7)) || (arg1.code_3 == 4)), "fused_multiply: Expect arg[1] to be pointer")
  attr ["default"] "device_id" = dev_id_3;
  attr ["default"] "device_type" = 1;
  assert((0 == @tir.tvm_struct_get(arg0_3, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0_3, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0_3, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0_3, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0_3, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0_3, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0_3, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1_3, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1_3, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1_3, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1_3, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1_3, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1_3, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1_3, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id_3 == @tir.tvm_struct_get(arg1_3, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  attr [0] "compute_scope" = "fused_multiply_compute_";
  T_multiply[0] = ((int64*)placeholder_3[0]*4i64)
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass BindTarget
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_prod", "calling_conv": 1} {
  assert((num_args == 2), "fused_prod: num_args should be 2")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_red: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_red] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_prod: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_prod: Expect arg[1] to be pointer")
  attr ["default"] "device_id" = dev_id;
  attr ["default"] "device_type" = 1;
  assert((1 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((4 == cast(int32, (int64*)arg0.shape[0])), "Argument arg0.shape[0] has an unsatisfied constraint: (4 == int32(arg0.shape[0]))")
   {
    if !@tir.isnullptr(arg0.strides, dtype=bool) {
      assert((1 == cast(int32, (int64*)arg0.strides[0])), "arg0.strides: expected to be compact array")
      0
    }
    assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
    assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
    assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
    assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
    assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
    assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
    attr [0] "compute_scope" = "fused_prod_compute_" {
      placeholder_red[0] = 1i64
      for (k0: int32, 0, 4) {
        placeholder_red[0] = ((int64*)placeholder_red[0]*(int64*)placeholder[k0])
      }
    }
  }
}

primfn(args_1: handle, arg_type_ids_1: handle, num_args_1: int32, out_ret_value_1: handle, out_ret_tcode_1: handle, resource_handle_1: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_nn_softmax", "calling_conv": 1} {
  assert((num_args_1 == 2), "fused_nn_softmax: num_args should be 2")
  let arg0_1: handle = @tir.tvm_struct_get(args_1, 0, 12, dtype=handle)
  let arg0.code_1: int32 = (int32*)arg_type_ids_1[0]
  let arg1_1: handle = @tir.tvm_struct_get(args_1, 1, 12, dtype=handle)
  let arg1.code_1: int32 = (int32*)arg_type_ids_1[1]
  let placeholder_1: Pointer(float32) = @tir.tvm_struct_get(arg0_1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg0.shape_1: handle = @tir.tvm_struct_get(arg0_1, 0, 2, dtype=handle)
  let d0: int32 = cast(int32, (int64*)arg0.shape_1[0])
  let d1: int32 = cast(int32, (int64*)arg0.shape_1[1])
  let d2: int32 = cast(int32, (int64*)arg0.shape_1[2])
  let d3: int32 = cast(int32, (int64*)arg0.shape_1[3])
  let arg0.strides_1: handle = @tir.tvm_struct_get(arg0_1, 0, 3, dtype=handle)
  let stride: int32 = @tir.if_then_else((d3 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides_1, dtype=bool), 1, cast(int32, (int64*)arg0.strides_1[3]), dtype=int32), dtype=int32)
  let stride_1: int32 = @tir.if_then_else((d2 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides_1, dtype=bool), d3, cast(int32, (int64*)arg0.strides_1[2]), dtype=int32), dtype=int32)
  let stride_2: int32 = @tir.if_then_else((d1 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides_1, dtype=bool), (d3*d2), cast(int32, (int64*)arg0.strides_1[1]), dtype=int32), dtype=int32)
  let stride_3: int32 = @tir.if_then_else((d0 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides_1, dtype=bool), ((d3*d2)*d1), cast(int32, (int64*)arg0.strides_1[0]), dtype=int32), dtype=int32)
  let dev_id_1: int32 = @tir.tvm_struct_get(arg0_1, 0, 9, dtype=int32)
  let T_softmax_norm: Pointer(float32) = @tir.tvm_struct_get(arg1_1, 0, 1, dtype=handle)
  attr [T_softmax_norm] "storage_alignment" = 128;
  let arg1.shape_1: handle = @tir.tvm_struct_get(arg1_1, 0, 2, dtype=handle)
  let arg1.strides_1: handle = @tir.tvm_struct_get(arg1_1, 0, 3, dtype=handle)
  let stride_4: int32 = @tir.if_then_else((d3 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides_1, dtype=bool), 1, cast(int32, (int64*)arg1.strides_1[3]), dtype=int32), dtype=int32)
  let stride_5: int32 = @tir.if_then_else((d2 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides_1, dtype=bool), d3, cast(int32, (int64*)arg1.strides_1[2]), dtype=int32), dtype=int32)
  let stride_6: int32 = @tir.if_then_else((d1 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides_1, dtype=bool), (d3*d2), cast(int32, (int64*)arg1.strides_1[1]), dtype=int32), dtype=int32)
  let stride_7: int32 = @tir.if_then_else((d0 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides_1, dtype=bool), ((d3*d2)*d1), cast(int32, (int64*)arg1.strides_1[0]), dtype=int32), dtype=int32)
  assert(((((arg0.code_1 == 3) || (arg0.code_1 == 13)) || (arg0.code_1 == 7)) || (arg0.code_1 == 4)), "fused_nn_softmax: Expect arg[0] to be pointer")
  assert(((((arg1.code_1 == 3) || (arg1.code_1 == 13)) || (arg1.code_1 == 7)) || (arg1.code_1 == 4)), "fused_nn_softmax: Expect arg[1] to be pointer")
  attr ["default"] "device_id" = dev_id_1;
  attr ["default"] "device_type" = 1;
  assert((4 == @tir.tvm_struct_get(arg0_1, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 4")
  assert((4 == @tir.tvm_struct_get(arg0_1, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 4")
  assert((((@tir.tvm_struct_get(arg0_1, 0, 5, dtype=uint8) == 2u8) && (@tir.tvm_struct_get(arg0_1, 0, 6, dtype=uint8) == 32u8)) && (@tir.tvm_struct_get(arg0_1, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be float32")
  assert((0u64 == @tir.tvm_struct_get(arg0_1, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0_1, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((4 == @tir.tvm_struct_get(arg1_1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 4")
  assert((4 == @tir.tvm_struct_get(arg1_1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 4")
  assert((((@tir.tvm_struct_get(arg1_1, 0, 5, dtype=uint8) == 2u8) && (@tir.tvm_struct_get(arg1_1, 0, 6, dtype=uint8) == 32u8)) && (@tir.tvm_struct_get(arg1_1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be float32")
  assert((d0 == cast(int32, (int64*)arg1.shape_1[0])), "Argument arg1.shape[0] has an unsatisfied constraint: (d0 == int32(arg1.shape[0]))")
  assert((d1 == cast(int32, (int64*)arg1.shape_1[1])), "Argument arg1.shape[1] has an unsatisfied constraint: (d1 == int32(arg1.shape[1]))")
  assert((d2 == cast(int32, (int64*)arg1.shape_1[2])), "Argument arg1.shape[2] has an unsatisfied constraint: (d2 == int32(arg1.shape[2]))")
  assert((d3 == cast(int32, (int64*)arg1.shape_1[3])), "Argument arg1.shape[3] has an unsatisfied constraint: (d3 == int32(arg1.shape[3]))")
  assert((0u64 == @tir.tvm_struct_get(arg1_1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1_1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id_1 == @tir.tvm_struct_get(arg1_1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  attr [0] "compute_scope" = "fused_nn_softmax_compute_";
  for (i0.i1.fused.i2.fused: int32, 0, ((d0*d1)*d2)) "parallel" {
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_maxelem, float32, [1]);
    attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_exp, float32, [d3]);
    attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_expsum, float32, [1]) {
      T_softmax_maxelem[0] = -3.40282e+38f32
      if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
        if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
          if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
              if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                  for (k: int32, 0, d3) {
                    T_softmax_maxelem[0] = max((float32*)T_softmax_maxelem[0], (float32*)placeholder_1[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_3) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_2)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_1)) + (k*stride))])
                  }
                }
              }
            }
          }
        }
      }
      if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
        if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
          if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
              if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                  for (i3: int32, 0, d3) {
                    T_softmax_exp[i3] = @tir.exp(((float32*)placeholder_1[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_3) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_2)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_1)) + (i3*stride))] - (float32*)T_softmax_maxelem[0]), dtype=float32)
                  }
                }
              }
            }
          }
        }
      }
      T_softmax_expsum[0] = 0f32
      if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
        if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
          if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
            if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
              if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                  for (k_1: int32, 0, d3) {
                    T_softmax_expsum[0] = ((float32*)T_softmax_expsum[0] + (float32*)T_softmax_exp[k_1])
                  }
                }
              }
            }
          }
        }
      }
      for (i3_1: int32, 0, d3) {
        T_softmax_norm[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_7) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_6)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_5)) + (i3_1*stride_4))] = ((float32*)T_softmax_exp[i3_1] / (float32*)T_softmax_expsum[0])
      }
    }
  }
}

primfn(args_2: handle, arg_type_ids_2: handle, num_args_2: int32, out_ret_value_2: handle, out_ret_tcode_2: handle, resource_handle_2: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "shape_func_nn_softmax_1", "calling_conv": 1} {
  assert((num_args_2 == 2), "shape_func_nn_softmax_1: num_args should be 2")
  let arg0_2: handle = @tir.tvm_struct_get(args_2, 0, 12, dtype=handle)
  let arg0.code_2: int32 = (int32*)arg_type_ids_2[0]
  let arg1_2: handle = @tir.tvm_struct_get(args_2, 1, 12, dtype=handle)
  let arg1.code_2: int32 = (int32*)arg_type_ids_2[1]
  let placeholder_2: Pointer(int64) = @tir.tvm_struct_get(arg0_2, 0, 1, dtype=handle)
  attr [placeholder_2] "storage_alignment" = 128;
  let arg0.shape_2: handle = @tir.tvm_struct_get(arg0_2, 0, 2, dtype=handle)
  let arg0.strides_2: handle = @tir.tvm_struct_get(arg0_2, 0, 3, dtype=handle)
  let dev_id_2: int32 = @tir.tvm_struct_get(arg0_2, 0, 9, dtype=int32)
  let compute: Pointer(int64) = @tir.tvm_struct_get(arg1_2, 0, 1, dtype=handle)
  attr [compute] "storage_alignment" = 128;
  let arg1.shape_2: handle = @tir.tvm_struct_get(arg1_2, 0, 2, dtype=handle)
  let arg1.strides_2: handle = @tir.tvm_struct_get(arg1_2, 0, 3, dtype=handle)
  assert(((((arg0.code_2 == 3) || (arg0.code_2 == 13)) || (arg0.code_2 == 7)) || (arg0.code_2 == 4)), "shape_func_nn_softmax_1: Expect arg[0] to be pointer")
  assert(((((arg1.code_2 == 3) || (arg1.code_2 == 13)) || (arg1.code_2 == 7)) || (arg1.code_2 == 4)), "shape_func_nn_softmax_1: Expect arg[1] to be pointer")
  attr ["default"] "device_id" = dev_id_2;
  attr ["default"] "device_type" = 1;
  assert((1 == @tir.tvm_struct_get(arg0_2, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((1 == @tir.tvm_struct_get(arg0_2, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((((@tir.tvm_struct_get(arg0_2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0_2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0_2, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((4 == cast(int32, (int64*)arg0.shape_2[0])), "Argument arg0.shape[0] has an unsatisfied constraint: (4 == int32(arg0.shape[0]))")
   {
    if !@tir.isnullptr(arg0.strides_2, dtype=bool) {
      assert((1 == cast(int32, (int64*)arg0.strides_2[0])), "arg0.strides: expected to be compact array")
      0
    }
    assert((0u64 == @tir.tvm_struct_get(arg0_2, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg0_2, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
    assert((1 == @tir.tvm_struct_get(arg1_2, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 1")
    assert((1 == @tir.tvm_struct_get(arg1_2, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 1")
    assert((((@tir.tvm_struct_get(arg1_2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1_2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1_2, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
    assert((4 == cast(int32, (int64*)arg1.shape_2[0])), "Argument arg1.shape[0] has an unsatisfied constraint: (4 == int32(arg1.shape[0]))")
     {
      if !@tir.isnullptr(arg1.strides_2, dtype=bool) {
        assert((1 == cast(int32, (int64*)arg1.strides_2[0])), "arg1.strides: expected to be compact array")
        0
      }
      assert((0u64 == @tir.tvm_struct_get(arg1_2, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
      assert((1 == @tir.tvm_struct_get(arg1_2, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
      assert((dev_id_2 == @tir.tvm_struct_get(arg1_2, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
      attr [0] "compute_scope" = "shape_func_nn_softmax_1_compute_";
      for (i0: int32, 0, 4) {
        compute[i0] = (int64*)placeholder_2[i0]
      }
    }
  }
}

primfn(args_3: handle, arg_type_ids_3: handle, num_args_3: int32, out_ret_value_3: handle, out_ret_tcode_3: handle, resource_handle_3: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_multiply", "calling_conv": 1} {
  assert((num_args_3 == 2), "fused_multiply: num_args should be 2")
  let arg0_3: handle = @tir.tvm_struct_get(args_3, 0, 12, dtype=handle)
  let arg0.code_3: int32 = (int32*)arg_type_ids_3[0]
  let arg1_3: handle = @tir.tvm_struct_get(args_3, 1, 12, dtype=handle)
  let arg1.code_3: int32 = (int32*)arg_type_ids_3[1]
  let placeholder_3: Pointer(int64) = @tir.tvm_struct_get(arg0_3, 0, 1, dtype=handle)
  attr [placeholder_3] "storage_alignment" = 128;
  let arg0.shape_3: handle = @tir.tvm_struct_get(arg0_3, 0, 2, dtype=handle)
  let arg0.strides_3: handle = @tir.tvm_struct_get(arg0_3, 0, 3, dtype=handle)
  let dev_id_3: int32 = @tir.tvm_struct_get(arg0_3, 0, 9, dtype=int32)
  let T_multiply: Pointer(int64) = @tir.tvm_struct_get(arg1_3, 0, 1, dtype=handle)
  attr [T_multiply] "storage_alignment" = 128;
  let arg1.shape_3: handle = @tir.tvm_struct_get(arg1_3, 0, 2, dtype=handle)
  let arg1.strides_3: handle = @tir.tvm_struct_get(arg1_3, 0, 3, dtype=handle)
  assert(((((arg0.code_3 == 3) || (arg0.code_3 == 13)) || (arg0.code_3 == 7)) || (arg0.code_3 == 4)), "fused_multiply: Expect arg[0] to be pointer")
  assert(((((arg1.code_3 == 3) || (arg1.code_3 == 13)) || (arg1.code_3 == 7)) || (arg1.code_3 == 4)), "fused_multiply: Expect arg[1] to be pointer")
  attr ["default"] "device_id" = dev_id_3;
  attr ["default"] "device_type" = 1;
  assert((0 == @tir.tvm_struct_get(arg0_3, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0_3, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0_3, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0_3, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0_3, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0_3, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0_3, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1_3, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1_3, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1_3, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1_3, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1_3, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1_3, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1_3, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id_3 == @tir.tvm_struct_get(arg1_3, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  attr [0] "compute_scope" = "fused_multiply_compute_";
  T_multiply[0] = ((int64*)placeholder_3[0]*4i64)
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerTVMBuiltin
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_prod", "calling_conv": 1} {
  assert((num_args == 2), "fused_prod: num_args should be 2")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_red: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_red] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_prod: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_prod: Expect arg[1] to be pointer")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((4 == cast(int32, (int64*)arg0.shape[0])), "Argument arg0.shape[0] has an unsatisfied constraint: (4 == int32(arg0.shape[0]))")
   {
    if !@tir.isnullptr(arg0.strides, dtype=bool) {
      assert((1 == cast(int32, (int64*)arg0.strides[0])), "arg0.strides: expected to be compact array")
      0
    }
    assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
    assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
    assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
    assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
    assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
    assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
    attr [0] "compute_scope" = "fused_prod_compute_" {
      placeholder_red[0] = 1i64
      for (k0: int32, 0, 4) {
        placeholder_red[0] = ((int64*)placeholder_red[0]*(int64*)placeholder[k0])
      }
    }
  }
}

primfn(args_1: handle, arg_type_ids_1: handle, num_args_1: int32, out_ret_value_1: handle, out_ret_tcode_1: handle, resource_handle_1: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_nn_softmax", "calling_conv": 1} {
  assert((num_args_1 == 2), "fused_nn_softmax: num_args should be 2")
  let arg0_1: handle = @tir.tvm_struct_get(args_1, 0, 12, dtype=handle)
  let arg0.code_1: int32 = (int32*)arg_type_ids_1[0]
  let arg1_1: handle = @tir.tvm_struct_get(args_1, 1, 12, dtype=handle)
  let arg1.code_1: int32 = (int32*)arg_type_ids_1[1]
  let placeholder_1: Pointer(float32) = @tir.tvm_struct_get(arg0_1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg0.shape_1: handle = @tir.tvm_struct_get(arg0_1, 0, 2, dtype=handle)
  let d0: int32 = cast(int32, (int64*)arg0.shape_1[0])
  let d1: int32 = cast(int32, (int64*)arg0.shape_1[1])
  let d2: int32 = cast(int32, (int64*)arg0.shape_1[2])
  let d3: int32 = cast(int32, (int64*)arg0.shape_1[3])
  let arg0.strides_1: handle = @tir.tvm_struct_get(arg0_1, 0, 3, dtype=handle)
  let stride: int32 = @tir.if_then_else((d3 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides_1, dtype=bool), 1, cast(int32, (int64*)arg0.strides_1[3]), dtype=int32), dtype=int32)
  let stride_1: int32 = @tir.if_then_else((d2 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides_1, dtype=bool), d3, cast(int32, (int64*)arg0.strides_1[2]), dtype=int32), dtype=int32)
  let stride_2: int32 = @tir.if_then_else((d1 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides_1, dtype=bool), (d3*d2), cast(int32, (int64*)arg0.strides_1[1]), dtype=int32), dtype=int32)
  let stride_3: int32 = @tir.if_then_else((d0 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides_1, dtype=bool), ((d3*d2)*d1), cast(int32, (int64*)arg0.strides_1[0]), dtype=int32), dtype=int32)
  let dev_id_1: int32 = @tir.tvm_struct_get(arg0_1, 0, 9, dtype=int32)
  let T_softmax_norm: Pointer(float32) = @tir.tvm_struct_get(arg1_1, 0, 1, dtype=handle)
  attr [T_softmax_norm] "storage_alignment" = 128;
  let arg1.shape_1: handle = @tir.tvm_struct_get(arg1_1, 0, 2, dtype=handle)
  let arg1.strides_1: handle = @tir.tvm_struct_get(arg1_1, 0, 3, dtype=handle)
  let stride_4: int32 = @tir.if_then_else((d3 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides_1, dtype=bool), 1, cast(int32, (int64*)arg1.strides_1[3]), dtype=int32), dtype=int32)
  let stride_5: int32 = @tir.if_then_else((d2 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides_1, dtype=bool), d3, cast(int32, (int64*)arg1.strides_1[2]), dtype=int32), dtype=int32)
  let stride_6: int32 = @tir.if_then_else((d1 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides_1, dtype=bool), (d3*d2), cast(int32, (int64*)arg1.strides_1[1]), dtype=int32), dtype=int32)
  let stride_7: int32 = @tir.if_then_else((d0 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides_1, dtype=bool), ((d3*d2)*d1), cast(int32, (int64*)arg1.strides_1[0]), dtype=int32), dtype=int32)
  assert(((((arg0.code_1 == 3) || (arg0.code_1 == 13)) || (arg0.code_1 == 7)) || (arg0.code_1 == 4)), "fused_nn_softmax: Expect arg[0] to be pointer")
  assert(((((arg1.code_1 == 3) || (arg1.code_1 == 13)) || (arg1.code_1 == 7)) || (arg1.code_1 == 4)), "fused_nn_softmax: Expect arg[1] to be pointer")
  assert((4 == @tir.tvm_struct_get(arg0_1, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 4")
  assert((4 == @tir.tvm_struct_get(arg0_1, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 4")
  assert((((@tir.tvm_struct_get(arg0_1, 0, 5, dtype=uint8) == 2u8) && (@tir.tvm_struct_get(arg0_1, 0, 6, dtype=uint8) == 32u8)) && (@tir.tvm_struct_get(arg0_1, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be float32")
  assert((0u64 == @tir.tvm_struct_get(arg0_1, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0_1, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((4 == @tir.tvm_struct_get(arg1_1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 4")
  assert((4 == @tir.tvm_struct_get(arg1_1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 4")
  assert((((@tir.tvm_struct_get(arg1_1, 0, 5, dtype=uint8) == 2u8) && (@tir.tvm_struct_get(arg1_1, 0, 6, dtype=uint8) == 32u8)) && (@tir.tvm_struct_get(arg1_1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be float32")
  assert((d0 == cast(int32, (int64*)arg1.shape_1[0])), "Argument arg1.shape[0] has an unsatisfied constraint: (d0 == int32(arg1.shape[0]))")
  assert((d1 == cast(int32, (int64*)arg1.shape_1[1])), "Argument arg1.shape[1] has an unsatisfied constraint: (d1 == int32(arg1.shape[1]))")
  assert((d2 == cast(int32, (int64*)arg1.shape_1[2])), "Argument arg1.shape[2] has an unsatisfied constraint: (d2 == int32(arg1.shape[2]))")
  assert((d3 == cast(int32, (int64*)arg1.shape_1[3])), "Argument arg1.shape[3] has an unsatisfied constraint: (d3 == int32(arg1.shape[3]))")
  assert((0u64 == @tir.tvm_struct_get(arg1_1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1_1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id_1 == @tir.tvm_struct_get(arg1_1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  attr [0] "compute_scope" = "fused_nn_softmax_compute_";
  for (i0.i1.fused.i2.fused: int32, 0, ((d0*d1)*d2)) "parallel" {
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    attr [T_softmax_maxelem] "storage_alignment" = 128 {
      let T_softmax_maxelem = @tir.TVMBackendAllocWorkspace(1, dev_id_1, 4u64, 2, 32, dtype=handle)
       {
        if @tir.isnullptr(T_softmax_maxelem, dtype=bool) {
          @tir.tvm_throw_last_error(, dtype=int32)
        }
        attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
        attr [T_softmax_exp] "storage_alignment" = 128 {
          let T_softmax_exp = @tir.TVMBackendAllocWorkspace(1, dev_id_1, cast(uint64, (4*d3)), 2, 32, dtype=handle)
           {
            if @tir.isnullptr(T_softmax_exp, dtype=bool) {
              @tir.tvm_throw_last_error(, dtype=int32)
            }
            attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
            attr [T_softmax_expsum] "storage_alignment" = 128 {
              let T_softmax_expsum = @tir.TVMBackendAllocWorkspace(1, dev_id_1, 4u64, 2, 32, dtype=handle)
               {
                if @tir.isnullptr(T_softmax_expsum, dtype=bool) {
                  @tir.tvm_throw_last_error(, dtype=int32)
                }
                 {
                  T_softmax_maxelem[0] = -3.40282e+38f32
                  if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                    if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
                      if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                        if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
                          if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                            if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                              for (k: int32, 0, d3) {
                                T_softmax_maxelem[0] = max((float32*)T_softmax_maxelem[0], (float32*)placeholder_1[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_3) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_2)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_1)) + (k*stride))])
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                    if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
                      if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                        if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
                          if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                            if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                              for (i3: int32, 0, d3) {
                                T_softmax_exp[i3] = @tir.exp(((float32*)placeholder_1[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_3) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_2)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_1)) + (i3*stride))] - (float32*)T_softmax_maxelem[0]), dtype=float32)
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  T_softmax_expsum[0] = 0f32
                  if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                    if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
                      if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                        if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
                          if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                            if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                              for (k_1: int32, 0, d3) {
                                T_softmax_expsum[0] = ((float32*)T_softmax_expsum[0] + (float32*)T_softmax_exp[k_1])
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  for (i3_1: int32, 0, d3) {
                    T_softmax_norm[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_7) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_6)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_5)) + (i3_1*stride_4))] = ((float32*)T_softmax_exp[i3_1] / (float32*)T_softmax_expsum[0])
                  }
                }
              }
              if (@tir.TVMBackendFreeWorkspace(1, dev_id_1, T_softmax_expsum, dtype=int32) != 0) {
                @tir.tvm_throw_last_error(, dtype=int32)
              }
            }
          }
          if (@tir.TVMBackendFreeWorkspace(1, dev_id_1, T_softmax_exp, dtype=int32) != 0) {
            @tir.tvm_throw_last_error(, dtype=int32)
          }
        }
      }
      if (@tir.TVMBackendFreeWorkspace(1, dev_id_1, T_softmax_maxelem, dtype=int32) != 0) {
        @tir.tvm_throw_last_error(, dtype=int32)
      }
    }
  }
}

primfn(args_2: handle, arg_type_ids_2: handle, num_args_2: int32, out_ret_value_2: handle, out_ret_tcode_2: handle, resource_handle_2: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "shape_func_nn_softmax_1", "calling_conv": 1} {
  assert((num_args_2 == 2), "shape_func_nn_softmax_1: num_args should be 2")
  let arg0_2: handle = @tir.tvm_struct_get(args_2, 0, 12, dtype=handle)
  let arg0.code_2: int32 = (int32*)arg_type_ids_2[0]
  let arg1_2: handle = @tir.tvm_struct_get(args_2, 1, 12, dtype=handle)
  let arg1.code_2: int32 = (int32*)arg_type_ids_2[1]
  let placeholder_2: Pointer(int64) = @tir.tvm_struct_get(arg0_2, 0, 1, dtype=handle)
  attr [placeholder_2] "storage_alignment" = 128;
  let arg0.shape_2: handle = @tir.tvm_struct_get(arg0_2, 0, 2, dtype=handle)
  let arg0.strides_2: handle = @tir.tvm_struct_get(arg0_2, 0, 3, dtype=handle)
  let dev_id_2: int32 = @tir.tvm_struct_get(arg0_2, 0, 9, dtype=int32)
  let compute: Pointer(int64) = @tir.tvm_struct_get(arg1_2, 0, 1, dtype=handle)
  attr [compute] "storage_alignment" = 128;
  let arg1.shape_2: handle = @tir.tvm_struct_get(arg1_2, 0, 2, dtype=handle)
  let arg1.strides_2: handle = @tir.tvm_struct_get(arg1_2, 0, 3, dtype=handle)
  assert(((((arg0.code_2 == 3) || (arg0.code_2 == 13)) || (arg0.code_2 == 7)) || (arg0.code_2 == 4)), "shape_func_nn_softmax_1: Expect arg[0] to be pointer")
  assert(((((arg1.code_2 == 3) || (arg1.code_2 == 13)) || (arg1.code_2 == 7)) || (arg1.code_2 == 4)), "shape_func_nn_softmax_1: Expect arg[1] to be pointer")
  assert((1 == @tir.tvm_struct_get(arg0_2, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((1 == @tir.tvm_struct_get(arg0_2, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((((@tir.tvm_struct_get(arg0_2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0_2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0_2, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((4 == cast(int32, (int64*)arg0.shape_2[0])), "Argument arg0.shape[0] has an unsatisfied constraint: (4 == int32(arg0.shape[0]))")
   {
    if !@tir.isnullptr(arg0.strides_2, dtype=bool) {
      assert((1 == cast(int32, (int64*)arg0.strides_2[0])), "arg0.strides: expected to be compact array")
      0
    }
    assert((0u64 == @tir.tvm_struct_get(arg0_2, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg0_2, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
    assert((1 == @tir.tvm_struct_get(arg1_2, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 1")
    assert((1 == @tir.tvm_struct_get(arg1_2, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 1")
    assert((((@tir.tvm_struct_get(arg1_2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1_2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1_2, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
    assert((4 == cast(int32, (int64*)arg1.shape_2[0])), "Argument arg1.shape[0] has an unsatisfied constraint: (4 == int32(arg1.shape[0]))")
     {
      if !@tir.isnullptr(arg1.strides_2, dtype=bool) {
        assert((1 == cast(int32, (int64*)arg1.strides_2[0])), "arg1.strides: expected to be compact array")
        0
      }
      assert((0u64 == @tir.tvm_struct_get(arg1_2, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
      assert((1 == @tir.tvm_struct_get(arg1_2, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
      assert((dev_id_2 == @tir.tvm_struct_get(arg1_2, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
      attr [0] "compute_scope" = "shape_func_nn_softmax_1_compute_";
      for (i0: int32, 0, 4) {
        compute[i0] = (int64*)placeholder_2[i0]
      }
    }
  }
}

primfn(args_3: handle, arg_type_ids_3: handle, num_args_3: int32, out_ret_value_3: handle, out_ret_tcode_3: handle, resource_handle_3: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_multiply", "calling_conv": 1} {
  assert((num_args_3 == 2), "fused_multiply: num_args should be 2")
  let arg0_3: handle = @tir.tvm_struct_get(args_3, 0, 12, dtype=handle)
  let arg0.code_3: int32 = (int32*)arg_type_ids_3[0]
  let arg1_3: handle = @tir.tvm_struct_get(args_3, 1, 12, dtype=handle)
  let arg1.code_3: int32 = (int32*)arg_type_ids_3[1]
  let placeholder_3: Pointer(int64) = @tir.tvm_struct_get(arg0_3, 0, 1, dtype=handle)
  attr [placeholder_3] "storage_alignment" = 128;
  let arg0.shape_3: handle = @tir.tvm_struct_get(arg0_3, 0, 2, dtype=handle)
  let arg0.strides_3: handle = @tir.tvm_struct_get(arg0_3, 0, 3, dtype=handle)
  let dev_id_3: int32 = @tir.tvm_struct_get(arg0_3, 0, 9, dtype=int32)
  let T_multiply: Pointer(int64) = @tir.tvm_struct_get(arg1_3, 0, 1, dtype=handle)
  attr [T_multiply] "storage_alignment" = 128;
  let arg1.shape_3: handle = @tir.tvm_struct_get(arg1_3, 0, 2, dtype=handle)
  let arg1.strides_3: handle = @tir.tvm_struct_get(arg1_3, 0, 3, dtype=handle)
  assert(((((arg0.code_3 == 3) || (arg0.code_3 == 13)) || (arg0.code_3 == 7)) || (arg0.code_3 == 4)), "fused_multiply: Expect arg[0] to be pointer")
  assert(((((arg1.code_3 == 3) || (arg1.code_3 == 13)) || (arg1.code_3 == 7)) || (arg1.code_3 == 4)), "fused_multiply: Expect arg[1] to be pointer")
  assert((0 == @tir.tvm_struct_get(arg0_3, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0_3, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0_3, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0_3, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0_3, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0_3, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0_3, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1_3, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1_3, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1_3, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1_3, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1_3, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1_3, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1_3, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id_3 == @tir.tvm_struct_get(arg1_3, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  attr [0] "compute_scope" = "fused_multiply_compute_";
  T_multiply[0] = ((int64*)placeholder_3[0]*4i64)
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerCustomDatatypes
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_prod", "calling_conv": 1} {
  assert((num_args == 2), "fused_prod: num_args should be 2")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_red: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_red] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_prod: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_prod: Expect arg[1] to be pointer")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((4 == cast(int32, (int64*)arg0.shape[0])), "Argument arg0.shape[0] has an unsatisfied constraint: (4 == int32(arg0.shape[0]))")
   {
    if !@tir.isnullptr(arg0.strides, dtype=bool) {
      assert((1 == cast(int32, (int64*)arg0.strides[0])), "arg0.strides: expected to be compact array")
      0
    }
    assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
    assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
    assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
    assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
    assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
    assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
    attr [0] "compute_scope" = "fused_prod_compute_" {
      placeholder_red[0] = 1i64
      for (k0: int32, 0, 4) {
        placeholder_red[0] = ((int64*)placeholder_red[0]*(int64*)placeholder[k0])
      }
    }
  }
}

primfn(args_1: handle, arg_type_ids_1: handle, num_args_1: int32, out_ret_value_1: handle, out_ret_tcode_1: handle, resource_handle_1: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_nn_softmax", "calling_conv": 1} {
  assert((num_args_1 == 2), "fused_nn_softmax: num_args should be 2")
  let arg0_1: handle = @tir.tvm_struct_get(args_1, 0, 12, dtype=handle)
  let arg0.code_1: int32 = (int32*)arg_type_ids_1[0]
  let arg1_1: handle = @tir.tvm_struct_get(args_1, 1, 12, dtype=handle)
  let arg1.code_1: int32 = (int32*)arg_type_ids_1[1]
  let placeholder_1: Pointer(float32) = @tir.tvm_struct_get(arg0_1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg0.shape_1: handle = @tir.tvm_struct_get(arg0_1, 0, 2, dtype=handle)
  let d0: int32 = cast(int32, (int64*)arg0.shape_1[0])
  let d1: int32 = cast(int32, (int64*)arg0.shape_1[1])
  let d2: int32 = cast(int32, (int64*)arg0.shape_1[2])
  let d3: int32 = cast(int32, (int64*)arg0.shape_1[3])
  let arg0.strides_1: handle = @tir.tvm_struct_get(arg0_1, 0, 3, dtype=handle)
  let stride: int32 = @tir.if_then_else((d3 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides_1, dtype=bool), 1, cast(int32, (int64*)arg0.strides_1[3]), dtype=int32), dtype=int32)
  let stride_1: int32 = @tir.if_then_else((d2 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides_1, dtype=bool), d3, cast(int32, (int64*)arg0.strides_1[2]), dtype=int32), dtype=int32)
  let stride_2: int32 = @tir.if_then_else((d1 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides_1, dtype=bool), (d3*d2), cast(int32, (int64*)arg0.strides_1[1]), dtype=int32), dtype=int32)
  let stride_3: int32 = @tir.if_then_else((d0 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides_1, dtype=bool), ((d3*d2)*d1), cast(int32, (int64*)arg0.strides_1[0]), dtype=int32), dtype=int32)
  let dev_id_1: int32 = @tir.tvm_struct_get(arg0_1, 0, 9, dtype=int32)
  let T_softmax_norm: Pointer(float32) = @tir.tvm_struct_get(arg1_1, 0, 1, dtype=handle)
  attr [T_softmax_norm] "storage_alignment" = 128;
  let arg1.shape_1: handle = @tir.tvm_struct_get(arg1_1, 0, 2, dtype=handle)
  let arg1.strides_1: handle = @tir.tvm_struct_get(arg1_1, 0, 3, dtype=handle)
  let stride_4: int32 = @tir.if_then_else((d3 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides_1, dtype=bool), 1, cast(int32, (int64*)arg1.strides_1[3]), dtype=int32), dtype=int32)
  let stride_5: int32 = @tir.if_then_else((d2 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides_1, dtype=bool), d3, cast(int32, (int64*)arg1.strides_1[2]), dtype=int32), dtype=int32)
  let stride_6: int32 = @tir.if_then_else((d1 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides_1, dtype=bool), (d3*d2), cast(int32, (int64*)arg1.strides_1[1]), dtype=int32), dtype=int32)
  let stride_7: int32 = @tir.if_then_else((d0 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides_1, dtype=bool), ((d3*d2)*d1), cast(int32, (int64*)arg1.strides_1[0]), dtype=int32), dtype=int32)
  assert(((((arg0.code_1 == 3) || (arg0.code_1 == 13)) || (arg0.code_1 == 7)) || (arg0.code_1 == 4)), "fused_nn_softmax: Expect arg[0] to be pointer")
  assert(((((arg1.code_1 == 3) || (arg1.code_1 == 13)) || (arg1.code_1 == 7)) || (arg1.code_1 == 4)), "fused_nn_softmax: Expect arg[1] to be pointer")
  assert((4 == @tir.tvm_struct_get(arg0_1, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 4")
  assert((4 == @tir.tvm_struct_get(arg0_1, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 4")
  assert((((@tir.tvm_struct_get(arg0_1, 0, 5, dtype=uint8) == 2u8) && (@tir.tvm_struct_get(arg0_1, 0, 6, dtype=uint8) == 32u8)) && (@tir.tvm_struct_get(arg0_1, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be float32")
  assert((0u64 == @tir.tvm_struct_get(arg0_1, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0_1, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((4 == @tir.tvm_struct_get(arg1_1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 4")
  assert((4 == @tir.tvm_struct_get(arg1_1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 4")
  assert((((@tir.tvm_struct_get(arg1_1, 0, 5, dtype=uint8) == 2u8) && (@tir.tvm_struct_get(arg1_1, 0, 6, dtype=uint8) == 32u8)) && (@tir.tvm_struct_get(arg1_1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be float32")
  assert((d0 == cast(int32, (int64*)arg1.shape_1[0])), "Argument arg1.shape[0] has an unsatisfied constraint: (d0 == int32(arg1.shape[0]))")
  assert((d1 == cast(int32, (int64*)arg1.shape_1[1])), "Argument arg1.shape[1] has an unsatisfied constraint: (d1 == int32(arg1.shape[1]))")
  assert((d2 == cast(int32, (int64*)arg1.shape_1[2])), "Argument arg1.shape[2] has an unsatisfied constraint: (d2 == int32(arg1.shape[2]))")
  assert((d3 == cast(int32, (int64*)arg1.shape_1[3])), "Argument arg1.shape[3] has an unsatisfied constraint: (d3 == int32(arg1.shape[3]))")
  assert((0u64 == @tir.tvm_struct_get(arg1_1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1_1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id_1 == @tir.tvm_struct_get(arg1_1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  attr [0] "compute_scope" = "fused_nn_softmax_compute_";
  for (i0.i1.fused.i2.fused: int32, 0, ((d0*d1)*d2)) "parallel" {
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    attr [T_softmax_maxelem] "storage_alignment" = 128 {
      let T_softmax_maxelem = @tir.TVMBackendAllocWorkspace(1, dev_id_1, 4u64, 2, 32, dtype=handle)
       {
        if @tir.isnullptr(T_softmax_maxelem, dtype=bool) {
          @tir.tvm_throw_last_error(, dtype=int32)
        }
        attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
        attr [T_softmax_exp] "storage_alignment" = 128 {
          let T_softmax_exp = @tir.TVMBackendAllocWorkspace(1, dev_id_1, cast(uint64, (4*d3)), 2, 32, dtype=handle)
           {
            if @tir.isnullptr(T_softmax_exp, dtype=bool) {
              @tir.tvm_throw_last_error(, dtype=int32)
            }
            attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
            attr [T_softmax_expsum] "storage_alignment" = 128 {
              let T_softmax_expsum = @tir.TVMBackendAllocWorkspace(1, dev_id_1, 4u64, 2, 32, dtype=handle)
               {
                if @tir.isnullptr(T_softmax_expsum, dtype=bool) {
                  @tir.tvm_throw_last_error(, dtype=int32)
                }
                 {
                  T_softmax_maxelem[0] = -3.40282e+38f32
                  if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                    if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
                      if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                        if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
                          if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                            if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                              for (k: int32, 0, d3) {
                                T_softmax_maxelem[0] = max((float32*)T_softmax_maxelem[0], (float32*)placeholder_1[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_3) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_2)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_1)) + (k*stride))])
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                    if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
                      if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                        if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
                          if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                            if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                              for (i3: int32, 0, d3) {
                                T_softmax_exp[i3] = @tir.exp(((float32*)placeholder_1[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_3) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_2)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_1)) + (i3*stride))] - (float32*)T_softmax_maxelem[0]), dtype=float32)
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  T_softmax_expsum[0] = 0f32
                  if (0 <= floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                    if (floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1) < d0) {
                      if (0 <= floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)) {
                        if (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1) < d1) {
                          if (0 <= floormod(i0.i1.fused.i2.fused, d2)) {
                            if (floormod(i0.i1.fused.i2.fused, d2) < d2) {
                              for (k_1: int32, 0, d3) {
                                T_softmax_expsum[0] = ((float32*)T_softmax_expsum[0] + (float32*)T_softmax_exp[k_1])
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  for (i3_1: int32, 0, d3) {
                    T_softmax_norm[((((floordiv(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_7) + (floormod(floordiv(i0.i1.fused.i2.fused, d2), d1)*stride_6)) + (floormod(i0.i1.fused.i2.fused, d2)*stride_5)) + (i3_1*stride_4))] = ((float32*)T_softmax_exp[i3_1] / (float32*)T_softmax_expsum[0])
                  }
                }
              }
              if (@tir.TVMBackendFreeWorkspace(1, dev_id_1, T_softmax_expsum, dtype=int32) != 0) {
                @tir.tvm_throw_last_error(, dtype=int32)
              }
            }
          }
          if (@tir.TVMBackendFreeWorkspace(1, dev_id_1, T_softmax_exp, dtype=int32) != 0) {
            @tir.tvm_throw_last_error(, dtype=int32)
          }
        }
      }
      if (@tir.TVMBackendFreeWorkspace(1, dev_id_1, T_softmax_maxelem, dtype=int32) != 0) {
        @tir.tvm_throw_last_error(, dtype=int32)
      }
    }
  }
}

primfn(args_2: handle, arg_type_ids_2: handle, num_args_2: int32, out_ret_value_2: handle, out_ret_tcode_2: handle, resource_handle_2: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "shape_func_nn_softmax_1", "calling_conv": 1} {
  assert((num_args_2 == 2), "shape_func_nn_softmax_1: num_args should be 2")
  let arg0_2: handle = @tir.tvm_struct_get(args_2, 0, 12, dtype=handle)
  let arg0.code_2: int32 = (int32*)arg_type_ids_2[0]
  let arg1_2: handle = @tir.tvm_struct_get(args_2, 1, 12, dtype=handle)
  let arg1.code_2: int32 = (int32*)arg_type_ids_2[1]
  let placeholder_2: Pointer(int64) = @tir.tvm_struct_get(arg0_2, 0, 1, dtype=handle)
  attr [placeholder_2] "storage_alignment" = 128;
  let arg0.shape_2: handle = @tir.tvm_struct_get(arg0_2, 0, 2, dtype=handle)
  let arg0.strides_2: handle = @tir.tvm_struct_get(arg0_2, 0, 3, dtype=handle)
  let dev_id_2: int32 = @tir.tvm_struct_get(arg0_2, 0, 9, dtype=int32)
  let compute: Pointer(int64) = @tir.tvm_struct_get(arg1_2, 0, 1, dtype=handle)
  attr [compute] "storage_alignment" = 128;
  let arg1.shape_2: handle = @tir.tvm_struct_get(arg1_2, 0, 2, dtype=handle)
  let arg1.strides_2: handle = @tir.tvm_struct_get(arg1_2, 0, 3, dtype=handle)
  assert(((((arg0.code_2 == 3) || (arg0.code_2 == 13)) || (arg0.code_2 == 7)) || (arg0.code_2 == 4)), "shape_func_nn_softmax_1: Expect arg[0] to be pointer")
  assert(((((arg1.code_2 == 3) || (arg1.code_2 == 13)) || (arg1.code_2 == 7)) || (arg1.code_2 == 4)), "shape_func_nn_softmax_1: Expect arg[1] to be pointer")
  assert((1 == @tir.tvm_struct_get(arg0_2, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((1 == @tir.tvm_struct_get(arg0_2, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((((@tir.tvm_struct_get(arg0_2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0_2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0_2, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((4 == cast(int32, (int64*)arg0.shape_2[0])), "Argument arg0.shape[0] has an unsatisfied constraint: (4 == int32(arg0.shape[0]))")
   {
    if !@tir.isnullptr(arg0.strides_2, dtype=bool) {
      assert((1 == cast(int32, (int64*)arg0.strides_2[0])), "arg0.strides: expected to be compact array")
      0
    }
    assert((0u64 == @tir.tvm_struct_get(arg0_2, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg0_2, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
    assert((1 == @tir.tvm_struct_get(arg1_2, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 1")
    assert((1 == @tir.tvm_struct_get(arg1_2, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 1")
    assert((((@tir.tvm_struct_get(arg1_2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1_2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1_2, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
    assert((4 == cast(int32, (int64*)arg1.shape_2[0])), "Argument arg1.shape[0] has an unsatisfied constraint: (4 == int32(arg1.shape[0]))")
     {
      if !@tir.isnullptr(arg1.strides_2, dtype=bool) {
        assert((1 == cast(int32, (int64*)arg1.strides_2[0])), "arg1.strides: expected to be compact array")
        0
      }
      assert((0u64 == @tir.tvm_struct_get(arg1_2, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
      assert((1 == @tir.tvm_struct_get(arg1_2, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
      assert((dev_id_2 == @tir.tvm_struct_get(arg1_2, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
      attr [0] "compute_scope" = "shape_func_nn_softmax_1_compute_";
      for (i0: int32, 0, 4) {
        compute[i0] = (int64*)placeholder_2[i0]
      }
    }
  }
}

primfn(args_3: handle, arg_type_ids_3: handle, num_args_3: int32, out_ret_value_3: handle, out_ret_tcode_3: handle, resource_handle_3: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_multiply", "calling_conv": 1} {
  assert((num_args_3 == 2), "fused_multiply: num_args should be 2")
  let arg0_3: handle = @tir.tvm_struct_get(args_3, 0, 12, dtype=handle)
  let arg0.code_3: int32 = (int32*)arg_type_ids_3[0]
  let arg1_3: handle = @tir.tvm_struct_get(args_3, 1, 12, dtype=handle)
  let arg1.code_3: int32 = (int32*)arg_type_ids_3[1]
  let placeholder_3: Pointer(int64) = @tir.tvm_struct_get(arg0_3, 0, 1, dtype=handle)
  attr [placeholder_3] "storage_alignment" = 128;
  let arg0.shape_3: handle = @tir.tvm_struct_get(arg0_3, 0, 2, dtype=handle)
  let arg0.strides_3: handle = @tir.tvm_struct_get(arg0_3, 0, 3, dtype=handle)
  let dev_id_3: int32 = @tir.tvm_struct_get(arg0_3, 0, 9, dtype=int32)
  let T_multiply: Pointer(int64) = @tir.tvm_struct_get(arg1_3, 0, 1, dtype=handle)
  attr [T_multiply] "storage_alignment" = 128;
  let arg1.shape_3: handle = @tir.tvm_struct_get(arg1_3, 0, 2, dtype=handle)
  let arg1.strides_3: handle = @tir.tvm_struct_get(arg1_3, 0, 3, dtype=handle)
  assert(((((arg0.code_3 == 3) || (arg0.code_3 == 13)) || (arg0.code_3 == 7)) || (arg0.code_3 == 4)), "fused_multiply: Expect arg[0] to be pointer")
  assert(((((arg1.code_3 == 3) || (arg1.code_3 == 13)) || (arg1.code_3 == 7)) || (arg1.code_3 == 4)), "fused_multiply: Expect arg[1] to be pointer")
  assert((0 == @tir.tvm_struct_get(arg0_3, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0_3, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0_3, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0_3, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0_3, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0_3, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0_3, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1_3, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1_3, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1_3, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1_3, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1_3, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1_3, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1_3, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id_3 == @tir.tvm_struct_get(arg1_3, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  attr [0] "compute_scope" = "fused_multiply_compute_";
  T_multiply[0] = ((int64*)placeholder_3[0]*4i64)
}


[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerIntrin
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_prod", "calling_conv": 1} {
  assert((num_args == 2), "fused_prod: num_args should be 2")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_red: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_red] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_prod: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_prod: Expect arg[1] to be pointer")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((4 == cast(int32, (int64*)arg0.shape[0])), "Argument arg0.shape[0] has an unsatisfied constraint: (4 == int32(arg0.shape[0]))")
   {
    if !@tir.isnullptr(arg0.strides, dtype=bool) {
      assert((1 == cast(int32, (int64*)arg0.strides[0])), "arg0.strides: expected to be compact array")
      0
    }
    assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
    assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
    assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
    assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
    assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
    assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
    attr [0] "compute_scope" = "fused_prod_compute_" {
      placeholder_red[0] = 1i64
      for (k0: int32, 0, 4) {
        placeholder_red[0] = ((int64*)placeholder_red[0]*(int64*)placeholder[k0])
      }
    }
  }
}

primfn(args_1: handle, arg_type_ids_1: handle, num_args_1: int32, out_ret_value_1: handle, out_ret_tcode_1: handle, resource_handle_1: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_nn_softmax", "calling_conv": 1} {
  assert((num_args_1 == 2), "fused_nn_softmax: num_args should be 2")
  let arg0_1: handle = @tir.tvm_struct_get(args_1, 0, 12, dtype=handle)
  let arg0.code_1: int32 = (int32*)arg_type_ids_1[0]
  let arg1_1: handle = @tir.tvm_struct_get(args_1, 1, 12, dtype=handle)
  let arg1.code_1: int32 = (int32*)arg_type_ids_1[1]
  let placeholder_1: Pointer(float32) = @tir.tvm_struct_get(arg0_1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg0.shape_1: handle = @tir.tvm_struct_get(arg0_1, 0, 2, dtype=handle)
  let d0: int32 = cast(int32, (int64*)arg0.shape_1[0])
  let d1: int32 = cast(int32, (int64*)arg0.shape_1[1])
  let d2: int32 = cast(int32, (int64*)arg0.shape_1[2])
  let d3: int32 = cast(int32, (int64*)arg0.shape_1[3])
  let arg0.strides_1: handle = @tir.tvm_struct_get(arg0_1, 0, 3, dtype=handle)
  let stride: int32 = @tir.if_then_else((d3 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides_1, dtype=bool), 1, cast(int32, (int64*)arg0.strides_1[3]), dtype=int32), dtype=int32)
  let stride_1: int32 = @tir.if_then_else((d2 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides_1, dtype=bool), d3, cast(int32, (int64*)arg0.strides_1[2]), dtype=int32), dtype=int32)
  let stride_2: int32 = @tir.if_then_else((d1 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides_1, dtype=bool), (d3*d2), cast(int32, (int64*)arg0.strides_1[1]), dtype=int32), dtype=int32)
  let stride_3: int32 = @tir.if_then_else((d0 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides_1, dtype=bool), ((d3*d2)*d1), cast(int32, (int64*)arg0.strides_1[0]), dtype=int32), dtype=int32)
  let dev_id_1: int32 = @tir.tvm_struct_get(arg0_1, 0, 9, dtype=int32)
  let T_softmax_norm: Pointer(float32) = @tir.tvm_struct_get(arg1_1, 0, 1, dtype=handle)
  attr [T_softmax_norm] "storage_alignment" = 128;
  let arg1.shape_1: handle = @tir.tvm_struct_get(arg1_1, 0, 2, dtype=handle)
  let arg1.strides_1: handle = @tir.tvm_struct_get(arg1_1, 0, 3, dtype=handle)
  let stride_4: int32 = @tir.if_then_else((d3 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides_1, dtype=bool), 1, cast(int32, (int64*)arg1.strides_1[3]), dtype=int32), dtype=int32)
  let stride_5: int32 = @tir.if_then_else((d2 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides_1, dtype=bool), d3, cast(int32, (int64*)arg1.strides_1[2]), dtype=int32), dtype=int32)
  let stride_6: int32 = @tir.if_then_else((d1 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides_1, dtype=bool), (d3*d2), cast(int32, (int64*)arg1.strides_1[1]), dtype=int32), dtype=int32)
  let stride_7: int32 = @tir.if_then_else((d0 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides_1, dtype=bool), ((d3*d2)*d1), cast(int32, (int64*)arg1.strides_1[0]), dtype=int32), dtype=int32)
  assert(((((arg0.code_1 == 3) || (arg0.code_1 == 13)) || (arg0.code_1 == 7)) || (arg0.code_1 == 4)), "fused_nn_softmax: Expect arg[0] to be pointer")
  assert(((((arg1.code_1 == 3) || (arg1.code_1 == 13)) || (arg1.code_1 == 7)) || (arg1.code_1 == 4)), "fused_nn_softmax: Expect arg[1] to be pointer")
  assert((4 == @tir.tvm_struct_get(arg0_1, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 4")
  assert((4 == @tir.tvm_struct_get(arg0_1, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 4")
  assert((((@tir.tvm_struct_get(arg0_1, 0, 5, dtype=uint8) == 2u8) && (@tir.tvm_struct_get(arg0_1, 0, 6, dtype=uint8) == 32u8)) && (@tir.tvm_struct_get(arg0_1, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be float32")
  assert((0u64 == @tir.tvm_struct_get(arg0_1, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0_1, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((4 == @tir.tvm_struct_get(arg1_1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 4")
  assert((4 == @tir.tvm_struct_get(arg1_1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 4")
  assert((((@tir.tvm_struct_get(arg1_1, 0, 5, dtype=uint8) == 2u8) && (@tir.tvm_struct_get(arg1_1, 0, 6, dtype=uint8) == 32u8)) && (@tir.tvm_struct_get(arg1_1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be float32")
  assert((d0 == cast(int32, (int64*)arg1.shape_1[0])), "Argument arg1.shape[0] has an unsatisfied constraint: (d0 == int32(arg1.shape[0]))")
  assert((d1 == cast(int32, (int64*)arg1.shape_1[1])), "Argument arg1.shape[1] has an unsatisfied constraint: (d1 == int32(arg1.shape[1]))")
  assert((d2 == cast(int32, (int64*)arg1.shape_1[2])), "Argument arg1.shape[2] has an unsatisfied constraint: (d2 == int32(arg1.shape[2]))")
  assert((d3 == cast(int32, (int64*)arg1.shape_1[3])), "Argument arg1.shape[3] has an unsatisfied constraint: (d3 == int32(arg1.shape[3]))")
  assert((0u64 == @tir.tvm_struct_get(arg1_1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1_1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id_1 == @tir.tvm_struct_get(arg1_1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  attr [0] "compute_scope" = "fused_nn_softmax_compute_";
  for (i0.i1.fused.i2.fused: int32, 0, ((d0*d1)*d2)) "parallel" {
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    attr [T_softmax_maxelem] "storage_alignment" = 128 {
      let T_softmax_maxelem = @tir.TVMBackendAllocWorkspace(1, dev_id_1, 4u64, 2, 32, dtype=handle)
       {
        if @tir.isnullptr(T_softmax_maxelem, dtype=bool) {
          @tir.tvm_throw_last_error(, dtype=int32)
        }
        attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
        attr [T_softmax_exp] "storage_alignment" = 128 {
          let T_softmax_exp = @tir.TVMBackendAllocWorkspace(1, dev_id_1, cast(uint64, (4*d3)), 2, 32, dtype=handle)
           {
            if @tir.isnullptr(T_softmax_exp, dtype=bool) {
              @tir.tvm_throw_last_error(, dtype=int32)
            }
            attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
            attr [T_softmax_expsum] "storage_alignment" = 128 {
              let T_softmax_expsum = @tir.TVMBackendAllocWorkspace(1, dev_id_1, 4u64, 2, 32, dtype=handle)
               {
                if @tir.isnullptr(T_softmax_expsum, dtype=bool) {
                  @tir.tvm_throw_last_error(, dtype=int32)
                }
                 {
                  T_softmax_maxelem[0] = -3.40282e+38f32
                  if (0 <= let rmod: int32 = (let rmod_1: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_1 >= 0)) || ((d2 < 0) && (rmod_1 <= 0))), rdiv, (rdiv - 1)) % d1) in let rdiv_1: int32 = (let rmod_1 = (i0.i1.fused.i2.fused % d2) in let rdiv = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_1 >= 0)) || ((d2 < 0) && (rmod_1 <= 0))), rdiv, (rdiv - 1)) / d1) in select((((d1 >= 0) && (rmod >= 0)) || ((d1 < 0) && (rmod <= 0))), rdiv_1, (rdiv_1 - 1))) {
                    if (let rmod_2: int32 = (let rmod_3: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_2: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_3 >= 0)) || ((d2 < 0) && (rmod_3 <= 0))), rdiv_2, (rdiv_2 - 1)) % d1) in let rdiv_3: int32 = (let rmod_3 = (i0.i1.fused.i2.fused % d2) in let rdiv_2 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_3 >= 0)) || ((d2 < 0) && (rmod_3 <= 0))), rdiv_2, (rdiv_2 - 1)) / d1) in select((((d1 >= 0) && (rmod_2 >= 0)) || ((d1 < 0) && (rmod_2 <= 0))), rdiv_3, (rdiv_3 - 1)) < d0) {
                      if (0 <= let rmod_4: int32 = (let rmod_5: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_4: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_5 >= 0)) || ((d2 < 0) && (rmod_5 <= 0))), rdiv_4, (rdiv_4 - 1)) % d1) in select((((d1 >= 0) && (rmod_4 >= 0)) || ((d1 < 0) && (rmod_4 <= 0))), rmod_4, (rmod_4 + d1))) {
                        if (let rmod_6: int32 = (let rmod_7: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_5: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_7 >= 0)) || ((d2 < 0) && (rmod_7 <= 0))), rdiv_5, (rdiv_5 - 1)) % d1) in select((((d1 >= 0) && (rmod_6 >= 0)) || ((d1 < 0) && (rmod_6 <= 0))), rmod_6, (rmod_6 + d1)) < d1) {
                          if (0 <= let rmod_8: int32 = (i0.i1.fused.i2.fused % d2) in select((((d2 >= 0) && (rmod_8 >= 0)) || ((d2 < 0) && (rmod_8 <= 0))), rmod_8, (rmod_8 + d2))) {
                            if (let rmod_9: int32 = (i0.i1.fused.i2.fused % d2) in select((((d2 >= 0) && (rmod_9 >= 0)) || ((d2 < 0) && (rmod_9 <= 0))), rmod_9, (rmod_9 + d2)) < d2) {
                              for (k: int32, 0, d3) {
                                T_softmax_maxelem[0] = max((float32*)T_softmax_maxelem[0], (float32*)placeholder_1[((((let rmod_10: int32 = (let rmod_11: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_6: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_11 >= 0)) || ((d2 < 0) && (rmod_11 <= 0))), rdiv_6, (rdiv_6 - 1)) % d1) in let rdiv_7: int32 = (let rmod_11 = (i0.i1.fused.i2.fused % d2) in let rdiv_6 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_11 >= 0)) || ((d2 < 0) && (rmod_11 <= 0))), rdiv_6, (rdiv_6 - 1)) / d1) in select((((d1 >= 0) && (rmod_10 >= 0)) || ((d1 < 0) && (rmod_10 <= 0))), rdiv_7, (rdiv_7 - 1))*stride_3) + (let rmod_12: int32 = (let rmod_13: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_8: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_13 >= 0)) || ((d2 < 0) && (rmod_13 <= 0))), rdiv_8, (rdiv_8 - 1)) % d1) in select((((d1 >= 0) && (rmod_12 >= 0)) || ((d1 < 0) && (rmod_12 <= 0))), rmod_12, (rmod_12 + d1))*stride_2)) + (let rmod_14: int32 = (i0.i1.fused.i2.fused % d2) in select((((d2 >= 0) && (rmod_14 >= 0)) || ((d2 < 0) && (rmod_14 <= 0))), rmod_14, (rmod_14 + d2))*stride_1)) + (k*stride))])
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  if (0 <= let rmod_15: int32 = (let rmod_16: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_9: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_16 >= 0)) || ((d2 < 0) && (rmod_16 <= 0))), rdiv_9, (rdiv_9 - 1)) % d1) in let rdiv_10: int32 = (let rmod_16 = (i0.i1.fused.i2.fused % d2) in let rdiv_9 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_16 >= 0)) || ((d2 < 0) && (rmod_16 <= 0))), rdiv_9, (rdiv_9 - 1)) / d1) in select((((d1 >= 0) && (rmod_15 >= 0)) || ((d1 < 0) && (rmod_15 <= 0))), rdiv_10, (rdiv_10 - 1))) {
                    if (let rmod_17: int32 = (let rmod_18: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_11: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_18 >= 0)) || ((d2 < 0) && (rmod_18 <= 0))), rdiv_11, (rdiv_11 - 1)) % d1) in let rdiv_12: int32 = (let rmod_18 = (i0.i1.fused.i2.fused % d2) in let rdiv_11 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_18 >= 0)) || ((d2 < 0) && (rmod_18 <= 0))), rdiv_11, (rdiv_11 - 1)) / d1) in select((((d1 >= 0) && (rmod_17 >= 0)) || ((d1 < 0) && (rmod_17 <= 0))), rdiv_12, (rdiv_12 - 1)) < d0) {
                      if (0 <= let rmod_19: int32 = (let rmod_20: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_13: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_20 >= 0)) || ((d2 < 0) && (rmod_20 <= 0))), rdiv_13, (rdiv_13 - 1)) % d1) in select((((d1 >= 0) && (rmod_19 >= 0)) || ((d1 < 0) && (rmod_19 <= 0))), rmod_19, (rmod_19 + d1))) {
                        if (let rmod_21: int32 = (let rmod_22: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_14: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_22 >= 0)) || ((d2 < 0) && (rmod_22 <= 0))), rdiv_14, (rdiv_14 - 1)) % d1) in select((((d1 >= 0) && (rmod_21 >= 0)) || ((d1 < 0) && (rmod_21 <= 0))), rmod_21, (rmod_21 + d1)) < d1) {
                          if (0 <= let rmod_23: int32 = (i0.i1.fused.i2.fused % d2) in select((((d2 >= 0) && (rmod_23 >= 0)) || ((d2 < 0) && (rmod_23 <= 0))), rmod_23, (rmod_23 + d2))) {
                            if (let rmod_24: int32 = (i0.i1.fused.i2.fused % d2) in select((((d2 >= 0) && (rmod_24 >= 0)) || ((d2 < 0) && (rmod_24 <= 0))), rmod_24, (rmod_24 + d2)) < d2) {
                              for (i3: int32, 0, d3) {
                                T_softmax_exp[i3] = @tir.call_llvm_pure_intrin(54u32, 1u32, ((float32*)placeholder_1[((((let rmod_25: int32 = (let rmod_26: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_15: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_26 >= 0)) || ((d2 < 0) && (rmod_26 <= 0))), rdiv_15, (rdiv_15 - 1)) % d1) in let rdiv_16: int32 = (let rmod_26 = (i0.i1.fused.i2.fused % d2) in let rdiv_15 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_26 >= 0)) || ((d2 < 0) && (rmod_26 <= 0))), rdiv_15, (rdiv_15 - 1)) / d1) in select((((d1 >= 0) && (rmod_25 >= 0)) || ((d1 < 0) && (rmod_25 <= 0))), rdiv_16, (rdiv_16 - 1))*stride_3) + (let rmod_27: int32 = (let rmod_28: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_17: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_28 >= 0)) || ((d2 < 0) && (rmod_28 <= 0))), rdiv_17, (rdiv_17 - 1)) % d1) in select((((d1 >= 0) && (rmod_27 >= 0)) || ((d1 < 0) && (rmod_27 <= 0))), rmod_27, (rmod_27 + d1))*stride_2)) + (let rmod_29: int32 = (i0.i1.fused.i2.fused % d2) in select((((d2 >= 0) && (rmod_29 >= 0)) || ((d2 < 0) && (rmod_29 <= 0))), rmod_29, (rmod_29 + d2))*stride_1)) + (i3*stride))] - (float32*)T_softmax_maxelem[0]), dtype=float32)
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  T_softmax_expsum[0] = 0f32
                  if (0 <= let rmod_30: int32 = (let rmod_31: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_18: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_31 >= 0)) || ((d2 < 0) && (rmod_31 <= 0))), rdiv_18, (rdiv_18 - 1)) % d1) in let rdiv_19: int32 = (let rmod_31 = (i0.i1.fused.i2.fused % d2) in let rdiv_18 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_31 >= 0)) || ((d2 < 0) && (rmod_31 <= 0))), rdiv_18, (rdiv_18 - 1)) / d1) in select((((d1 >= 0) && (rmod_30 >= 0)) || ((d1 < 0) && (rmod_30 <= 0))), rdiv_19, (rdiv_19 - 1))) {
                    if (let rmod_32: int32 = (let rmod_33: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_20: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_33 >= 0)) || ((d2 < 0) && (rmod_33 <= 0))), rdiv_20, (rdiv_20 - 1)) % d1) in let rdiv_21: int32 = (let rmod_33 = (i0.i1.fused.i2.fused % d2) in let rdiv_20 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_33 >= 0)) || ((d2 < 0) && (rmod_33 <= 0))), rdiv_20, (rdiv_20 - 1)) / d1) in select((((d1 >= 0) && (rmod_32 >= 0)) || ((d1 < 0) && (rmod_32 <= 0))), rdiv_21, (rdiv_21 - 1)) < d0) {
                      if (0 <= let rmod_34: int32 = (let rmod_35: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_22: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_35 >= 0)) || ((d2 < 0) && (rmod_35 <= 0))), rdiv_22, (rdiv_22 - 1)) % d1) in select((((d1 >= 0) && (rmod_34 >= 0)) || ((d1 < 0) && (rmod_34 <= 0))), rmod_34, (rmod_34 + d1))) {
                        if (let rmod_36: int32 = (let rmod_37: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_23: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_37 >= 0)) || ((d2 < 0) && (rmod_37 <= 0))), rdiv_23, (rdiv_23 - 1)) % d1) in select((((d1 >= 0) && (rmod_36 >= 0)) || ((d1 < 0) && (rmod_36 <= 0))), rmod_36, (rmod_36 + d1)) < d1) {
                          if (0 <= let rmod_38: int32 = (i0.i1.fused.i2.fused % d2) in select((((d2 >= 0) && (rmod_38 >= 0)) || ((d2 < 0) && (rmod_38 <= 0))), rmod_38, (rmod_38 + d2))) {
                            if (let rmod_39: int32 = (i0.i1.fused.i2.fused % d2) in select((((d2 >= 0) && (rmod_39 >= 0)) || ((d2 < 0) && (rmod_39 <= 0))), rmod_39, (rmod_39 + d2)) < d2) {
                              for (k_1: int32, 0, d3) {
                                T_softmax_expsum[0] = ((float32*)T_softmax_expsum[0] + (float32*)T_softmax_exp[k_1])
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  for (i3_1: int32, 0, d3) {
                    T_softmax_norm[((((let rmod_40: int32 = (let rmod_41: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_24: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_41 >= 0)) || ((d2 < 0) && (rmod_41 <= 0))), rdiv_24, (rdiv_24 - 1)) % d1) in let rdiv_25: int32 = (let rmod_41 = (i0.i1.fused.i2.fused % d2) in let rdiv_24 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_41 >= 0)) || ((d2 < 0) && (rmod_41 <= 0))), rdiv_24, (rdiv_24 - 1)) / d1) in select((((d1 >= 0) && (rmod_40 >= 0)) || ((d1 < 0) && (rmod_40 <= 0))), rdiv_25, (rdiv_25 - 1))*stride_7) + (let rmod_42: int32 = (let rmod_43: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_26: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_43 >= 0)) || ((d2 < 0) && (rmod_43 <= 0))), rdiv_26, (rdiv_26 - 1)) % d1) in select((((d1 >= 0) && (rmod_42 >= 0)) || ((d1 < 0) && (rmod_42 <= 0))), rmod_42, (rmod_42 + d1))*stride_6)) + (let rmod_44: int32 = (i0.i1.fused.i2.fused % d2) in select((((d2 >= 0) && (rmod_44 >= 0)) || ((d2 < 0) && (rmod_44 <= 0))), rmod_44, (rmod_44 + d2))*stride_5)) + (i3_1*stride_4))] = ((float32*)T_softmax_exp[i3_1] / (float32*)T_softmax_expsum[0])
                  }
                }
              }
              if (@tir.TVMBackendFreeWorkspace(1, dev_id_1, T_softmax_expsum, dtype=int32) != 0) {
                @tir.tvm_throw_last_error(, dtype=int32)
              }
            }
          }
          if (@tir.TVMBackendFreeWorkspace(1, dev_id_1, T_softmax_exp, dtype=int32) != 0) {
            @tir.tvm_throw_last_error(, dtype=int32)
          }
        }
      }
      if (@tir.TVMBackendFreeWorkspace(1, dev_id_1, T_softmax_maxelem, dtype=int32) != 0) {
        @tir.tvm_throw_last_error(, dtype=int32)
      }
    }
  }
}

primfn(args_2: handle, arg_type_ids_2: handle, num_args_2: int32, out_ret_value_2: handle, out_ret_tcode_2: handle, resource_handle_2: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "shape_func_nn_softmax_1", "calling_conv": 1} {
  assert((num_args_2 == 2), "shape_func_nn_softmax_1: num_args should be 2")
  let arg0_2: handle = @tir.tvm_struct_get(args_2, 0, 12, dtype=handle)
  let arg0.code_2: int32 = (int32*)arg_type_ids_2[0]
  let arg1_2: handle = @tir.tvm_struct_get(args_2, 1, 12, dtype=handle)
  let arg1.code_2: int32 = (int32*)arg_type_ids_2[1]
  let placeholder_2: Pointer(int64) = @tir.tvm_struct_get(arg0_2, 0, 1, dtype=handle)
  attr [placeholder_2] "storage_alignment" = 128;
  let arg0.shape_2: handle = @tir.tvm_struct_get(arg0_2, 0, 2, dtype=handle)
  let arg0.strides_2: handle = @tir.tvm_struct_get(arg0_2, 0, 3, dtype=handle)
  let dev_id_2: int32 = @tir.tvm_struct_get(arg0_2, 0, 9, dtype=int32)
  let compute: Pointer(int64) = @tir.tvm_struct_get(arg1_2, 0, 1, dtype=handle)
  attr [compute] "storage_alignment" = 128;
  let arg1.shape_2: handle = @tir.tvm_struct_get(arg1_2, 0, 2, dtype=handle)
  let arg1.strides_2: handle = @tir.tvm_struct_get(arg1_2, 0, 3, dtype=handle)
  assert(((((arg0.code_2 == 3) || (arg0.code_2 == 13)) || (arg0.code_2 == 7)) || (arg0.code_2 == 4)), "shape_func_nn_softmax_1: Expect arg[0] to be pointer")
  assert(((((arg1.code_2 == 3) || (arg1.code_2 == 13)) || (arg1.code_2 == 7)) || (arg1.code_2 == 4)), "shape_func_nn_softmax_1: Expect arg[1] to be pointer")
  assert((1 == @tir.tvm_struct_get(arg0_2, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((1 == @tir.tvm_struct_get(arg0_2, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((((@tir.tvm_struct_get(arg0_2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0_2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0_2, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((4 == cast(int32, (int64*)arg0.shape_2[0])), "Argument arg0.shape[0] has an unsatisfied constraint: (4 == int32(arg0.shape[0]))")
   {
    if !@tir.isnullptr(arg0.strides_2, dtype=bool) {
      assert((1 == cast(int32, (int64*)arg0.strides_2[0])), "arg0.strides: expected to be compact array")
      0
    }
    assert((0u64 == @tir.tvm_struct_get(arg0_2, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg0_2, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
    assert((1 == @tir.tvm_struct_get(arg1_2, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 1")
    assert((1 == @tir.tvm_struct_get(arg1_2, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 1")
    assert((((@tir.tvm_struct_get(arg1_2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1_2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1_2, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
    assert((4 == cast(int32, (int64*)arg1.shape_2[0])), "Argument arg1.shape[0] has an unsatisfied constraint: (4 == int32(arg1.shape[0]))")
     {
      if !@tir.isnullptr(arg1.strides_2, dtype=bool) {
        assert((1 == cast(int32, (int64*)arg1.strides_2[0])), "arg1.strides: expected to be compact array")
        0
      }
      assert((0u64 == @tir.tvm_struct_get(arg1_2, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
      assert((1 == @tir.tvm_struct_get(arg1_2, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
      assert((dev_id_2 == @tir.tvm_struct_get(arg1_2, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
      attr [0] "compute_scope" = "shape_func_nn_softmax_1_compute_";
      for (i0: int32, 0, 4) {
        compute[i0] = (int64*)placeholder_2[i0]
      }
    }
  }
}

primfn(args_3: handle, arg_type_ids_3: handle, num_args_3: int32, out_ret_value_3: handle, out_ret_tcode_3: handle, resource_handle_3: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_multiply", "calling_conv": 1} {
  assert((num_args_3 == 2), "fused_multiply: num_args should be 2")
  let arg0_3: handle = @tir.tvm_struct_get(args_3, 0, 12, dtype=handle)
  let arg0.code_3: int32 = (int32*)arg_type_ids_3[0]
  let arg1_3: handle = @tir.tvm_struct_get(args_3, 1, 12, dtype=handle)
  let arg1.code_3: int32 = (int32*)arg_type_ids_3[1]
  let placeholder_3: Pointer(int64) = @tir.tvm_struct_get(arg0_3, 0, 1, dtype=handle)
  attr [placeholder_3] "storage_alignment" = 128;
  let arg0.shape_3: handle = @tir.tvm_struct_get(arg0_3, 0, 2, dtype=handle)
  let arg0.strides_3: handle = @tir.tvm_struct_get(arg0_3, 0, 3, dtype=handle)
  let dev_id_3: int32 = @tir.tvm_struct_get(arg0_3, 0, 9, dtype=int32)
  let T_multiply: Pointer(int64) = @tir.tvm_struct_get(arg1_3, 0, 1, dtype=handle)
  attr [T_multiply] "storage_alignment" = 128;
  let arg1.shape_3: handle = @tir.tvm_struct_get(arg1_3, 0, 2, dtype=handle)
  let arg1.strides_3: handle = @tir.tvm_struct_get(arg1_3, 0, 3, dtype=handle)
  assert(((((arg0.code_3 == 3) || (arg0.code_3 == 13)) || (arg0.code_3 == 7)) || (arg0.code_3 == 4)), "fused_multiply: Expect arg[0] to be pointer")
  assert(((((arg1.code_3 == 3) || (arg1.code_3 == 13)) || (arg1.code_3 == 7)) || (arg1.code_3 == 4)), "fused_multiply: Expect arg[1] to be pointer")
  assert((0 == @tir.tvm_struct_get(arg0_3, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0_3, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0_3, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0_3, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0_3, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0_3, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0_3, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1_3, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1_3, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1_3, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1_3, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1_3, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1_3, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1_3, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id_3 == @tir.tvm_struct_get(arg1_3, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  attr [0] "compute_scope" = "fused_multiply_compute_";
  T_multiply[0] = ((int64*)placeholder_3[0]*4i64)
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerDeviceStorageAccessInfo
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_prod", "calling_conv": 1} {
  assert((num_args == 2), "fused_prod: num_args should be 2")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_red: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_red] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_prod: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_prod: Expect arg[1] to be pointer")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((4 == cast(int32, (int64*)arg0.shape[0])), "Argument arg0.shape[0] has an unsatisfied constraint: (4 == int32(arg0.shape[0]))")
   {
    if !@tir.isnullptr(arg0.strides, dtype=bool) {
      assert((1 == cast(int32, (int64*)arg0.strides[0])), "arg0.strides: expected to be compact array")
      0
    }
    assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
    assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
    assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
    assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
    assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
    assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
    attr [0] "compute_scope" = "fused_prod_compute_" {
      placeholder_red[0] = 1i64
      for (k0: int32, 0, 4) {
        placeholder_red[0] = ((int64*)placeholder_red[0]*(int64*)placeholder[k0])
      }
    }
  }
}

primfn(args_1: handle, arg_type_ids_1: handle, num_args_1: int32, out_ret_value_1: handle, out_ret_tcode_1: handle, resource_handle_1: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_nn_softmax", "calling_conv": 1} {
  assert((num_args_1 == 2), "fused_nn_softmax: num_args should be 2")
  let arg0_1: handle = @tir.tvm_struct_get(args_1, 0, 12, dtype=handle)
  let arg0.code_1: int32 = (int32*)arg_type_ids_1[0]
  let arg1_1: handle = @tir.tvm_struct_get(args_1, 1, 12, dtype=handle)
  let arg1.code_1: int32 = (int32*)arg_type_ids_1[1]
  let placeholder_1: Pointer(float32) = @tir.tvm_struct_get(arg0_1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg0.shape_1: handle = @tir.tvm_struct_get(arg0_1, 0, 2, dtype=handle)
  let d0: int32 = cast(int32, (int64*)arg0.shape_1[0])
  let d1: int32 = cast(int32, (int64*)arg0.shape_1[1])
  let d2: int32 = cast(int32, (int64*)arg0.shape_1[2])
  let d3: int32 = cast(int32, (int64*)arg0.shape_1[3])
  let arg0.strides_1: handle = @tir.tvm_struct_get(arg0_1, 0, 3, dtype=handle)
  let stride: int32 = @tir.if_then_else((d3 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides_1, dtype=bool), 1, cast(int32, (int64*)arg0.strides_1[3]), dtype=int32), dtype=int32)
  let stride_1: int32 = @tir.if_then_else((d2 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides_1, dtype=bool), d3, cast(int32, (int64*)arg0.strides_1[2]), dtype=int32), dtype=int32)
  let stride_2: int32 = @tir.if_then_else((d1 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides_1, dtype=bool), (d3*d2), cast(int32, (int64*)arg0.strides_1[1]), dtype=int32), dtype=int32)
  let stride_3: int32 = @tir.if_then_else((d0 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides_1, dtype=bool), ((d3*d2)*d1), cast(int32, (int64*)arg0.strides_1[0]), dtype=int32), dtype=int32)
  let dev_id_1: int32 = @tir.tvm_struct_get(arg0_1, 0, 9, dtype=int32)
  let T_softmax_norm: Pointer(float32) = @tir.tvm_struct_get(arg1_1, 0, 1, dtype=handle)
  attr [T_softmax_norm] "storage_alignment" = 128;
  let arg1.shape_1: handle = @tir.tvm_struct_get(arg1_1, 0, 2, dtype=handle)
  let arg1.strides_1: handle = @tir.tvm_struct_get(arg1_1, 0, 3, dtype=handle)
  let stride_4: int32 = @tir.if_then_else((d3 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides_1, dtype=bool), 1, cast(int32, (int64*)arg1.strides_1[3]), dtype=int32), dtype=int32)
  let stride_5: int32 = @tir.if_then_else((d2 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides_1, dtype=bool), d3, cast(int32, (int64*)arg1.strides_1[2]), dtype=int32), dtype=int32)
  let stride_6: int32 = @tir.if_then_else((d1 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides_1, dtype=bool), (d3*d2), cast(int32, (int64*)arg1.strides_1[1]), dtype=int32), dtype=int32)
  let stride_7: int32 = @tir.if_then_else((d0 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides_1, dtype=bool), ((d3*d2)*d1), cast(int32, (int64*)arg1.strides_1[0]), dtype=int32), dtype=int32)
  assert(((((arg0.code_1 == 3) || (arg0.code_1 == 13)) || (arg0.code_1 == 7)) || (arg0.code_1 == 4)), "fused_nn_softmax: Expect arg[0] to be pointer")
  assert(((((arg1.code_1 == 3) || (arg1.code_1 == 13)) || (arg1.code_1 == 7)) || (arg1.code_1 == 4)), "fused_nn_softmax: Expect arg[1] to be pointer")
  assert((4 == @tir.tvm_struct_get(arg0_1, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 4")
  assert((4 == @tir.tvm_struct_get(arg0_1, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 4")
  assert((((@tir.tvm_struct_get(arg0_1, 0, 5, dtype=uint8) == 2u8) && (@tir.tvm_struct_get(arg0_1, 0, 6, dtype=uint8) == 32u8)) && (@tir.tvm_struct_get(arg0_1, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be float32")
  assert((0u64 == @tir.tvm_struct_get(arg0_1, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0_1, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((4 == @tir.tvm_struct_get(arg1_1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 4")
  assert((4 == @tir.tvm_struct_get(arg1_1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 4")
  assert((((@tir.tvm_struct_get(arg1_1, 0, 5, dtype=uint8) == 2u8) && (@tir.tvm_struct_get(arg1_1, 0, 6, dtype=uint8) == 32u8)) && (@tir.tvm_struct_get(arg1_1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be float32")
  assert((d0 == cast(int32, (int64*)arg1.shape_1[0])), "Argument arg1.shape[0] has an unsatisfied constraint: (d0 == int32(arg1.shape[0]))")
  assert((d1 == cast(int32, (int64*)arg1.shape_1[1])), "Argument arg1.shape[1] has an unsatisfied constraint: (d1 == int32(arg1.shape[1]))")
  assert((d2 == cast(int32, (int64*)arg1.shape_1[2])), "Argument arg1.shape[2] has an unsatisfied constraint: (d2 == int32(arg1.shape[2]))")
  assert((d3 == cast(int32, (int64*)arg1.shape_1[3])), "Argument arg1.shape[3] has an unsatisfied constraint: (d3 == int32(arg1.shape[3]))")
  assert((0u64 == @tir.tvm_struct_get(arg1_1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1_1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id_1 == @tir.tvm_struct_get(arg1_1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  attr [0] "compute_scope" = "fused_nn_softmax_compute_";
  for (i0.i1.fused.i2.fused: int32, 0, ((d0*d1)*d2)) "parallel" {
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    attr [T_softmax_maxelem] "storage_alignment" = 128 {
      let T_softmax_maxelem = @tir.TVMBackendAllocWorkspace(1, dev_id_1, 4u64, 2, 32, dtype=handle)
       {
        if @tir.isnullptr(T_softmax_maxelem, dtype=bool) {
          @tir.tvm_throw_last_error(, dtype=int32)
        }
        attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
        attr [T_softmax_exp] "storage_alignment" = 128 {
          let T_softmax_exp = @tir.TVMBackendAllocWorkspace(1, dev_id_1, cast(uint64, (4*d3)), 2, 32, dtype=handle)
           {
            if @tir.isnullptr(T_softmax_exp, dtype=bool) {
              @tir.tvm_throw_last_error(, dtype=int32)
            }
            attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
            attr [T_softmax_expsum] "storage_alignment" = 128 {
              let T_softmax_expsum = @tir.TVMBackendAllocWorkspace(1, dev_id_1, 4u64, 2, 32, dtype=handle)
               {
                if @tir.isnullptr(T_softmax_expsum, dtype=bool) {
                  @tir.tvm_throw_last_error(, dtype=int32)
                }
                 {
                  T_softmax_maxelem[0] = -3.40282e+38f32
                  if (0 <= let rmod: int32 = (let rmod_1: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_1 >= 0)) || ((d2 < 0) && (rmod_1 <= 0))), rdiv, (rdiv - 1)) % d1) in let rdiv_1: int32 = (let rmod_1 = (i0.i1.fused.i2.fused % d2) in let rdiv = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_1 >= 0)) || ((d2 < 0) && (rmod_1 <= 0))), rdiv, (rdiv - 1)) / d1) in select((((d1 >= 0) && (rmod >= 0)) || ((d1 < 0) && (rmod <= 0))), rdiv_1, (rdiv_1 - 1))) {
                    if (let rmod_2: int32 = (let rmod_3: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_2: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_3 >= 0)) || ((d2 < 0) && (rmod_3 <= 0))), rdiv_2, (rdiv_2 - 1)) % d1) in let rdiv_3: int32 = (let rmod_3 = (i0.i1.fused.i2.fused % d2) in let rdiv_2 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_3 >= 0)) || ((d2 < 0) && (rmod_3 <= 0))), rdiv_2, (rdiv_2 - 1)) / d1) in select((((d1 >= 0) && (rmod_2 >= 0)) || ((d1 < 0) && (rmod_2 <= 0))), rdiv_3, (rdiv_3 - 1)) < d0) {
                      if (0 <= let rmod_4: int32 = (let rmod_5: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_4: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_5 >= 0)) || ((d2 < 0) && (rmod_5 <= 0))), rdiv_4, (rdiv_4 - 1)) % d1) in select((((d1 >= 0) && (rmod_4 >= 0)) || ((d1 < 0) && (rmod_4 <= 0))), rmod_4, (rmod_4 + d1))) {
                        if (let rmod_6: int32 = (let rmod_7: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_5: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_7 >= 0)) || ((d2 < 0) && (rmod_7 <= 0))), rdiv_5, (rdiv_5 - 1)) % d1) in select((((d1 >= 0) && (rmod_6 >= 0)) || ((d1 < 0) && (rmod_6 <= 0))), rmod_6, (rmod_6 + d1)) < d1) {
                          if (0 <= let rmod_8: int32 = (i0.i1.fused.i2.fused % d2) in select((((d2 >= 0) && (rmod_8 >= 0)) || ((d2 < 0) && (rmod_8 <= 0))), rmod_8, (rmod_8 + d2))) {
                            if (let rmod_9: int32 = (i0.i1.fused.i2.fused % d2) in select((((d2 >= 0) && (rmod_9 >= 0)) || ((d2 < 0) && (rmod_9 <= 0))), rmod_9, (rmod_9 + d2)) < d2) {
                              for (k: int32, 0, d3) {
                                T_softmax_maxelem[0] = max((float32*)T_softmax_maxelem[0], (float32*)placeholder_1[((((let rmod_10: int32 = (let rmod_11: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_6: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_11 >= 0)) || ((d2 < 0) && (rmod_11 <= 0))), rdiv_6, (rdiv_6 - 1)) % d1) in let rdiv_7: int32 = (let rmod_11 = (i0.i1.fused.i2.fused % d2) in let rdiv_6 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_11 >= 0)) || ((d2 < 0) && (rmod_11 <= 0))), rdiv_6, (rdiv_6 - 1)) / d1) in select((((d1 >= 0) && (rmod_10 >= 0)) || ((d1 < 0) && (rmod_10 <= 0))), rdiv_7, (rdiv_7 - 1))*stride_3) + (let rmod_12: int32 = (let rmod_13: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_8: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_13 >= 0)) || ((d2 < 0) && (rmod_13 <= 0))), rdiv_8, (rdiv_8 - 1)) % d1) in select((((d1 >= 0) && (rmod_12 >= 0)) || ((d1 < 0) && (rmod_12 <= 0))), rmod_12, (rmod_12 + d1))*stride_2)) + (let rmod_14: int32 = (i0.i1.fused.i2.fused % d2) in select((((d2 >= 0) && (rmod_14 >= 0)) || ((d2 < 0) && (rmod_14 <= 0))), rmod_14, (rmod_14 + d2))*stride_1)) + (k*stride))])
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  if (0 <= let rmod_15: int32 = (let rmod_16: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_9: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_16 >= 0)) || ((d2 < 0) && (rmod_16 <= 0))), rdiv_9, (rdiv_9 - 1)) % d1) in let rdiv_10: int32 = (let rmod_16 = (i0.i1.fused.i2.fused % d2) in let rdiv_9 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_16 >= 0)) || ((d2 < 0) && (rmod_16 <= 0))), rdiv_9, (rdiv_9 - 1)) / d1) in select((((d1 >= 0) && (rmod_15 >= 0)) || ((d1 < 0) && (rmod_15 <= 0))), rdiv_10, (rdiv_10 - 1))) {
                    if (let rmod_17: int32 = (let rmod_18: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_11: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_18 >= 0)) || ((d2 < 0) && (rmod_18 <= 0))), rdiv_11, (rdiv_11 - 1)) % d1) in let rdiv_12: int32 = (let rmod_18 = (i0.i1.fused.i2.fused % d2) in let rdiv_11 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_18 >= 0)) || ((d2 < 0) && (rmod_18 <= 0))), rdiv_11, (rdiv_11 - 1)) / d1) in select((((d1 >= 0) && (rmod_17 >= 0)) || ((d1 < 0) && (rmod_17 <= 0))), rdiv_12, (rdiv_12 - 1)) < d0) {
                      if (0 <= let rmod_19: int32 = (let rmod_20: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_13: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_20 >= 0)) || ((d2 < 0) && (rmod_20 <= 0))), rdiv_13, (rdiv_13 - 1)) % d1) in select((((d1 >= 0) && (rmod_19 >= 0)) || ((d1 < 0) && (rmod_19 <= 0))), rmod_19, (rmod_19 + d1))) {
                        if (let rmod_21: int32 = (let rmod_22: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_14: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_22 >= 0)) || ((d2 < 0) && (rmod_22 <= 0))), rdiv_14, (rdiv_14 - 1)) % d1) in select((((d1 >= 0) && (rmod_21 >= 0)) || ((d1 < 0) && (rmod_21 <= 0))), rmod_21, (rmod_21 + d1)) < d1) {
                          if (0 <= let rmod_23: int32 = (i0.i1.fused.i2.fused % d2) in select((((d2 >= 0) && (rmod_23 >= 0)) || ((d2 < 0) && (rmod_23 <= 0))), rmod_23, (rmod_23 + d2))) {
                            if (let rmod_24: int32 = (i0.i1.fused.i2.fused % d2) in select((((d2 >= 0) && (rmod_24 >= 0)) || ((d2 < 0) && (rmod_24 <= 0))), rmod_24, (rmod_24 + d2)) < d2) {
                              for (i3: int32, 0, d3) {
                                T_softmax_exp[i3] = @tir.call_llvm_pure_intrin(54u32, 1u32, ((float32*)placeholder_1[((((let rmod_25: int32 = (let rmod_26: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_15: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_26 >= 0)) || ((d2 < 0) && (rmod_26 <= 0))), rdiv_15, (rdiv_15 - 1)) % d1) in let rdiv_16: int32 = (let rmod_26 = (i0.i1.fused.i2.fused % d2) in let rdiv_15 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_26 >= 0)) || ((d2 < 0) && (rmod_26 <= 0))), rdiv_15, (rdiv_15 - 1)) / d1) in select((((d1 >= 0) && (rmod_25 >= 0)) || ((d1 < 0) && (rmod_25 <= 0))), rdiv_16, (rdiv_16 - 1))*stride_3) + (let rmod_27: int32 = (let rmod_28: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_17: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_28 >= 0)) || ((d2 < 0) && (rmod_28 <= 0))), rdiv_17, (rdiv_17 - 1)) % d1) in select((((d1 >= 0) && (rmod_27 >= 0)) || ((d1 < 0) && (rmod_27 <= 0))), rmod_27, (rmod_27 + d1))*stride_2)) + (let rmod_29: int32 = (i0.i1.fused.i2.fused % d2) in select((((d2 >= 0) && (rmod_29 >= 0)) || ((d2 < 0) && (rmod_29 <= 0))), rmod_29, (rmod_29 + d2))*stride_1)) + (i3*stride))] - (float32*)T_softmax_maxelem[0]), dtype=float32)
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  T_softmax_expsum[0] = 0f32
                  if (0 <= let rmod_30: int32 = (let rmod_31: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_18: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_31 >= 0)) || ((d2 < 0) && (rmod_31 <= 0))), rdiv_18, (rdiv_18 - 1)) % d1) in let rdiv_19: int32 = (let rmod_31 = (i0.i1.fused.i2.fused % d2) in let rdiv_18 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_31 >= 0)) || ((d2 < 0) && (rmod_31 <= 0))), rdiv_18, (rdiv_18 - 1)) / d1) in select((((d1 >= 0) && (rmod_30 >= 0)) || ((d1 < 0) && (rmod_30 <= 0))), rdiv_19, (rdiv_19 - 1))) {
                    if (let rmod_32: int32 = (let rmod_33: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_20: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_33 >= 0)) || ((d2 < 0) && (rmod_33 <= 0))), rdiv_20, (rdiv_20 - 1)) % d1) in let rdiv_21: int32 = (let rmod_33 = (i0.i1.fused.i2.fused % d2) in let rdiv_20 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_33 >= 0)) || ((d2 < 0) && (rmod_33 <= 0))), rdiv_20, (rdiv_20 - 1)) / d1) in select((((d1 >= 0) && (rmod_32 >= 0)) || ((d1 < 0) && (rmod_32 <= 0))), rdiv_21, (rdiv_21 - 1)) < d0) {
                      if (0 <= let rmod_34: int32 = (let rmod_35: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_22: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_35 >= 0)) || ((d2 < 0) && (rmod_35 <= 0))), rdiv_22, (rdiv_22 - 1)) % d1) in select((((d1 >= 0) && (rmod_34 >= 0)) || ((d1 < 0) && (rmod_34 <= 0))), rmod_34, (rmod_34 + d1))) {
                        if (let rmod_36: int32 = (let rmod_37: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_23: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_37 >= 0)) || ((d2 < 0) && (rmod_37 <= 0))), rdiv_23, (rdiv_23 - 1)) % d1) in select((((d1 >= 0) && (rmod_36 >= 0)) || ((d1 < 0) && (rmod_36 <= 0))), rmod_36, (rmod_36 + d1)) < d1) {
                          if (0 <= let rmod_38: int32 = (i0.i1.fused.i2.fused % d2) in select((((d2 >= 0) && (rmod_38 >= 0)) || ((d2 < 0) && (rmod_38 <= 0))), rmod_38, (rmod_38 + d2))) {
                            if (let rmod_39: int32 = (i0.i1.fused.i2.fused % d2) in select((((d2 >= 0) && (rmod_39 >= 0)) || ((d2 < 0) && (rmod_39 <= 0))), rmod_39, (rmod_39 + d2)) < d2) {
                              for (k_1: int32, 0, d3) {
                                T_softmax_expsum[0] = ((float32*)T_softmax_expsum[0] + (float32*)T_softmax_exp[k_1])
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  for (i3_1: int32, 0, d3) {
                    T_softmax_norm[((((let rmod_40: int32 = (let rmod_41: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_24: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_41 >= 0)) || ((d2 < 0) && (rmod_41 <= 0))), rdiv_24, (rdiv_24 - 1)) % d1) in let rdiv_25: int32 = (let rmod_41 = (i0.i1.fused.i2.fused % d2) in let rdiv_24 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_41 >= 0)) || ((d2 < 0) && (rmod_41 <= 0))), rdiv_24, (rdiv_24 - 1)) / d1) in select((((d1 >= 0) && (rmod_40 >= 0)) || ((d1 < 0) && (rmod_40 <= 0))), rdiv_25, (rdiv_25 - 1))*stride_7) + (let rmod_42: int32 = (let rmod_43: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_26: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_43 >= 0)) || ((d2 < 0) && (rmod_43 <= 0))), rdiv_26, (rdiv_26 - 1)) % d1) in select((((d1 >= 0) && (rmod_42 >= 0)) || ((d1 < 0) && (rmod_42 <= 0))), rmod_42, (rmod_42 + d1))*stride_6)) + (let rmod_44: int32 = (i0.i1.fused.i2.fused % d2) in select((((d2 >= 0) && (rmod_44 >= 0)) || ((d2 < 0) && (rmod_44 <= 0))), rmod_44, (rmod_44 + d2))*stride_5)) + (i3_1*stride_4))] = ((float32*)T_softmax_exp[i3_1] / (float32*)T_softmax_expsum[0])
                  }
                }
              }
              if (@tir.TVMBackendFreeWorkspace(1, dev_id_1, T_softmax_expsum, dtype=int32) != 0) {
                @tir.tvm_throw_last_error(, dtype=int32)
              }
            }
          }
          if (@tir.TVMBackendFreeWorkspace(1, dev_id_1, T_softmax_exp, dtype=int32) != 0) {
            @tir.tvm_throw_last_error(, dtype=int32)
          }
        }
      }
      if (@tir.TVMBackendFreeWorkspace(1, dev_id_1, T_softmax_maxelem, dtype=int32) != 0) {
        @tir.tvm_throw_last_error(, dtype=int32)
      }
    }
  }
}

primfn(args_2: handle, arg_type_ids_2: handle, num_args_2: int32, out_ret_value_2: handle, out_ret_tcode_2: handle, resource_handle_2: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "shape_func_nn_softmax_1", "calling_conv": 1} {
  assert((num_args_2 == 2), "shape_func_nn_softmax_1: num_args should be 2")
  let arg0_2: handle = @tir.tvm_struct_get(args_2, 0, 12, dtype=handle)
  let arg0.code_2: int32 = (int32*)arg_type_ids_2[0]
  let arg1_2: handle = @tir.tvm_struct_get(args_2, 1, 12, dtype=handle)
  let arg1.code_2: int32 = (int32*)arg_type_ids_2[1]
  let placeholder_2: Pointer(int64) = @tir.tvm_struct_get(arg0_2, 0, 1, dtype=handle)
  attr [placeholder_2] "storage_alignment" = 128;
  let arg0.shape_2: handle = @tir.tvm_struct_get(arg0_2, 0, 2, dtype=handle)
  let arg0.strides_2: handle = @tir.tvm_struct_get(arg0_2, 0, 3, dtype=handle)
  let dev_id_2: int32 = @tir.tvm_struct_get(arg0_2, 0, 9, dtype=int32)
  let compute: Pointer(int64) = @tir.tvm_struct_get(arg1_2, 0, 1, dtype=handle)
  attr [compute] "storage_alignment" = 128;
  let arg1.shape_2: handle = @tir.tvm_struct_get(arg1_2, 0, 2, dtype=handle)
  let arg1.strides_2: handle = @tir.tvm_struct_get(arg1_2, 0, 3, dtype=handle)
  assert(((((arg0.code_2 == 3) || (arg0.code_2 == 13)) || (arg0.code_2 == 7)) || (arg0.code_2 == 4)), "shape_func_nn_softmax_1: Expect arg[0] to be pointer")
  assert(((((arg1.code_2 == 3) || (arg1.code_2 == 13)) || (arg1.code_2 == 7)) || (arg1.code_2 == 4)), "shape_func_nn_softmax_1: Expect arg[1] to be pointer")
  assert((1 == @tir.tvm_struct_get(arg0_2, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((1 == @tir.tvm_struct_get(arg0_2, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((((@tir.tvm_struct_get(arg0_2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0_2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0_2, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((4 == cast(int32, (int64*)arg0.shape_2[0])), "Argument arg0.shape[0] has an unsatisfied constraint: (4 == int32(arg0.shape[0]))")
   {
    if !@tir.isnullptr(arg0.strides_2, dtype=bool) {
      assert((1 == cast(int32, (int64*)arg0.strides_2[0])), "arg0.strides: expected to be compact array")
      0
    }
    assert((0u64 == @tir.tvm_struct_get(arg0_2, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg0_2, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
    assert((1 == @tir.tvm_struct_get(arg1_2, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 1")
    assert((1 == @tir.tvm_struct_get(arg1_2, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 1")
    assert((((@tir.tvm_struct_get(arg1_2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1_2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1_2, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
    assert((4 == cast(int32, (int64*)arg1.shape_2[0])), "Argument arg1.shape[0] has an unsatisfied constraint: (4 == int32(arg1.shape[0]))")
     {
      if !@tir.isnullptr(arg1.strides_2, dtype=bool) {
        assert((1 == cast(int32, (int64*)arg1.strides_2[0])), "arg1.strides: expected to be compact array")
        0
      }
      assert((0u64 == @tir.tvm_struct_get(arg1_2, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
      assert((1 == @tir.tvm_struct_get(arg1_2, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
      assert((dev_id_2 == @tir.tvm_struct_get(arg1_2, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
      attr [0] "compute_scope" = "shape_func_nn_softmax_1_compute_";
      for (i0: int32, 0, 4) {
        compute[i0] = (int64*)placeholder_2[i0]
      }
    }
  }
}

primfn(args_3: handle, arg_type_ids_3: handle, num_args_3: int32, out_ret_value_3: handle, out_ret_tcode_3: handle, resource_handle_3: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_multiply", "calling_conv": 1} {
  assert((num_args_3 == 2), "fused_multiply: num_args should be 2")
  let arg0_3: handle = @tir.tvm_struct_get(args_3, 0, 12, dtype=handle)
  let arg0.code_3: int32 = (int32*)arg_type_ids_3[0]
  let arg1_3: handle = @tir.tvm_struct_get(args_3, 1, 12, dtype=handle)
  let arg1.code_3: int32 = (int32*)arg_type_ids_3[1]
  let placeholder_3: Pointer(int64) = @tir.tvm_struct_get(arg0_3, 0, 1, dtype=handle)
  attr [placeholder_3] "storage_alignment" = 128;
  let arg0.shape_3: handle = @tir.tvm_struct_get(arg0_3, 0, 2, dtype=handle)
  let arg0.strides_3: handle = @tir.tvm_struct_get(arg0_3, 0, 3, dtype=handle)
  let dev_id_3: int32 = @tir.tvm_struct_get(arg0_3, 0, 9, dtype=int32)
  let T_multiply: Pointer(int64) = @tir.tvm_struct_get(arg1_3, 0, 1, dtype=handle)
  attr [T_multiply] "storage_alignment" = 128;
  let arg1.shape_3: handle = @tir.tvm_struct_get(arg1_3, 0, 2, dtype=handle)
  let arg1.strides_3: handle = @tir.tvm_struct_get(arg1_3, 0, 3, dtype=handle)
  assert(((((arg0.code_3 == 3) || (arg0.code_3 == 13)) || (arg0.code_3 == 7)) || (arg0.code_3 == 4)), "fused_multiply: Expect arg[0] to be pointer")
  assert(((((arg1.code_3 == 3) || (arg1.code_3 == 13)) || (arg1.code_3 == 7)) || (arg1.code_3 == 4)), "fused_multiply: Expect arg[1] to be pointer")
  assert((0 == @tir.tvm_struct_get(arg0_3, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0_3, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0_3, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0_3, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0_3, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0_3, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0_3, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1_3, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1_3, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1_3, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1_3, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1_3, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1_3, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1_3, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id_3 == @tir.tvm_struct_get(arg1_3, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  attr [0] "compute_scope" = "fused_multiply_compute_";
  T_multiply[0] = ((int64*)placeholder_3[0]*4i64)
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.CombineContextCall
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_prod", "calling_conv": 1} {
  assert((num_args == 2), "fused_prod: num_args should be 2")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_red: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_red] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_prod: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_prod: Expect arg[1] to be pointer")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((4 == cast(int32, (int64*)arg0.shape[0])), "Argument arg0.shape[0] has an unsatisfied constraint: (4 == int32(arg0.shape[0]))")
   {
    if !@tir.isnullptr(arg0.strides, dtype=bool) {
      assert((1 == cast(int32, (int64*)arg0.strides[0])), "arg0.strides: expected to be compact array")
      0
    }
    assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
    assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
    assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
    assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
    assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
    assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
    attr [0] "compute_scope" = "fused_prod_compute_" {
      placeholder_red[0] = 1i64
      for (k0: int32, 0, 4) {
        placeholder_red[0] = ((int64*)placeholder_red[0]*(int64*)placeholder[k0])
      }
    }
  }
}

primfn(args_1: handle, arg_type_ids_1: handle, num_args_1: int32, out_ret_value_1: handle, out_ret_tcode_1: handle, resource_handle_1: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_nn_softmax", "calling_conv": 1} {
  assert((num_args_1 == 2), "fused_nn_softmax: num_args should be 2")
  let arg0_1: handle = @tir.tvm_struct_get(args_1, 0, 12, dtype=handle)
  let arg0.code_1: int32 = (int32*)arg_type_ids_1[0]
  let arg1_1: handle = @tir.tvm_struct_get(args_1, 1, 12, dtype=handle)
  let arg1.code_1: int32 = (int32*)arg_type_ids_1[1]
  let placeholder_1: Pointer(float32) = @tir.tvm_struct_get(arg0_1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg0.shape_1: handle = @tir.tvm_struct_get(arg0_1, 0, 2, dtype=handle)
  let d0: int32 = cast(int32, (int64*)arg0.shape_1[0])
  let d1: int32 = cast(int32, (int64*)arg0.shape_1[1])
  let d2: int32 = cast(int32, (int64*)arg0.shape_1[2])
  let d3: int32 = cast(int32, (int64*)arg0.shape_1[3])
  let arg0.strides_1: handle = @tir.tvm_struct_get(arg0_1, 0, 3, dtype=handle)
  let stride: int32 = @tir.if_then_else((d3 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides_1, dtype=bool), 1, cast(int32, (int64*)arg0.strides_1[3]), dtype=int32), dtype=int32)
  let stride_1: int32 = @tir.if_then_else((d2 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides_1, dtype=bool), d3, cast(int32, (int64*)arg0.strides_1[2]), dtype=int32), dtype=int32)
  let stride_2: int32 = @tir.if_then_else((d1 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides_1, dtype=bool), (d3*d2), cast(int32, (int64*)arg0.strides_1[1]), dtype=int32), dtype=int32)
  let stride_3: int32 = @tir.if_then_else((d0 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides_1, dtype=bool), ((d3*d2)*d1), cast(int32, (int64*)arg0.strides_1[0]), dtype=int32), dtype=int32)
  let dev_id_1: int32 = @tir.tvm_struct_get(arg0_1, 0, 9, dtype=int32)
  let T_softmax_norm: Pointer(float32) = @tir.tvm_struct_get(arg1_1, 0, 1, dtype=handle)
  attr [T_softmax_norm] "storage_alignment" = 128;
  let arg1.shape_1: handle = @tir.tvm_struct_get(arg1_1, 0, 2, dtype=handle)
  let arg1.strides_1: handle = @tir.tvm_struct_get(arg1_1, 0, 3, dtype=handle)
  let stride_4: int32 = @tir.if_then_else((d3 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides_1, dtype=bool), 1, cast(int32, (int64*)arg1.strides_1[3]), dtype=int32), dtype=int32)
  let stride_5: int32 = @tir.if_then_else((d2 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides_1, dtype=bool), d3, cast(int32, (int64*)arg1.strides_1[2]), dtype=int32), dtype=int32)
  let stride_6: int32 = @tir.if_then_else((d1 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides_1, dtype=bool), (d3*d2), cast(int32, (int64*)arg1.strides_1[1]), dtype=int32), dtype=int32)
  let stride_7: int32 = @tir.if_then_else((d0 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides_1, dtype=bool), ((d3*d2)*d1), cast(int32, (int64*)arg1.strides_1[0]), dtype=int32), dtype=int32)
  assert(((((arg0.code_1 == 3) || (arg0.code_1 == 13)) || (arg0.code_1 == 7)) || (arg0.code_1 == 4)), "fused_nn_softmax: Expect arg[0] to be pointer")
  assert(((((arg1.code_1 == 3) || (arg1.code_1 == 13)) || (arg1.code_1 == 7)) || (arg1.code_1 == 4)), "fused_nn_softmax: Expect arg[1] to be pointer")
  assert((4 == @tir.tvm_struct_get(arg0_1, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 4")
  assert((4 == @tir.tvm_struct_get(arg0_1, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 4")
  assert((((@tir.tvm_struct_get(arg0_1, 0, 5, dtype=uint8) == 2u8) && (@tir.tvm_struct_get(arg0_1, 0, 6, dtype=uint8) == 32u8)) && (@tir.tvm_struct_get(arg0_1, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be float32")
  assert((0u64 == @tir.tvm_struct_get(arg0_1, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0_1, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((4 == @tir.tvm_struct_get(arg1_1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 4")
  assert((4 == @tir.tvm_struct_get(arg1_1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 4")
  assert((((@tir.tvm_struct_get(arg1_1, 0, 5, dtype=uint8) == 2u8) && (@tir.tvm_struct_get(arg1_1, 0, 6, dtype=uint8) == 32u8)) && (@tir.tvm_struct_get(arg1_1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be float32")
  assert((d0 == cast(int32, (int64*)arg1.shape_1[0])), "Argument arg1.shape[0] has an unsatisfied constraint: (d0 == int32(arg1.shape[0]))")
  assert((d1 == cast(int32, (int64*)arg1.shape_1[1])), "Argument arg1.shape[1] has an unsatisfied constraint: (d1 == int32(arg1.shape[1]))")
  assert((d2 == cast(int32, (int64*)arg1.shape_1[2])), "Argument arg1.shape[2] has an unsatisfied constraint: (d2 == int32(arg1.shape[2]))")
  assert((d3 == cast(int32, (int64*)arg1.shape_1[3])), "Argument arg1.shape[3] has an unsatisfied constraint: (d3 == int32(arg1.shape[3]))")
  assert((0u64 == @tir.tvm_struct_get(arg1_1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1_1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id_1 == @tir.tvm_struct_get(arg1_1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  attr [0] "compute_scope" = "fused_nn_softmax_compute_";
  for (i0.i1.fused.i2.fused: int32, 0, ((d0*d1)*d2)) "parallel" {
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    attr [T_softmax_maxelem] "storage_alignment" = 128 {
      let T_softmax_maxelem = @tir.TVMBackendAllocWorkspace(1, dev_id_1, 4u64, 2, 32, dtype=handle)
       {
        if @tir.isnullptr(T_softmax_maxelem, dtype=bool) {
          @tir.tvm_throw_last_error(, dtype=int32)
        }
        attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
        attr [T_softmax_exp] "storage_alignment" = 128 {
          let T_softmax_exp = @tir.TVMBackendAllocWorkspace(1, dev_id_1, cast(uint64, (4*d3)), 2, 32, dtype=handle)
           {
            if @tir.isnullptr(T_softmax_exp, dtype=bool) {
              @tir.tvm_throw_last_error(, dtype=int32)
            }
            attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
            attr [T_softmax_expsum] "storage_alignment" = 128 {
              let T_softmax_expsum = @tir.TVMBackendAllocWorkspace(1, dev_id_1, 4u64, 2, 32, dtype=handle)
               {
                if @tir.isnullptr(T_softmax_expsum, dtype=bool) {
                  @tir.tvm_throw_last_error(, dtype=int32)
                }
                 {
                  T_softmax_maxelem[0] = -3.40282e+38f32
                  if (0 <= let rmod: int32 = (let rmod_1: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_1 >= 0)) || ((d2 < 0) && (rmod_1 <= 0))), rdiv, (rdiv - 1)) % d1) in let rdiv_1: int32 = (let rmod_1 = (i0.i1.fused.i2.fused % d2) in let rdiv = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_1 >= 0)) || ((d2 < 0) && (rmod_1 <= 0))), rdiv, (rdiv - 1)) / d1) in select((((d1 >= 0) && (rmod >= 0)) || ((d1 < 0) && (rmod <= 0))), rdiv_1, (rdiv_1 - 1))) {
                    if (let rmod_2: int32 = (let rmod_3: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_2: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_3 >= 0)) || ((d2 < 0) && (rmod_3 <= 0))), rdiv_2, (rdiv_2 - 1)) % d1) in let rdiv_3: int32 = (let rmod_3 = (i0.i1.fused.i2.fused % d2) in let rdiv_2 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_3 >= 0)) || ((d2 < 0) && (rmod_3 <= 0))), rdiv_2, (rdiv_2 - 1)) / d1) in select((((d1 >= 0) && (rmod_2 >= 0)) || ((d1 < 0) && (rmod_2 <= 0))), rdiv_3, (rdiv_3 - 1)) < d0) {
                      if (0 <= let rmod_4: int32 = (let rmod_5: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_4: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_5 >= 0)) || ((d2 < 0) && (rmod_5 <= 0))), rdiv_4, (rdiv_4 - 1)) % d1) in select((((d1 >= 0) && (rmod_4 >= 0)) || ((d1 < 0) && (rmod_4 <= 0))), rmod_4, (rmod_4 + d1))) {
                        if (let rmod_6: int32 = (let rmod_7: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_5: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_7 >= 0)) || ((d2 < 0) && (rmod_7 <= 0))), rdiv_5, (rdiv_5 - 1)) % d1) in select((((d1 >= 0) && (rmod_6 >= 0)) || ((d1 < 0) && (rmod_6 <= 0))), rmod_6, (rmod_6 + d1)) < d1) {
                          if (0 <= let rmod_8: int32 = (i0.i1.fused.i2.fused % d2) in select((((d2 >= 0) && (rmod_8 >= 0)) || ((d2 < 0) && (rmod_8 <= 0))), rmod_8, (rmod_8 + d2))) {
                            if (let rmod_9: int32 = (i0.i1.fused.i2.fused % d2) in select((((d2 >= 0) && (rmod_9 >= 0)) || ((d2 < 0) && (rmod_9 <= 0))), rmod_9, (rmod_9 + d2)) < d2) {
                              for (k: int32, 0, d3) {
                                T_softmax_maxelem[0] = max((float32*)T_softmax_maxelem[0], (float32*)placeholder_1[((((let rmod_10: int32 = (let rmod_11: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_6: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_11 >= 0)) || ((d2 < 0) && (rmod_11 <= 0))), rdiv_6, (rdiv_6 - 1)) % d1) in let rdiv_7: int32 = (let rmod_11 = (i0.i1.fused.i2.fused % d2) in let rdiv_6 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_11 >= 0)) || ((d2 < 0) && (rmod_11 <= 0))), rdiv_6, (rdiv_6 - 1)) / d1) in select((((d1 >= 0) && (rmod_10 >= 0)) || ((d1 < 0) && (rmod_10 <= 0))), rdiv_7, (rdiv_7 - 1))*stride_3) + (let rmod_12: int32 = (let rmod_13: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_8: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_13 >= 0)) || ((d2 < 0) && (rmod_13 <= 0))), rdiv_8, (rdiv_8 - 1)) % d1) in select((((d1 >= 0) && (rmod_12 >= 0)) || ((d1 < 0) && (rmod_12 <= 0))), rmod_12, (rmod_12 + d1))*stride_2)) + (let rmod_14: int32 = (i0.i1.fused.i2.fused % d2) in select((((d2 >= 0) && (rmod_14 >= 0)) || ((d2 < 0) && (rmod_14 <= 0))), rmod_14, (rmod_14 + d2))*stride_1)) + (k*stride))])
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  if (0 <= let rmod_15: int32 = (let rmod_16: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_9: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_16 >= 0)) || ((d2 < 0) && (rmod_16 <= 0))), rdiv_9, (rdiv_9 - 1)) % d1) in let rdiv_10: int32 = (let rmod_16 = (i0.i1.fused.i2.fused % d2) in let rdiv_9 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_16 >= 0)) || ((d2 < 0) && (rmod_16 <= 0))), rdiv_9, (rdiv_9 - 1)) / d1) in select((((d1 >= 0) && (rmod_15 >= 0)) || ((d1 < 0) && (rmod_15 <= 0))), rdiv_10, (rdiv_10 - 1))) {
                    if (let rmod_17: int32 = (let rmod_18: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_11: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_18 >= 0)) || ((d2 < 0) && (rmod_18 <= 0))), rdiv_11, (rdiv_11 - 1)) % d1) in let rdiv_12: int32 = (let rmod_18 = (i0.i1.fused.i2.fused % d2) in let rdiv_11 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_18 >= 0)) || ((d2 < 0) && (rmod_18 <= 0))), rdiv_11, (rdiv_11 - 1)) / d1) in select((((d1 >= 0) && (rmod_17 >= 0)) || ((d1 < 0) && (rmod_17 <= 0))), rdiv_12, (rdiv_12 - 1)) < d0) {
                      if (0 <= let rmod_19: int32 = (let rmod_20: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_13: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_20 >= 0)) || ((d2 < 0) && (rmod_20 <= 0))), rdiv_13, (rdiv_13 - 1)) % d1) in select((((d1 >= 0) && (rmod_19 >= 0)) || ((d1 < 0) && (rmod_19 <= 0))), rmod_19, (rmod_19 + d1))) {
                        if (let rmod_21: int32 = (let rmod_22: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_14: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_22 >= 0)) || ((d2 < 0) && (rmod_22 <= 0))), rdiv_14, (rdiv_14 - 1)) % d1) in select((((d1 >= 0) && (rmod_21 >= 0)) || ((d1 < 0) && (rmod_21 <= 0))), rmod_21, (rmod_21 + d1)) < d1) {
                          if (0 <= let rmod_23: int32 = (i0.i1.fused.i2.fused % d2) in select((((d2 >= 0) && (rmod_23 >= 0)) || ((d2 < 0) && (rmod_23 <= 0))), rmod_23, (rmod_23 + d2))) {
                            if (let rmod_24: int32 = (i0.i1.fused.i2.fused % d2) in select((((d2 >= 0) && (rmod_24 >= 0)) || ((d2 < 0) && (rmod_24 <= 0))), rmod_24, (rmod_24 + d2)) < d2) {
                              for (i3: int32, 0, d3) {
                                T_softmax_exp[i3] = @tir.call_llvm_pure_intrin(54u32, 1u32, ((float32*)placeholder_1[((((let rmod_25: int32 = (let rmod_26: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_15: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_26 >= 0)) || ((d2 < 0) && (rmod_26 <= 0))), rdiv_15, (rdiv_15 - 1)) % d1) in let rdiv_16: int32 = (let rmod_26 = (i0.i1.fused.i2.fused % d2) in let rdiv_15 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_26 >= 0)) || ((d2 < 0) && (rmod_26 <= 0))), rdiv_15, (rdiv_15 - 1)) / d1) in select((((d1 >= 0) && (rmod_25 >= 0)) || ((d1 < 0) && (rmod_25 <= 0))), rdiv_16, (rdiv_16 - 1))*stride_3) + (let rmod_27: int32 = (let rmod_28: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_17: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_28 >= 0)) || ((d2 < 0) && (rmod_28 <= 0))), rdiv_17, (rdiv_17 - 1)) % d1) in select((((d1 >= 0) && (rmod_27 >= 0)) || ((d1 < 0) && (rmod_27 <= 0))), rmod_27, (rmod_27 + d1))*stride_2)) + (let rmod_29: int32 = (i0.i1.fused.i2.fused % d2) in select((((d2 >= 0) && (rmod_29 >= 0)) || ((d2 < 0) && (rmod_29 <= 0))), rmod_29, (rmod_29 + d2))*stride_1)) + (i3*stride))] - (float32*)T_softmax_maxelem[0]), dtype=float32)
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  T_softmax_expsum[0] = 0f32
                  if (0 <= let rmod_30: int32 = (let rmod_31: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_18: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_31 >= 0)) || ((d2 < 0) && (rmod_31 <= 0))), rdiv_18, (rdiv_18 - 1)) % d1) in let rdiv_19: int32 = (let rmod_31 = (i0.i1.fused.i2.fused % d2) in let rdiv_18 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_31 >= 0)) || ((d2 < 0) && (rmod_31 <= 0))), rdiv_18, (rdiv_18 - 1)) / d1) in select((((d1 >= 0) && (rmod_30 >= 0)) || ((d1 < 0) && (rmod_30 <= 0))), rdiv_19, (rdiv_19 - 1))) {
                    if (let rmod_32: int32 = (let rmod_33: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_20: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_33 >= 0)) || ((d2 < 0) && (rmod_33 <= 0))), rdiv_20, (rdiv_20 - 1)) % d1) in let rdiv_21: int32 = (let rmod_33 = (i0.i1.fused.i2.fused % d2) in let rdiv_20 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_33 >= 0)) || ((d2 < 0) && (rmod_33 <= 0))), rdiv_20, (rdiv_20 - 1)) / d1) in select((((d1 >= 0) && (rmod_32 >= 0)) || ((d1 < 0) && (rmod_32 <= 0))), rdiv_21, (rdiv_21 - 1)) < d0) {
                      if (0 <= let rmod_34: int32 = (let rmod_35: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_22: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_35 >= 0)) || ((d2 < 0) && (rmod_35 <= 0))), rdiv_22, (rdiv_22 - 1)) % d1) in select((((d1 >= 0) && (rmod_34 >= 0)) || ((d1 < 0) && (rmod_34 <= 0))), rmod_34, (rmod_34 + d1))) {
                        if (let rmod_36: int32 = (let rmod_37: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_23: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_37 >= 0)) || ((d2 < 0) && (rmod_37 <= 0))), rdiv_23, (rdiv_23 - 1)) % d1) in select((((d1 >= 0) && (rmod_36 >= 0)) || ((d1 < 0) && (rmod_36 <= 0))), rmod_36, (rmod_36 + d1)) < d1) {
                          if (0 <= let rmod_38: int32 = (i0.i1.fused.i2.fused % d2) in select((((d2 >= 0) && (rmod_38 >= 0)) || ((d2 < 0) && (rmod_38 <= 0))), rmod_38, (rmod_38 + d2))) {
                            if (let rmod_39: int32 = (i0.i1.fused.i2.fused % d2) in select((((d2 >= 0) && (rmod_39 >= 0)) || ((d2 < 0) && (rmod_39 <= 0))), rmod_39, (rmod_39 + d2)) < d2) {
                              for (k_1: int32, 0, d3) {
                                T_softmax_expsum[0] = ((float32*)T_softmax_expsum[0] + (float32*)T_softmax_exp[k_1])
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  for (i3_1: int32, 0, d3) {
                    T_softmax_norm[((((let rmod_40: int32 = (let rmod_41: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_24: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_41 >= 0)) || ((d2 < 0) && (rmod_41 <= 0))), rdiv_24, (rdiv_24 - 1)) % d1) in let rdiv_25: int32 = (let rmod_41 = (i0.i1.fused.i2.fused % d2) in let rdiv_24 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_41 >= 0)) || ((d2 < 0) && (rmod_41 <= 0))), rdiv_24, (rdiv_24 - 1)) / d1) in select((((d1 >= 0) && (rmod_40 >= 0)) || ((d1 < 0) && (rmod_40 <= 0))), rdiv_25, (rdiv_25 - 1))*stride_7) + (let rmod_42: int32 = (let rmod_43: int32 = (i0.i1.fused.i2.fused % d2) in let rdiv_26: int32 = (i0.i1.fused.i2.fused / d2) in select((((d2 >= 0) && (rmod_43 >= 0)) || ((d2 < 0) && (rmod_43 <= 0))), rdiv_26, (rdiv_26 - 1)) % d1) in select((((d1 >= 0) && (rmod_42 >= 0)) || ((d1 < 0) && (rmod_42 <= 0))), rmod_42, (rmod_42 + d1))*stride_6)) + (let rmod_44: int32 = (i0.i1.fused.i2.fused % d2) in select((((d2 >= 0) && (rmod_44 >= 0)) || ((d2 < 0) && (rmod_44 <= 0))), rmod_44, (rmod_44 + d2))*stride_5)) + (i3_1*stride_4))] = ((float32*)T_softmax_exp[i3_1] / (float32*)T_softmax_expsum[0])
                  }
                }
              }
              if (@tir.TVMBackendFreeWorkspace(1, dev_id_1, T_softmax_expsum, dtype=int32) != 0) {
                @tir.tvm_throw_last_error(, dtype=int32)
              }
            }
          }
          if (@tir.TVMBackendFreeWorkspace(1, dev_id_1, T_softmax_exp, dtype=int32) != 0) {
            @tir.tvm_throw_last_error(, dtype=int32)
          }
        }
      }
      if (@tir.TVMBackendFreeWorkspace(1, dev_id_1, T_softmax_maxelem, dtype=int32) != 0) {
        @tir.tvm_throw_last_error(, dtype=int32)
      }
    }
  }
}

primfn(args_2: handle, arg_type_ids_2: handle, num_args_2: int32, out_ret_value_2: handle, out_ret_tcode_2: handle, resource_handle_2: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "shape_func_nn_softmax_1", "calling_conv": 1} {
  assert((num_args_2 == 2), "shape_func_nn_softmax_1: num_args should be 2")
  let arg0_2: handle = @tir.tvm_struct_get(args_2, 0, 12, dtype=handle)
  let arg0.code_2: int32 = (int32*)arg_type_ids_2[0]
  let arg1_2: handle = @tir.tvm_struct_get(args_2, 1, 12, dtype=handle)
  let arg1.code_2: int32 = (int32*)arg_type_ids_2[1]
  let placeholder_2: Pointer(int64) = @tir.tvm_struct_get(arg0_2, 0, 1, dtype=handle)
  attr [placeholder_2] "storage_alignment" = 128;
  let arg0.shape_2: handle = @tir.tvm_struct_get(arg0_2, 0, 2, dtype=handle)
  let arg0.strides_2: handle = @tir.tvm_struct_get(arg0_2, 0, 3, dtype=handle)
  let dev_id_2: int32 = @tir.tvm_struct_get(arg0_2, 0, 9, dtype=int32)
  let compute: Pointer(int64) = @tir.tvm_struct_get(arg1_2, 0, 1, dtype=handle)
  attr [compute] "storage_alignment" = 128;
  let arg1.shape_2: handle = @tir.tvm_struct_get(arg1_2, 0, 2, dtype=handle)
  let arg1.strides_2: handle = @tir.tvm_struct_get(arg1_2, 0, 3, dtype=handle)
  assert(((((arg0.code_2 == 3) || (arg0.code_2 == 13)) || (arg0.code_2 == 7)) || (arg0.code_2 == 4)), "shape_func_nn_softmax_1: Expect arg[0] to be pointer")
  assert(((((arg1.code_2 == 3) || (arg1.code_2 == 13)) || (arg1.code_2 == 7)) || (arg1.code_2 == 4)), "shape_func_nn_softmax_1: Expect arg[1] to be pointer")
  assert((1 == @tir.tvm_struct_get(arg0_2, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((1 == @tir.tvm_struct_get(arg0_2, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((((@tir.tvm_struct_get(arg0_2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0_2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0_2, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((4 == cast(int32, (int64*)arg0.shape_2[0])), "Argument arg0.shape[0] has an unsatisfied constraint: (4 == int32(arg0.shape[0]))")
   {
    if !@tir.isnullptr(arg0.strides_2, dtype=bool) {
      assert((1 == cast(int32, (int64*)arg0.strides_2[0])), "arg0.strides: expected to be compact array")
      0
    }
    assert((0u64 == @tir.tvm_struct_get(arg0_2, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg0_2, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
    assert((1 == @tir.tvm_struct_get(arg1_2, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 1")
    assert((1 == @tir.tvm_struct_get(arg1_2, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 1")
    assert((((@tir.tvm_struct_get(arg1_2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1_2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1_2, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
    assert((4 == cast(int32, (int64*)arg1.shape_2[0])), "Argument arg1.shape[0] has an unsatisfied constraint: (4 == int32(arg1.shape[0]))")
     {
      if !@tir.isnullptr(arg1.strides_2, dtype=bool) {
        assert((1 == cast(int32, (int64*)arg1.strides_2[0])), "arg1.strides: expected to be compact array")
        0
      }
      assert((0u64 == @tir.tvm_struct_get(arg1_2, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
      assert((1 == @tir.tvm_struct_get(arg1_2, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
      assert((dev_id_2 == @tir.tvm_struct_get(arg1_2, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
      attr [0] "compute_scope" = "shape_func_nn_softmax_1_compute_";
      for (i0: int32, 0, 4) {
        compute[i0] = (int64*)placeholder_2[i0]
      }
    }
  }
}

primfn(args_3: handle, arg_type_ids_3: handle, num_args_3: int32, out_ret_value_3: handle, out_ret_tcode_3: handle, resource_handle_3: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_multiply", "calling_conv": 1} {
  assert((num_args_3 == 2), "fused_multiply: num_args should be 2")
  let arg0_3: handle = @tir.tvm_struct_get(args_3, 0, 12, dtype=handle)
  let arg0.code_3: int32 = (int32*)arg_type_ids_3[0]
  let arg1_3: handle = @tir.tvm_struct_get(args_3, 1, 12, dtype=handle)
  let arg1.code_3: int32 = (int32*)arg_type_ids_3[1]
  let placeholder_3: Pointer(int64) = @tir.tvm_struct_get(arg0_3, 0, 1, dtype=handle)
  attr [placeholder_3] "storage_alignment" = 128;
  let arg0.shape_3: handle = @tir.tvm_struct_get(arg0_3, 0, 2, dtype=handle)
  let arg0.strides_3: handle = @tir.tvm_struct_get(arg0_3, 0, 3, dtype=handle)
  let dev_id_3: int32 = @tir.tvm_struct_get(arg0_3, 0, 9, dtype=int32)
  let T_multiply: Pointer(int64) = @tir.tvm_struct_get(arg1_3, 0, 1, dtype=handle)
  attr [T_multiply] "storage_alignment" = 128;
  let arg1.shape_3: handle = @tir.tvm_struct_get(arg1_3, 0, 2, dtype=handle)
  let arg1.strides_3: handle = @tir.tvm_struct_get(arg1_3, 0, 3, dtype=handle)
  assert(((((arg0.code_3 == 3) || (arg0.code_3 == 13)) || (arg0.code_3 == 7)) || (arg0.code_3 == 4)), "fused_multiply: Expect arg[0] to be pointer")
  assert(((((arg1.code_3 == 3) || (arg1.code_3 == 13)) || (arg1.code_3 == 7)) || (arg1.code_3 == 4)), "fused_multiply: Expect arg[1] to be pointer")
  assert((0 == @tir.tvm_struct_get(arg0_3, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0_3, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0_3, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0_3, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0_3, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0_3, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0_3, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1_3, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1_3, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1_3, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1_3, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1_3, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1_3, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1_3, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id_3 == @tir.tvm_struct_get(arg1_3, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  attr [0] "compute_scope" = "fused_multiply_compute_";
  T_multiply[0] = ((int64*)placeholder_3[0]*4i64)
}


[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass Filter

[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass BindTarget

[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerWarpMemory

[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify

[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerCustomDatatypes

[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerIntrin

[11:49:24] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerDeviceStorageAccessInfo

[11:49:24] /workspace/home/codes/tvm/src/relay/backend/vm/compiler.cc:1205: CODEGEN END

Raw module: 
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) {
  nn.softmax(%x)
}


Running on (llvm, cpu(0))
Finish in 21.46602 ms
