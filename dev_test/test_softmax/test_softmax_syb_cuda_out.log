[14:05:56] /workspace/home/codes/tvm/src/relay/backend/vm/compiler.cc:916: LOWER START

[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass RemoveUnusedFunctions
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) {
  nn.softmax(%x)
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass ToBasicBlockNormalForm
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) {
  nn.softmax(%x)
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass Legalize
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  nn.softmax(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass Legalize
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  nn.softmax(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass sequential
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  nn.softmax(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass Legalize
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  nn.softmax(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass EtaExpand
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  nn.softmax(%x)
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass SimplifyInference
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  nn.softmax(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass SimplifyExpr
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  nn.softmax(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass Inline
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  nn.softmax(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass DeadCodeElimination
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  nn.softmax(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass InlinePrimitives
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  nn.softmax(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass FoldConstant
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  nn.softmax(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass FoldConstant
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  nn.softmax(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass FoldScaleAxis
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  nn.softmax(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass FoldConstant
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  nn.softmax(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass FuseOps
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  %0 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  %0(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass ToANormalForm
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  let %x1 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  let %x2 = %x1(%x);
  %x2
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass InferType
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  let %x1: fn (Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  let %x2: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %x1(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */;
  %x2
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass LambdaLift
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  let %x1: fn (Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  let %x2: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %x1(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */;
  %x2
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass Inline
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  %0 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  let %x1: fn (Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %0;
  let %x2: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %0(%x);
  %x2
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass DeadCodeElimination
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  %0 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  let %x1: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %0(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */;
  %x1
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass InlinePrimitives
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  %0 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  let %x1: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %0(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */;
  %x1
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass InlineGlobals
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  %0 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  let %x1: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %0(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */;
  %x1
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass RemoveUnusedFunctions
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  %0 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  let %x1: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %0(%x) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */;
  %x1
}


[14:05:56] /workspace/home/codes/tvm/src/driver/driver_api.cc:139: LOWER INFERBOUND BEFORE
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0, ): range(min=0, ext=4)
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0, range(min=0, ext=4)): range(min=0, ext=4)
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, 3]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, 3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/driver/driver_api.cc:149: Func before opt
[14:05:56] /workspace/home/codes/tvm/src/driver/driver_api.cc:150: primfn(placeholder_1: handle, compute_1: handle) -> ()
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  attr [compute] "realize_scope" = "";
  realize(compute, [0:4], True {
    for (i0: int32, 0, 4) {
      compute[i0] = placeholder[i0]
    }
  })
}
[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectPrefetch
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  attr [compute] "realize_scope" = "";
  realize(compute, [0:4], True {
    for (i0: int32, 0, 4) {
      compute[i0] = placeholder[i0]
    }
  })
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.StorageFlatten
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16Promote
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16CastElimination
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16TypeLowering
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16Legalize
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.NarrowDataType
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LoopPartition
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.VectorizeLoop
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectVirtualThread
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectDoubleBuffer
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.StorageRewrite
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.UnrollLoop
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.RemoveNoOp
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.RewriteUnsafeSelect
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass ManifestAlloc
type Storage {
  
}

def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  let %in_shape_0: Tensor[(4), int64] = vm.shape_of(%x, meta[relay.attrs.ShapeOfAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %storage_0: Storage[] = memory.alloc_storage(32 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][0]) /* ty=Storage[] */;
  let %tensor_0: Tensor[(4), int64] = memory.alloc_tensor(%storage_0, 0 /* ty=int64 */, meta[relay.Constant][0] /* ty=Tensor[(1), int64] */, meta[relay.attrs.AllocTensorAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %shape_func_out_0: Tensor[(4), int64] = %tensor_0;
  %0 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  %1 = (%in_shape_0,);
  %2 = (%shape_func_out_0,);
  let %shape_func: () = vm.shape_func(%0, %1, %2, meta[relay.attrs.ShapeFuncAttrs][0]) /* ty=() */;
  %3 = add(32 /* ty=int64 */, 7 /* ty=int64 */) /* ty=int64 */;
  %4 = prod(%shape_func_out_0) /* ty=int64 */;
  %5 = divide(%3, 8 /* ty=int64 */) /* ty=int64 */;
  %6 = multiply(%4, %5) /* ty=int64 */;
  let %storage_01: Storage[] = memory.alloc_storage(%6, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][1]) /* ty=Storage[] */;
  let %out_0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = memory.alloc_tensor(%storage_01, 0 /* ty=int64 */, %shape_func_out_0, meta[relay.attrs.AllocTensorAttrs][1]) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */;
  %7 = (%x,);
  %8 = (%out_0,);
  let %x1: () = vm.invoke_tvm_op(%0, %7, %8) /* ty=() */;
  let %x2: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %out_0;
  %x2
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass FuseOps
type Storage {
  
}

def @main() -> int64 {
  %0 = fn (%p0: int64, %p1: int64, Primitive=1) -> int64 {
    add(%p0, %p1) /* ty=int64 */
  };
  %0(32 /* ty=int64 */, 7 /* ty=int64 */) /* ty=int64 */
}

[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass ToANormalForm
type Storage {
  
}

def @main() -> int64 {
  let %x = 32 /* ty=int64 */;
  let %x1 = 7 /* ty=int64 */;
  let %x2 = fn (%p0: int64, %p1: int64, Primitive=1) -> int64 {
    add(%p0, %p1) /* ty=int64 */
  };
  let %x3 = %x2(%x, %x1);
  %x3
}

[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass InferType
type Storage {
  
}

def @main() -> int64 {
  let %x: int64 = 32 /* ty=int64 */;
  let %x1: int64 = 7 /* ty=int64 */;
  let %x2: fn (int64, int64) -> int64 = fn (%p0: int64, %p1: int64, Primitive=1) -> int64 {
    add(%p0, %p1) /* ty=int64 */
  };
  let %x3: int64 = %x2(%x, %x1) /* ty=int64 */;
  %x3
}

[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass EtaExpand
type Storage {
  
}

def @main() -> int64 {
  let %x: int64 = 32 /* ty=int64 */;
  let %x1: int64 = 7 /* ty=int64 */;
  let %x2: fn (int64, int64) -> int64 = fn (%p0: int64, %p1: int64, Primitive=1) -> int64 {
    add(%p0, %p1)
  };
  let %x3: int64 = %x2(%x, %x1);
  %x3
}

[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass InferType
type Storage {
  
}

def @main() -> int64 {
  let %x: int64 = 32 /* ty=int64 */;
  let %x1: int64 = 7 /* ty=int64 */;
  let %x2: fn (int64, int64) -> int64 = fn (%p0: int64, %p1: int64, Primitive=1) -> int64 {
    add(%p0, %p1) /* ty=int64 */
  };
  let %x3: int64 = %x2(%x, %x1) /* ty=int64 */;
  %x3
}

[14:05:56] /workspace/home/codes/tvm/src/relay/backend/compile_engine.cc:767: POS1
[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectPrefetch
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  attr [T_add] "realize_scope" = "";
  realize(T_add, [], True {
    T_add[] = (placeholder[] + placeholder_1[])
  })
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.StorageFlatten
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16Promote
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16CastElimination
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16TypeLowering
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16Legalize
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.NarrowDataType
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LoopPartition
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.VectorizeLoop
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectVirtualThread
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectDoubleBuffer
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.StorageRewrite
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.UnrollLoop
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.RemoveNoOp
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.RewriteUnsafeSelect
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.HoistIfThenElse
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/relay/backend/compile_engine.cc:778: POS4
[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerReduction
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.PlanAndUpdateBufferAllocationLocation
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.ConvertBlocksToOpaque
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.CompactBufferAllocation
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.FlattenBuffer
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16Promote
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16CastElimination
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16TypeLowering
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16Legalize
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.NarrowDataType
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LoopPartition
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.VectorizeLoop
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectVirtualThread
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectDoubleBuffer
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.StorageRewrite
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.UnrollLoop
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.RemoveNoOp
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.RewriteUnsafeSelect
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.HoistIfThenElse
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.VerifyMemory
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass Apply
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True, "target": meta[Target][0], "tir.is_entry_func": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.ThreadSync
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True, "target": meta[Target][0], "tir.is_entry_func": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.ThreadSync
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True, "target": meta[Target][0], "tir.is_entry_func": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InferFragment
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True, "target": meta[Target][0], "tir.is_entry_func": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerThreadAllreduce
primfn(placeholder_2: handle, placeholder_3: handle, T_add_1: handle) -> ()
  attr = {"global_symbol": "fused_add", "tir.noalias": True, "target": meta[Target][0], "tir.is_entry_func": True}
  buffers = {placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             T_add: Buffer(T_add_2: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_add_1: T_add} {
  T_add_2[0] = ((int64*)placeholder_4[0] + (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.MakePackedAPI
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_add", "tir.is_entry_func": True, "calling_conv": 1} {
  assert((num_args == 3), "fused_add: num_args should be 3")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let arg2: handle = @tir.tvm_struct_get(args, 2, 12, dtype=handle)
  let arg2.code: int32 = (int32*)arg_type_ids[2]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let T_add: Pointer(int64) = @tir.tvm_struct_get(arg2, 0, 1, dtype=handle)
  attr [T_add] "storage_alignment" = 128;
  let arg2.shape: handle = @tir.tvm_struct_get(arg2, 0, 2, dtype=handle)
  let arg2.strides: handle = @tir.tvm_struct_get(arg2, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_add: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_add: Expect arg[1] to be pointer")
  assert(((((arg2.code == 3) || (arg2.code == 13)) || (arg2.code == 7)) || (arg2.code == 4)), "fused_add: Expect arg[2] to be pointer")
  attr ["default"] "device_id" = dev_id;
  attr ["default"] "device_type" = 1;
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg2, 0, 7, dtype=uint16) == 1u16)), "arg2.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg2, 0, 8, dtype=uint64)), "Argument arg2.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg2, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg2, 0, 10, dtype=int32)), "Argument arg2.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg2, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg2, 0, 9, dtype=int32)), "Argument arg2.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg2, 0, 9))")
  attr [0] "compute_scope" = "fused_add_compute_";
  T_add[0] = ((int64*)placeholder[0] + (int64*)placeholder_1[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.SplitHostDevice
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": (nullptr), "tir.noalias": True, "global_symbol": "fused_add", "tir.is_entry_func": True, "calling_conv": 1} {
  assert((num_args == 3), "fused_add: num_args should be 3")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let arg2: handle = @tir.tvm_struct_get(args, 2, 12, dtype=handle)
  let arg2.code: int32 = (int32*)arg_type_ids[2]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let T_add: Pointer(int64) = @tir.tvm_struct_get(arg2, 0, 1, dtype=handle)
  attr [T_add] "storage_alignment" = 128;
  let arg2.shape: handle = @tir.tvm_struct_get(arg2, 0, 2, dtype=handle)
  let arg2.strides: handle = @tir.tvm_struct_get(arg2, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_add: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_add: Expect arg[1] to be pointer")
  assert(((((arg2.code == 3) || (arg2.code == 13)) || (arg2.code == 7)) || (arg2.code == 4)), "fused_add: Expect arg[2] to be pointer")
  attr ["default"] "device_id" = dev_id;
  attr ["default"] "device_type" = 1;
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg2, 0, 7, dtype=uint16) == 1u16)), "arg2.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg2, 0, 8, dtype=uint64)), "Argument arg2.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg2, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg2, 0, 10, dtype=int32)), "Argument arg2.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg2, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg2, 0, 9, dtype=int32)), "Argument arg2.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg2, 0, 9))")
  attr [0] "compute_scope" = "fused_add_compute_";
  T_add[0] = ((int64*)placeholder[0] + (int64*)placeholder_1[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass Filter

[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerWarpMemory

[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify

[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerDeviceStorageAccessInfo

[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerCustomDatatypes

[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerIntrin

[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass Filter
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": (nullptr), "tir.noalias": True, "global_symbol": "fused_add", "tir.is_entry_func": True, "calling_conv": 1} {
  assert((num_args == 3), "fused_add: num_args should be 3")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let arg2: handle = @tir.tvm_struct_get(args, 2, 12, dtype=handle)
  let arg2.code: int32 = (int32*)arg_type_ids[2]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let T_add: Pointer(int64) = @tir.tvm_struct_get(arg2, 0, 1, dtype=handle)
  attr [T_add] "storage_alignment" = 128;
  let arg2.shape: handle = @tir.tvm_struct_get(arg2, 0, 2, dtype=handle)
  let arg2.strides: handle = @tir.tvm_struct_get(arg2, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_add: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_add: Expect arg[1] to be pointer")
  assert(((((arg2.code == 3) || (arg2.code == 13)) || (arg2.code == 7)) || (arg2.code == 4)), "fused_add: Expect arg[2] to be pointer")
  attr ["default"] "device_id" = dev_id;
  attr ["default"] "device_type" = 1;
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg2, 0, 7, dtype=uint16) == 1u16)), "arg2.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg2, 0, 8, dtype=uint64)), "Argument arg2.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg2, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg2, 0, 10, dtype=int32)), "Argument arg2.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg2, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg2, 0, 9, dtype=int32)), "Argument arg2.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg2, 0, 9))")
  attr [0] "compute_scope" = "fused_add_compute_";
  T_add[0] = ((int64*)placeholder[0] + (int64*)placeholder_1[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass Apply
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_add", "tir.is_entry_func": True, "calling_conv": 1} {
  assert((num_args == 3), "fused_add: num_args should be 3")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let arg2: handle = @tir.tvm_struct_get(args, 2, 12, dtype=handle)
  let arg2.code: int32 = (int32*)arg_type_ids[2]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let T_add: Pointer(int64) = @tir.tvm_struct_get(arg2, 0, 1, dtype=handle)
  attr [T_add] "storage_alignment" = 128;
  let arg2.shape: handle = @tir.tvm_struct_get(arg2, 0, 2, dtype=handle)
  let arg2.strides: handle = @tir.tvm_struct_get(arg2, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_add: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_add: Expect arg[1] to be pointer")
  assert(((((arg2.code == 3) || (arg2.code == 13)) || (arg2.code == 7)) || (arg2.code == 4)), "fused_add: Expect arg[2] to be pointer")
  attr ["default"] "device_id" = dev_id;
  attr ["default"] "device_type" = 1;
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg2, 0, 7, dtype=uint16) == 1u16)), "arg2.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg2, 0, 8, dtype=uint64)), "Argument arg2.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg2, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg2, 0, 10, dtype=int32)), "Argument arg2.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg2, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg2, 0, 9, dtype=int32)), "Argument arg2.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg2, 0, 9))")
  attr [0] "compute_scope" = "fused_add_compute_";
  T_add[0] = ((int64*)placeholder[0] + (int64*)placeholder_1[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerTVMBuiltin
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_add", "tir.is_entry_func": True, "calling_conv": 1} {
  assert((num_args == 3), "fused_add: num_args should be 3")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let arg2: handle = @tir.tvm_struct_get(args, 2, 12, dtype=handle)
  let arg2.code: int32 = (int32*)arg_type_ids[2]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let T_add: Pointer(int64) = @tir.tvm_struct_get(arg2, 0, 1, dtype=handle)
  attr [T_add] "storage_alignment" = 128;
  let arg2.shape: handle = @tir.tvm_struct_get(arg2, 0, 2, dtype=handle)
  let arg2.strides: handle = @tir.tvm_struct_get(arg2, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_add: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_add: Expect arg[1] to be pointer")
  assert(((((arg2.code == 3) || (arg2.code == 13)) || (arg2.code == 7)) || (arg2.code == 4)), "fused_add: Expect arg[2] to be pointer")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg2, 0, 7, dtype=uint16) == 1u16)), "arg2.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg2, 0, 8, dtype=uint64)), "Argument arg2.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg2, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg2, 0, 10, dtype=int32)), "Argument arg2.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg2, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg2, 0, 9, dtype=int32)), "Argument arg2.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg2, 0, 9))")
  attr [0] "compute_scope" = "fused_add_compute_";
  T_add[0] = ((int64*)placeholder[0] + (int64*)placeholder_1[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerDeviceStorageAccessInfo
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_add", "tir.is_entry_func": True, "calling_conv": 1} {
  assert((num_args == 3), "fused_add: num_args should be 3")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let arg2: handle = @tir.tvm_struct_get(args, 2, 12, dtype=handle)
  let arg2.code: int32 = (int32*)arg_type_ids[2]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let T_add: Pointer(int64) = @tir.tvm_struct_get(arg2, 0, 1, dtype=handle)
  attr [T_add] "storage_alignment" = 128;
  let arg2.shape: handle = @tir.tvm_struct_get(arg2, 0, 2, dtype=handle)
  let arg2.strides: handle = @tir.tvm_struct_get(arg2, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_add: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_add: Expect arg[1] to be pointer")
  assert(((((arg2.code == 3) || (arg2.code == 13)) || (arg2.code == 7)) || (arg2.code == 4)), "fused_add: Expect arg[2] to be pointer")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg2, 0, 7, dtype=uint16) == 1u16)), "arg2.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg2, 0, 8, dtype=uint64)), "Argument arg2.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg2, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg2, 0, 10, dtype=int32)), "Argument arg2.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg2, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg2, 0, 9, dtype=int32)), "Argument arg2.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg2, 0, 9))")
  attr [0] "compute_scope" = "fused_add_compute_";
  T_add[0] = ((int64*)placeholder[0] + (int64*)placeholder_1[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerCustomDatatypes
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_add", "tir.is_entry_func": True, "calling_conv": 1} {
  assert((num_args == 3), "fused_add: num_args should be 3")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let arg2: handle = @tir.tvm_struct_get(args, 2, 12, dtype=handle)
  let arg2.code: int32 = (int32*)arg_type_ids[2]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let T_add: Pointer(int64) = @tir.tvm_struct_get(arg2, 0, 1, dtype=handle)
  attr [T_add] "storage_alignment" = 128;
  let arg2.shape: handle = @tir.tvm_struct_get(arg2, 0, 2, dtype=handle)
  let arg2.strides: handle = @tir.tvm_struct_get(arg2, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_add: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_add: Expect arg[1] to be pointer")
  assert(((((arg2.code == 3) || (arg2.code == 13)) || (arg2.code == 7)) || (arg2.code == 4)), "fused_add: Expect arg[2] to be pointer")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg2, 0, 7, dtype=uint16) == 1u16)), "arg2.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg2, 0, 8, dtype=uint64)), "Argument arg2.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg2, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg2, 0, 10, dtype=int32)), "Argument arg2.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg2, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg2, 0, 9, dtype=int32)), "Argument arg2.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg2, 0, 9))")
  attr [0] "compute_scope" = "fused_add_compute_";
  T_add[0] = ((int64*)placeholder[0] + (int64*)placeholder_1[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerIntrin
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_add", "tir.is_entry_func": True, "calling_conv": 1} {
  assert((num_args == 3), "fused_add: num_args should be 3")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let arg2: handle = @tir.tvm_struct_get(args, 2, 12, dtype=handle)
  let arg2.code: int32 = (int32*)arg_type_ids[2]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let T_add: Pointer(int64) = @tir.tvm_struct_get(arg2, 0, 1, dtype=handle)
  attr [T_add] "storage_alignment" = 128;
  let arg2.shape: handle = @tir.tvm_struct_get(arg2, 0, 2, dtype=handle)
  let arg2.strides: handle = @tir.tvm_struct_get(arg2, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_add: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_add: Expect arg[1] to be pointer")
  assert(((((arg2.code == 3) || (arg2.code == 13)) || (arg2.code == 7)) || (arg2.code == 4)), "fused_add: Expect arg[2] to be pointer")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg2, 0, 7, dtype=uint16) == 1u16)), "arg2.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg2, 0, 8, dtype=uint64)), "Argument arg2.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg2, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg2, 0, 10, dtype=int32)), "Argument arg2.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg2, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg2, 0, 9, dtype=int32)), "Argument arg2.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg2, 0, 9))")
  attr [0] "compute_scope" = "fused_add_compute_";
  T_add[0] = ((int64*)placeholder[0] + (int64*)placeholder_1[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.CombineContextCall
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_add", "tir.is_entry_func": True, "calling_conv": 1} {
  assert((num_args == 3), "fused_add: num_args should be 3")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let arg2: handle = @tir.tvm_struct_get(args, 2, 12, dtype=handle)
  let arg2.code: int32 = (int32*)arg_type_ids[2]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let T_add: Pointer(int64) = @tir.tvm_struct_get(arg2, 0, 1, dtype=handle)
  attr [T_add] "storage_alignment" = 128;
  let arg2.shape: handle = @tir.tvm_struct_get(arg2, 0, 2, dtype=handle)
  let arg2.strides: handle = @tir.tvm_struct_get(arg2, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_add: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_add: Expect arg[1] to be pointer")
  assert(((((arg2.code == 3) || (arg2.code == 13)) || (arg2.code == 7)) || (arg2.code == 4)), "fused_add: Expect arg[2] to be pointer")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg2, 0, 7, dtype=uint16) == 1u16)), "arg2.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg2, 0, 8, dtype=uint64)), "Argument arg2.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg2, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg2, 0, 10, dtype=int32)), "Argument arg2.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg2, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg2, 0, 9, dtype=int32)), "Argument arg2.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg2, 0, 9))")
  attr [0] "compute_scope" = "fused_add_compute_";
  T_add[0] = ((int64*)placeholder[0] + (int64*)placeholder_1[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass FuseOps
type Storage {
  
}

def @main() -> int64 {
  %0 = fn (%p0: int64, %p1: int64, Primitive=1) -> int64 {
    divide(%p0, %p1) /* ty=int64 */
  };
  %0(39 /* ty=int64 */, 8 /* ty=int64 */) /* ty=int64 */
}

[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass ToANormalForm
type Storage {
  
}

def @main() -> int64 {
  let %x = 39 /* ty=int64 */;
  let %x1 = 8 /* ty=int64 */;
  let %x2 = fn (%p0: int64, %p1: int64, Primitive=1) -> int64 {
    divide(%p0, %p1) /* ty=int64 */
  };
  let %x3 = %x2(%x, %x1);
  %x3
}

[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass InferType
type Storage {
  
}

def @main() -> int64 {
  let %x: int64 = 39 /* ty=int64 */;
  let %x1: int64 = 8 /* ty=int64 */;
  let %x2: fn (int64, int64) -> int64 = fn (%p0: int64, %p1: int64, Primitive=1) -> int64 {
    divide(%p0, %p1) /* ty=int64 */
  };
  let %x3: int64 = %x2(%x, %x1) /* ty=int64 */;
  %x3
}

[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass EtaExpand
type Storage {
  
}

def @main() -> int64 {
  let %x: int64 = 39 /* ty=int64 */;
  let %x1: int64 = 8 /* ty=int64 */;
  let %x2: fn (int64, int64) -> int64 = fn (%p0: int64, %p1: int64, Primitive=1) -> int64 {
    divide(%p0, %p1)
  };
  let %x3: int64 = %x2(%x, %x1);
  %x3
}

[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass InferType
type Storage {
  
}

def @main() -> int64 {
  let %x: int64 = 39 /* ty=int64 */;
  let %x1: int64 = 8 /* ty=int64 */;
  let %x2: fn (int64, int64) -> int64 = fn (%p0: int64, %p1: int64, Primitive=1) -> int64 {
    divide(%p0, %p1) /* ty=int64 */
  };
  let %x3: int64 = %x2(%x, %x1) /* ty=int64 */;
  %x3
}

[14:05:56] /workspace/home/codes/tvm/src/relay/backend/compile_engine.cc:767: POS1
[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectPrefetch
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  attr [T_divide] "realize_scope" = "";
  realize(T_divide, [], True {
    T_divide[] = (placeholder[] / placeholder_1[])
  })
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.StorageFlatten
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16Promote
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16CastElimination
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16TypeLowering
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16Legalize
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.NarrowDataType
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LoopPartition
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.VectorizeLoop
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectVirtualThread
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectDoubleBuffer
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.StorageRewrite
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.UnrollLoop
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.RemoveNoOp
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.RewriteUnsafeSelect
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.HoistIfThenElse
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/relay/backend/compile_engine.cc:778: POS4
[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerReduction
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.PlanAndUpdateBufferAllocationLocation
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.ConvertBlocksToOpaque
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.CompactBufferAllocation
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.FlattenBuffer
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16Promote
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16CastElimination
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16TypeLowering
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16Legalize
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.NarrowDataType
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LoopPartition
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.VectorizeLoop
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectVirtualThread
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectDoubleBuffer
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.StorageRewrite
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.UnrollLoop
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.RemoveNoOp
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.RewriteUnsafeSelect
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.HoistIfThenElse
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.VerifyMemory
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass Apply
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True, "target": meta[Target][0], "tir.is_entry_func": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.ThreadSync
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True, "target": meta[Target][0], "tir.is_entry_func": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.ThreadSync
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True, "target": meta[Target][0], "tir.is_entry_func": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InferFragment
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True, "target": meta[Target][0], "tir.is_entry_func": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerThreadAllreduce
primfn(placeholder_2: handle, placeholder_3: handle, T_divide_1: handle) -> ()
  attr = {"global_symbol": "fused_divide", "tir.noalias": True, "target": meta[Target][0], "tir.is_entry_func": True}
  buffers = {T_divide: Buffer(T_divide_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_4: Pointer(int64), int64, [], []),
             placeholder_1: Buffer(placeholder_5: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_2: placeholder, placeholder_3: placeholder_1, T_divide_1: T_divide} {
  T_divide_2[0] = ((int64*)placeholder_4[0] / (int64*)placeholder_5[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.MakePackedAPI
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_divide", "tir.is_entry_func": True, "calling_conv": 1} {
  assert((num_args == 3), "fused_divide: num_args should be 3")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let arg2: handle = @tir.tvm_struct_get(args, 2, 12, dtype=handle)
  let arg2.code: int32 = (int32*)arg_type_ids[2]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let T_divide: Pointer(int64) = @tir.tvm_struct_get(arg2, 0, 1, dtype=handle)
  attr [T_divide] "storage_alignment" = 128;
  let arg2.shape: handle = @tir.tvm_struct_get(arg2, 0, 2, dtype=handle)
  let arg2.strides: handle = @tir.tvm_struct_get(arg2, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_divide: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_divide: Expect arg[1] to be pointer")
  assert(((((arg2.code == 3) || (arg2.code == 13)) || (arg2.code == 7)) || (arg2.code == 4)), "fused_divide: Expect arg[2] to be pointer")
  attr ["default"] "device_id" = dev_id;
  attr ["default"] "device_type" = 1;
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg2, 0, 7, dtype=uint16) == 1u16)), "arg2.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg2, 0, 8, dtype=uint64)), "Argument arg2.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg2, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg2, 0, 10, dtype=int32)), "Argument arg2.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg2, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg2, 0, 9, dtype=int32)), "Argument arg2.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg2, 0, 9))")
  attr [0] "compute_scope" = "fused_divide_compute_";
  T_divide[0] = ((int64*)placeholder[0] / (int64*)placeholder_1[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.SplitHostDevice
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": (nullptr), "tir.noalias": True, "global_symbol": "fused_divide", "tir.is_entry_func": True, "calling_conv": 1} {
  assert((num_args == 3), "fused_divide: num_args should be 3")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let arg2: handle = @tir.tvm_struct_get(args, 2, 12, dtype=handle)
  let arg2.code: int32 = (int32*)arg_type_ids[2]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let T_divide: Pointer(int64) = @tir.tvm_struct_get(arg2, 0, 1, dtype=handle)
  attr [T_divide] "storage_alignment" = 128;
  let arg2.shape: handle = @tir.tvm_struct_get(arg2, 0, 2, dtype=handle)
  let arg2.strides: handle = @tir.tvm_struct_get(arg2, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_divide: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_divide: Expect arg[1] to be pointer")
  assert(((((arg2.code == 3) || (arg2.code == 13)) || (arg2.code == 7)) || (arg2.code == 4)), "fused_divide: Expect arg[2] to be pointer")
  attr ["default"] "device_id" = dev_id;
  attr ["default"] "device_type" = 1;
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg2, 0, 7, dtype=uint16) == 1u16)), "arg2.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg2, 0, 8, dtype=uint64)), "Argument arg2.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg2, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg2, 0, 10, dtype=int32)), "Argument arg2.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg2, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg2, 0, 9, dtype=int32)), "Argument arg2.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg2, 0, 9))")
  attr [0] "compute_scope" = "fused_divide_compute_";
  T_divide[0] = ((int64*)placeholder[0] / (int64*)placeholder_1[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass Filter

[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerWarpMemory

[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify

[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerDeviceStorageAccessInfo

[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerCustomDatatypes

[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerIntrin

[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass Filter
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": (nullptr), "tir.noalias": True, "global_symbol": "fused_divide", "tir.is_entry_func": True, "calling_conv": 1} {
  assert((num_args == 3), "fused_divide: num_args should be 3")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let arg2: handle = @tir.tvm_struct_get(args, 2, 12, dtype=handle)
  let arg2.code: int32 = (int32*)arg_type_ids[2]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let T_divide: Pointer(int64) = @tir.tvm_struct_get(arg2, 0, 1, dtype=handle)
  attr [T_divide] "storage_alignment" = 128;
  let arg2.shape: handle = @tir.tvm_struct_get(arg2, 0, 2, dtype=handle)
  let arg2.strides: handle = @tir.tvm_struct_get(arg2, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_divide: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_divide: Expect arg[1] to be pointer")
  assert(((((arg2.code == 3) || (arg2.code == 13)) || (arg2.code == 7)) || (arg2.code == 4)), "fused_divide: Expect arg[2] to be pointer")
  attr ["default"] "device_id" = dev_id;
  attr ["default"] "device_type" = 1;
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg2, 0, 7, dtype=uint16) == 1u16)), "arg2.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg2, 0, 8, dtype=uint64)), "Argument arg2.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg2, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg2, 0, 10, dtype=int32)), "Argument arg2.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg2, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg2, 0, 9, dtype=int32)), "Argument arg2.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg2, 0, 9))")
  attr [0] "compute_scope" = "fused_divide_compute_";
  T_divide[0] = ((int64*)placeholder[0] / (int64*)placeholder_1[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass Apply
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_divide", "tir.is_entry_func": True, "calling_conv": 1} {
  assert((num_args == 3), "fused_divide: num_args should be 3")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let arg2: handle = @tir.tvm_struct_get(args, 2, 12, dtype=handle)
  let arg2.code: int32 = (int32*)arg_type_ids[2]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let T_divide: Pointer(int64) = @tir.tvm_struct_get(arg2, 0, 1, dtype=handle)
  attr [T_divide] "storage_alignment" = 128;
  let arg2.shape: handle = @tir.tvm_struct_get(arg2, 0, 2, dtype=handle)
  let arg2.strides: handle = @tir.tvm_struct_get(arg2, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_divide: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_divide: Expect arg[1] to be pointer")
  assert(((((arg2.code == 3) || (arg2.code == 13)) || (arg2.code == 7)) || (arg2.code == 4)), "fused_divide: Expect arg[2] to be pointer")
  attr ["default"] "device_id" = dev_id;
  attr ["default"] "device_type" = 1;
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg2, 0, 7, dtype=uint16) == 1u16)), "arg2.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg2, 0, 8, dtype=uint64)), "Argument arg2.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg2, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg2, 0, 10, dtype=int32)), "Argument arg2.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg2, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg2, 0, 9, dtype=int32)), "Argument arg2.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg2, 0, 9))")
  attr [0] "compute_scope" = "fused_divide_compute_";
  T_divide[0] = ((int64*)placeholder[0] / (int64*)placeholder_1[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerTVMBuiltin
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_divide", "tir.is_entry_func": True, "calling_conv": 1} {
  assert((num_args == 3), "fused_divide: num_args should be 3")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let arg2: handle = @tir.tvm_struct_get(args, 2, 12, dtype=handle)
  let arg2.code: int32 = (int32*)arg_type_ids[2]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let T_divide: Pointer(int64) = @tir.tvm_struct_get(arg2, 0, 1, dtype=handle)
  attr [T_divide] "storage_alignment" = 128;
  let arg2.shape: handle = @tir.tvm_struct_get(arg2, 0, 2, dtype=handle)
  let arg2.strides: handle = @tir.tvm_struct_get(arg2, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_divide: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_divide: Expect arg[1] to be pointer")
  assert(((((arg2.code == 3) || (arg2.code == 13)) || (arg2.code == 7)) || (arg2.code == 4)), "fused_divide: Expect arg[2] to be pointer")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg2, 0, 7, dtype=uint16) == 1u16)), "arg2.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg2, 0, 8, dtype=uint64)), "Argument arg2.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg2, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg2, 0, 10, dtype=int32)), "Argument arg2.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg2, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg2, 0, 9, dtype=int32)), "Argument arg2.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg2, 0, 9))")
  attr [0] "compute_scope" = "fused_divide_compute_";
  T_divide[0] = ((int64*)placeholder[0] / (int64*)placeholder_1[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerDeviceStorageAccessInfo
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_divide", "tir.is_entry_func": True, "calling_conv": 1} {
  assert((num_args == 3), "fused_divide: num_args should be 3")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let arg2: handle = @tir.tvm_struct_get(args, 2, 12, dtype=handle)
  let arg2.code: int32 = (int32*)arg_type_ids[2]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let T_divide: Pointer(int64) = @tir.tvm_struct_get(arg2, 0, 1, dtype=handle)
  attr [T_divide] "storage_alignment" = 128;
  let arg2.shape: handle = @tir.tvm_struct_get(arg2, 0, 2, dtype=handle)
  let arg2.strides: handle = @tir.tvm_struct_get(arg2, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_divide: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_divide: Expect arg[1] to be pointer")
  assert(((((arg2.code == 3) || (arg2.code == 13)) || (arg2.code == 7)) || (arg2.code == 4)), "fused_divide: Expect arg[2] to be pointer")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg2, 0, 7, dtype=uint16) == 1u16)), "arg2.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg2, 0, 8, dtype=uint64)), "Argument arg2.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg2, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg2, 0, 10, dtype=int32)), "Argument arg2.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg2, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg2, 0, 9, dtype=int32)), "Argument arg2.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg2, 0, 9))")
  attr [0] "compute_scope" = "fused_divide_compute_";
  T_divide[0] = ((int64*)placeholder[0] / (int64*)placeholder_1[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerCustomDatatypes
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_divide", "tir.is_entry_func": True, "calling_conv": 1} {
  assert((num_args == 3), "fused_divide: num_args should be 3")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let arg2: handle = @tir.tvm_struct_get(args, 2, 12, dtype=handle)
  let arg2.code: int32 = (int32*)arg_type_ids[2]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let T_divide: Pointer(int64) = @tir.tvm_struct_get(arg2, 0, 1, dtype=handle)
  attr [T_divide] "storage_alignment" = 128;
  let arg2.shape: handle = @tir.tvm_struct_get(arg2, 0, 2, dtype=handle)
  let arg2.strides: handle = @tir.tvm_struct_get(arg2, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_divide: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_divide: Expect arg[1] to be pointer")
  assert(((((arg2.code == 3) || (arg2.code == 13)) || (arg2.code == 7)) || (arg2.code == 4)), "fused_divide: Expect arg[2] to be pointer")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg2, 0, 7, dtype=uint16) == 1u16)), "arg2.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg2, 0, 8, dtype=uint64)), "Argument arg2.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg2, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg2, 0, 10, dtype=int32)), "Argument arg2.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg2, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg2, 0, 9, dtype=int32)), "Argument arg2.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg2, 0, 9))")
  attr [0] "compute_scope" = "fused_divide_compute_";
  T_divide[0] = ((int64*)placeholder[0] / (int64*)placeholder_1[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerIntrin
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_divide", "tir.is_entry_func": True, "calling_conv": 1} {
  assert((num_args == 3), "fused_divide: num_args should be 3")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let arg2: handle = @tir.tvm_struct_get(args, 2, 12, dtype=handle)
  let arg2.code: int32 = (int32*)arg_type_ids[2]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let T_divide: Pointer(int64) = @tir.tvm_struct_get(arg2, 0, 1, dtype=handle)
  attr [T_divide] "storage_alignment" = 128;
  let arg2.shape: handle = @tir.tvm_struct_get(arg2, 0, 2, dtype=handle)
  let arg2.strides: handle = @tir.tvm_struct_get(arg2, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_divide: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_divide: Expect arg[1] to be pointer")
  assert(((((arg2.code == 3) || (arg2.code == 13)) || (arg2.code == 7)) || (arg2.code == 4)), "fused_divide: Expect arg[2] to be pointer")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg2, 0, 7, dtype=uint16) == 1u16)), "arg2.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg2, 0, 8, dtype=uint64)), "Argument arg2.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg2, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg2, 0, 10, dtype=int32)), "Argument arg2.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg2, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg2, 0, 9, dtype=int32)), "Argument arg2.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg2, 0, 9))")
  attr [0] "compute_scope" = "fused_divide_compute_";
  T_divide[0] = ((int64*)placeholder[0] / (int64*)placeholder_1[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.CombineContextCall
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_divide", "tir.is_entry_func": True, "calling_conv": 1} {
  assert((num_args == 3), "fused_divide: num_args should be 3")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let arg2: handle = @tir.tvm_struct_get(args, 2, 12, dtype=handle)
  let arg2.code: int32 = (int32*)arg_type_ids[2]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let T_divide: Pointer(int64) = @tir.tvm_struct_get(arg2, 0, 1, dtype=handle)
  attr [T_divide] "storage_alignment" = 128;
  let arg2.shape: handle = @tir.tvm_struct_get(arg2, 0, 2, dtype=handle)
  let arg2.strides: handle = @tir.tvm_struct_get(arg2, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_divide: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_divide: Expect arg[1] to be pointer")
  assert(((((arg2.code == 3) || (arg2.code == 13)) || (arg2.code == 7)) || (arg2.code == 4)), "fused_divide: Expect arg[2] to be pointer")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg2, 0, 4, dtype=int32)), "arg2.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg2, 0, 7, dtype=uint16) == 1u16)), "arg2.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg2, 0, 8, dtype=uint64)), "Argument arg2.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg2, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg2, 0, 10, dtype=int32)), "Argument arg2.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg2, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg2, 0, 9, dtype=int32)), "Argument arg2.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg2, 0, 9))")
  attr [0] "compute_scope" = "fused_divide_compute_";
  T_divide[0] = ((int64*)placeholder[0] / (int64*)placeholder_1[0])
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass FoldConstant
type Storage {
  
}

def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  let %in_shape_0: Tensor[(4), int64] = vm.shape_of(%x, meta[relay.attrs.ShapeOfAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %storage_0: Storage[] = memory.alloc_storage(32 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][0]) /* ty=Storage[] */;
  let %tensor_0: Tensor[(4), int64] = memory.alloc_tensor(%storage_0, 0 /* ty=int64 */, meta[relay.Constant][0] /* ty=Tensor[(1), int64] */, meta[relay.attrs.AllocTensorAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %shape_func_out_0: Tensor[(4), int64] = %tensor_0;
  %0 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  %1 = (%in_shape_0,);
  %2 = (%shape_func_out_0,);
  let %shape_func: () = vm.shape_func(%0, %1, %2, meta[relay.attrs.ShapeFuncAttrs][0]) /* ty=() */;
  %3 = prod(%shape_func_out_0) /* ty=int64 */;
  %4 = multiply(%3, 4 /* ty=int64 */) /* ty=int64 */;
  let %storage_01: Storage[] = memory.alloc_storage(%4, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][1]) /* ty=Storage[] */;
  let %out_0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = memory.alloc_tensor(%storage_01, 0 /* ty=int64 */, %shape_func_out_0, meta[relay.attrs.AllocTensorAttrs][1]) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */;
  %5 = (%x,);
  %6 = (%out_0,);
  let %x1: () = vm.invoke_tvm_op(%0, %5, %6) /* ty=() */;
  let %x2: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %out_0;
  %x2
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass FuseOps
type Storage {
  
}

def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  let %in_shape_0: Tensor[(4), int64] = vm.shape_of(%x, meta[relay.attrs.ShapeOfAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %storage_0: Storage[] = memory.alloc_storage(32 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][0]) /* ty=Storage[] */;
  let %tensor_0: Tensor[(4), int64] = memory.alloc_tensor(%storage_0, 0 /* ty=int64 */, meta[relay.Constant][0] /* ty=Tensor[(1), int64] */, meta[relay.attrs.AllocTensorAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %shape_func_out_0: Tensor[(4), int64] = %tensor_0;
  %0 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  %1 = (%in_shape_0,);
  %2 = (%shape_func_out_0,);
  let %shape_func: () = vm.shape_func(%0, %1, %2, meta[relay.attrs.ShapeFuncAttrs][0]) /* ty=() */;
  %3 = fn (%p02: Tensor[(4), int64], Primitive=1) -> int64 {
    prod(%p02) /* ty=int64 */
  };
  %4 = %3(%shape_func_out_0) /* ty=int64 */;
  %5 = fn (%p01: int64, Primitive=1) -> int64 {
    multiply(%p01, 4 /* ty=int64 */) /* ty=int64 */
  };
  %6 = %5(%4) /* ty=int64 */;
  let %storage_01: Storage[] = memory.alloc_storage(%6, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][1]) /* ty=Storage[] */;
  let %out_0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = memory.alloc_tensor(%storage_01, 0 /* ty=int64 */, %shape_func_out_0, meta[relay.attrs.AllocTensorAttrs][1]) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */;
  %7 = (%x,);
  %8 = (%out_0,);
  let %x1: () = vm.invoke_tvm_op(%0, %7, %8) /* ty=() */;
  let %x2: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %out_0;
  %x2
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass ManifestAlloc
type Storage {
  
}

def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  let %in_shape_0: Tensor[(4), int64] = vm.shape_of(%x, meta[relay.attrs.ShapeOfAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %storage_0: Storage[] = memory.alloc_storage(32 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][0]) /* ty=Storage[] */;
  let %tensor_0: Tensor[(4), int64] = memory.alloc_tensor(%storage_0, 0 /* ty=int64 */, meta[relay.Constant][0] /* ty=Tensor[(1), int64] */, meta[relay.attrs.AllocTensorAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %shape_func_out_0: Tensor[(4), int64] = %tensor_0;
  %0 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  %1 = (%in_shape_0,);
  %2 = (%shape_func_out_0,);
  let %shape_func: () = vm.shape_func(%0, %1, %2, meta[relay.attrs.ShapeFuncAttrs][0]) /* ty=() */;
  let %storage_01: Storage[] = memory.alloc_storage(8 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][1]) /* ty=Storage[] */;
  let %tensor_01: int64 = memory.alloc_tensor(%storage_01, 0 /* ty=int64 */, meta[relay.Constant][1] /* ty=Tensor[(0), int64] */, meta[relay.attrs.AllocTensorAttrs][1]) /* ty=int64 */;
  %3 = fn (%p01: Tensor[(4), int64], Primitive=1) -> int64 {
    prod(%p01) /* ty=int64 */
  };
  %4 = (%shape_func_out_0,);
  %5 = (%tensor_01,);
  let %x1: () = vm.invoke_tvm_op(%3, %4, %5) /* ty=() */;
  let %storage_02: Storage[] = memory.alloc_storage(8 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][2]) /* ty=Storage[] */;
  let %tensor_02: int64 = memory.alloc_tensor(%storage_02, 0 /* ty=int64 */, meta[relay.Constant][2] /* ty=Tensor[(0), int64] */, meta[relay.attrs.AllocTensorAttrs][2]) /* ty=int64 */;
  %6 = fn (%p02: int64, Primitive=1) -> int64 {
    multiply(%p02, 4 /* ty=int64 */) /* ty=int64 */
  };
  %7 = (%tensor_01,);
  %8 = (%tensor_02,);
  let %x2: () = vm.invoke_tvm_op(%6, %7, %8) /* ty=() */;
  let %storage_03: Storage[] = memory.alloc_storage(%tensor_02, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][3]) /* ty=Storage[] */;
  let %out_0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = memory.alloc_tensor(%storage_03, 0 /* ty=int64 */, %shape_func_out_0, meta[relay.attrs.AllocTensorAttrs][3]) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */;
  %9 = (%x,);
  %10 = (%out_0,);
  let %x3: () = vm.invoke_tvm_op(%0, %9, %10) /* ty=() */;
  let %x4: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %out_0;
  %x4
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass FuseOps
type Storage {
  
}

def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  let %in_shape_0: Tensor[(4), int64] = vm.shape_of(%x, meta[relay.attrs.ShapeOfAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %storage_0: Storage[] = memory.alloc_storage(32 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][0]) /* ty=Storage[] */;
  let %tensor_0: Tensor[(4), int64] = memory.alloc_tensor(%storage_0, 0 /* ty=int64 */, meta[relay.Constant][0] /* ty=Tensor[(1), int64] */, meta[relay.attrs.AllocTensorAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %shape_func_out_0: Tensor[(4), int64] = %tensor_0;
  %0 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  %1 = (%in_shape_0,);
  %2 = (%shape_func_out_0,);
  let %shape_func: () = vm.shape_func(%0, %1, %2, meta[relay.attrs.ShapeFuncAttrs][0]) /* ty=() */;
  let %storage_01: Storage[] = memory.alloc_storage(8 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][1]) /* ty=Storage[] */;
  let %tensor_01: int64 = memory.alloc_tensor(%storage_01, 0 /* ty=int64 */, meta[relay.Constant][1] /* ty=Tensor[(0), int64] */, meta[relay.attrs.AllocTensorAttrs][1]) /* ty=int64 */;
  %3 = fn (%p01: Tensor[(4), int64], Primitive=1) -> int64 {
    prod(%p01) /* ty=int64 */
  };
  %4 = (%shape_func_out_0,);
  %5 = (%tensor_01,);
  let %x1: () = vm.invoke_tvm_op(%3, %4, %5) /* ty=() */;
  let %storage_02: Storage[] = memory.alloc_storage(8 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][2]) /* ty=Storage[] */;
  let %tensor_02: int64 = memory.alloc_tensor(%storage_02, 0 /* ty=int64 */, meta[relay.Constant][2] /* ty=Tensor[(0), int64] */, meta[relay.attrs.AllocTensorAttrs][2]) /* ty=int64 */;
  %6 = fn (%p02: int64, Primitive=1) -> int64 {
    multiply(%p02, 4 /* ty=int64 */) /* ty=int64 */
  };
  %7 = (%tensor_01,);
  %8 = (%tensor_02,);
  let %x2: () = vm.invoke_tvm_op(%6, %7, %8) /* ty=() */;
  let %storage_03: Storage[] = memory.alloc_storage(%tensor_02, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][3]) /* ty=Storage[] */;
  let %out_0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = memory.alloc_tensor(%storage_03, 0 /* ty=int64 */, %shape_func_out_0, meta[relay.attrs.AllocTensorAttrs][3]) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */;
  %9 = (%x,);
  %10 = (%out_0,);
  let %x3: () = vm.invoke_tvm_op(%0, %9, %10) /* ty=() */;
  let %x4: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %out_0;
  %x4
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass FoldConstant
type Storage {
  
}

def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  let %in_shape_0: Tensor[(4), int64] = vm.shape_of(%x, meta[relay.attrs.ShapeOfAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %storage_0: Storage[] = memory.alloc_storage(32 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][0]) /* ty=Storage[] */;
  let %tensor_0: Tensor[(4), int64] = memory.alloc_tensor(%storage_0, 0 /* ty=int64 */, meta[relay.Constant][0] /* ty=Tensor[(1), int64] */, meta[relay.attrs.AllocTensorAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %shape_func_out_0: Tensor[(4), int64] = %tensor_0;
  %0 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  %1 = (%in_shape_0,);
  %2 = (%shape_func_out_0,);
  let %shape_func: () = vm.shape_func(%0, %1, %2, meta[relay.attrs.ShapeFuncAttrs][0]) /* ty=() */;
  let %storage_01: Storage[] = memory.alloc_storage(8 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][1]) /* ty=Storage[] */;
  let %tensor_01: int64 = memory.alloc_tensor(%storage_01, 0 /* ty=int64 */, meta[relay.Constant][1] /* ty=Tensor[(0), int64] */, meta[relay.attrs.AllocTensorAttrs][1]) /* ty=int64 */;
  %3 = fn (%p01: Tensor[(4), int64], Primitive=1) -> int64 {
    prod(%p01) /* ty=int64 */
  };
  %4 = (%shape_func_out_0,);
  %5 = (%tensor_01,);
  let %x1: () = vm.invoke_tvm_op(%3, %4, %5) /* ty=() */;
  let %storage_02: Storage[] = memory.alloc_storage(8 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][2]) /* ty=Storage[] */;
  let %tensor_02: int64 = memory.alloc_tensor(%storage_02, 0 /* ty=int64 */, meta[relay.Constant][2] /* ty=Tensor[(0), int64] */, meta[relay.attrs.AllocTensorAttrs][2]) /* ty=int64 */;
  %6 = fn (%p02: int64, Primitive=1) -> int64 {
    multiply(%p02, 4 /* ty=int64 */) /* ty=int64 */
  };
  %7 = (%tensor_01,);
  %8 = (%tensor_02,);
  let %x2: () = vm.invoke_tvm_op(%6, %7, %8) /* ty=() */;
  let %storage_03: Storage[] = memory.alloc_storage(%tensor_02, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][3]) /* ty=Storage[] */;
  let %out_0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = memory.alloc_tensor(%storage_03, 0 /* ty=int64 */, %shape_func_out_0, meta[relay.attrs.AllocTensorAttrs][3]) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */;
  %9 = (%x,);
  %10 = (%out_0,);
  let %x3: () = vm.invoke_tvm_op(%0, %9, %10) /* ty=() */;
  let %x4: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %out_0;
  %x4
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass FuseOps
type Storage {
  
}

def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  let %in_shape_0: Tensor[(4), int64] = vm.shape_of(%x, meta[relay.attrs.ShapeOfAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %storage_0: Storage[] = memory.alloc_storage(32 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][0]) /* ty=Storage[] */;
  let %tensor_0: Tensor[(4), int64] = memory.alloc_tensor(%storage_0, 0 /* ty=int64 */, meta[relay.Constant][0] /* ty=Tensor[(1), int64] */, meta[relay.attrs.AllocTensorAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %shape_func_out_0: Tensor[(4), int64] = %tensor_0;
  %0 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  %1 = (%in_shape_0,);
  %2 = (%shape_func_out_0,);
  let %shape_func: () = vm.shape_func(%0, %1, %2, meta[relay.attrs.ShapeFuncAttrs][0]) /* ty=() */;
  let %storage_01: Storage[] = memory.alloc_storage(8 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][1]) /* ty=Storage[] */;
  let %tensor_01: int64 = memory.alloc_tensor(%storage_01, 0 /* ty=int64 */, meta[relay.Constant][1] /* ty=Tensor[(0), int64] */, meta[relay.attrs.AllocTensorAttrs][1]) /* ty=int64 */;
  %3 = fn (%p01: Tensor[(4), int64], Primitive=1) -> int64 {
    prod(%p01) /* ty=int64 */
  };
  %4 = (%shape_func_out_0,);
  %5 = (%tensor_01,);
  let %x1: () = vm.invoke_tvm_op(%3, %4, %5) /* ty=() */;
  let %storage_02: Storage[] = memory.alloc_storage(8 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][2]) /* ty=Storage[] */;
  let %tensor_02: int64 = memory.alloc_tensor(%storage_02, 0 /* ty=int64 */, meta[relay.Constant][2] /* ty=Tensor[(0), int64] */, meta[relay.attrs.AllocTensorAttrs][2]) /* ty=int64 */;
  %6 = fn (%p02: int64, Primitive=1) -> int64 {
    multiply(%p02, 4 /* ty=int64 */) /* ty=int64 */
  };
  %7 = (%tensor_01,);
  %8 = (%tensor_02,);
  let %x2: () = vm.invoke_tvm_op(%6, %7, %8) /* ty=() */;
  let %storage_03: Storage[] = memory.alloc_storage(%tensor_02, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][3]) /* ty=Storage[] */;
  let %out_0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = memory.alloc_tensor(%storage_03, 0 /* ty=int64 */, %shape_func_out_0, meta[relay.attrs.AllocTensorAttrs][3]) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */;
  %9 = (%x,);
  %10 = (%out_0,);
  let %x3: () = vm.invoke_tvm_op(%0, %9, %10) /* ty=() */;
  let %x4: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %out_0;
  %x4
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass ManifestAlloc
type Storage {
  
}

def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  let %in_shape_0: Tensor[(4), int64] = vm.shape_of(%x, meta[relay.attrs.ShapeOfAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %storage_0: Storage[] = memory.alloc_storage(32 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][0]) /* ty=Storage[] */;
  let %tensor_0: Tensor[(4), int64] = memory.alloc_tensor(%storage_0, 0 /* ty=int64 */, meta[relay.Constant][0] /* ty=Tensor[(1), int64] */, meta[relay.attrs.AllocTensorAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %shape_func_out_0: Tensor[(4), int64] = %tensor_0;
  %0 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  %1 = (%in_shape_0,);
  %2 = (%shape_func_out_0,);
  let %shape_func: () = vm.shape_func(%0, %1, %2, meta[relay.attrs.ShapeFuncAttrs][0]) /* ty=() */;
  let %storage_01: Storage[] = memory.alloc_storage(8 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][1]) /* ty=Storage[] */;
  let %tensor_01: int64 = memory.alloc_tensor(%storage_01, 0 /* ty=int64 */, meta[relay.Constant][1] /* ty=Tensor[(0), int64] */, meta[relay.attrs.AllocTensorAttrs][1]) /* ty=int64 */;
  %3 = fn (%p01: Tensor[(4), int64], Primitive=1) -> int64 {
    prod(%p01) /* ty=int64 */
  };
  %4 = (%shape_func_out_0,);
  %5 = (%tensor_01,);
  let %x1: () = vm.invoke_tvm_op(%3, %4, %5) /* ty=() */;
  let %storage_02: Storage[] = memory.alloc_storage(8 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][2]) /* ty=Storage[] */;
  let %tensor_02: int64 = memory.alloc_tensor(%storage_02, 0 /* ty=int64 */, meta[relay.Constant][2] /* ty=Tensor[(0), int64] */, meta[relay.attrs.AllocTensorAttrs][2]) /* ty=int64 */;
  %6 = fn (%p02: int64, Primitive=1) -> int64 {
    multiply(%p02, 4 /* ty=int64 */) /* ty=int64 */
  };
  %7 = (%tensor_01,);
  %8 = (%tensor_02,);
  let %x2: () = vm.invoke_tvm_op(%6, %7, %8) /* ty=() */;
  let %storage_03: Storage[] = memory.alloc_storage(%tensor_02, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][3]) /* ty=Storage[] */;
  let %out_0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = memory.alloc_tensor(%storage_03, 0 /* ty=int64 */, %shape_func_out_0, meta[relay.attrs.AllocTensorAttrs][3]) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */;
  %9 = (%x,);
  %10 = (%out_0,);
  let %x3: () = vm.invoke_tvm_op(%0, %9, %10) /* ty=() */;
  let %x4: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %out_0;
  %x4
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass FoldConstant
type Storage {
  
}

def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  let %in_shape_0: Tensor[(4), int64] = vm.shape_of(%x, meta[relay.attrs.ShapeOfAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %storage_0: Storage[] = memory.alloc_storage(32 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][0]) /* ty=Storage[] */;
  let %tensor_0: Tensor[(4), int64] = memory.alloc_tensor(%storage_0, 0 /* ty=int64 */, meta[relay.Constant][0] /* ty=Tensor[(1), int64] */, meta[relay.attrs.AllocTensorAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %shape_func_out_0: Tensor[(4), int64] = %tensor_0;
  %0 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  %1 = (%in_shape_0,);
  %2 = (%shape_func_out_0,);
  let %shape_func: () = vm.shape_func(%0, %1, %2, meta[relay.attrs.ShapeFuncAttrs][0]) /* ty=() */;
  let %storage_01: Storage[] = memory.alloc_storage(8 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][1]) /* ty=Storage[] */;
  let %tensor_01: int64 = memory.alloc_tensor(%storage_01, 0 /* ty=int64 */, meta[relay.Constant][1] /* ty=Tensor[(0), int64] */, meta[relay.attrs.AllocTensorAttrs][1]) /* ty=int64 */;
  %3 = fn (%p01: Tensor[(4), int64], Primitive=1) -> int64 {
    prod(%p01) /* ty=int64 */
  };
  %4 = (%shape_func_out_0,);
  %5 = (%tensor_01,);
  let %x1: () = vm.invoke_tvm_op(%3, %4, %5) /* ty=() */;
  let %storage_02: Storage[] = memory.alloc_storage(8 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][2]) /* ty=Storage[] */;
  let %tensor_02: int64 = memory.alloc_tensor(%storage_02, 0 /* ty=int64 */, meta[relay.Constant][2] /* ty=Tensor[(0), int64] */, meta[relay.attrs.AllocTensorAttrs][2]) /* ty=int64 */;
  %6 = fn (%p02: int64, Primitive=1) -> int64 {
    multiply(%p02, 4 /* ty=int64 */) /* ty=int64 */
  };
  %7 = (%tensor_01,);
  %8 = (%tensor_02,);
  let %x2: () = vm.invoke_tvm_op(%6, %7, %8) /* ty=() */;
  let %storage_03: Storage[] = memory.alloc_storage(%tensor_02, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][3]) /* ty=Storage[] */;
  let %out_0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = memory.alloc_tensor(%storage_03, 0 /* ty=int64 */, %shape_func_out_0, meta[relay.attrs.AllocTensorAttrs][3]) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */;
  %9 = (%x,);
  %10 = (%out_0,);
  let %x3: () = vm.invoke_tvm_op(%0, %9, %10) /* ty=() */;
  let %x4: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %out_0;
  %x4
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass sequential
type Storage {
  
}

def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  let %in_shape_0: Tensor[(4), int64] = vm.shape_of(%x, meta[relay.attrs.ShapeOfAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %storage_0: Storage[] = memory.alloc_storage(32 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][0]) /* ty=Storage[] */;
  let %tensor_0: Tensor[(4), int64] = memory.alloc_tensor(%storage_0, 0 /* ty=int64 */, meta[relay.Constant][0] /* ty=Tensor[(1), int64] */, meta[relay.attrs.AllocTensorAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %shape_func_out_0: Tensor[(4), int64] = %tensor_0;
  %0 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  %1 = (%in_shape_0,);
  %2 = (%shape_func_out_0,);
  let %shape_func: () = vm.shape_func(%0, %1, %2, meta[relay.attrs.ShapeFuncAttrs][0]) /* ty=() */;
  let %storage_01: Storage[] = memory.alloc_storage(8 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][1]) /* ty=Storage[] */;
  let %tensor_01: int64 = memory.alloc_tensor(%storage_01, 0 /* ty=int64 */, meta[relay.Constant][1] /* ty=Tensor[(0), int64] */, meta[relay.attrs.AllocTensorAttrs][1]) /* ty=int64 */;
  %3 = fn (%p01: Tensor[(4), int64], Primitive=1) -> int64 {
    prod(%p01) /* ty=int64 */
  };
  %4 = (%shape_func_out_0,);
  %5 = (%tensor_01,);
  let %x1: () = vm.invoke_tvm_op(%3, %4, %5) /* ty=() */;
  let %storage_02: Storage[] = memory.alloc_storage(8 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][2]) /* ty=Storage[] */;
  let %tensor_02: int64 = memory.alloc_tensor(%storage_02, 0 /* ty=int64 */, meta[relay.Constant][2] /* ty=Tensor[(0), int64] */, meta[relay.attrs.AllocTensorAttrs][2]) /* ty=int64 */;
  %6 = fn (%p02: int64, Primitive=1) -> int64 {
    multiply(%p02, 4 /* ty=int64 */) /* ty=int64 */
  };
  %7 = (%tensor_01,);
  %8 = (%tensor_02,);
  let %x2: () = vm.invoke_tvm_op(%6, %7, %8) /* ty=() */;
  let %storage_03: Storage[] = memory.alloc_storage(%tensor_02, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][3]) /* ty=Storage[] */;
  let %out_0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = memory.alloc_tensor(%storage_03, 0 /* ty=int64 */, %shape_func_out_0, meta[relay.attrs.AllocTensorAttrs][3]) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */;
  %9 = (%x,);
  %10 = (%out_0,);
  let %x3: () = vm.invoke_tvm_op(%0, %9, %10) /* ty=() */;
  let %x4: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %out_0;
  %x4
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass InferType
type Storage {
  
}

def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  let %in_shape_0: Tensor[(4), int64] = vm.shape_of(%x, meta[relay.attrs.ShapeOfAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %storage_0: Storage[] = memory.alloc_storage(32 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][0]) /* ty=Storage[] */;
  let %tensor_0: Tensor[(4), int64] = memory.alloc_tensor(%storage_0, 0 /* ty=int64 */, meta[relay.Constant][0] /* ty=Tensor[(1), int64] */, meta[relay.attrs.AllocTensorAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %shape_func_out_0: Tensor[(4), int64] = %tensor_0;
  %0 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1) -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  %1 = (%in_shape_0,);
  %2 = (%shape_func_out_0,);
  let %shape_func: () = vm.shape_func(%0, %1, %2, meta[relay.attrs.ShapeFuncAttrs][0]) /* ty=() */;
  let %storage_01: Storage[] = memory.alloc_storage(8 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][1]) /* ty=Storage[] */;
  let %tensor_01: int64 = memory.alloc_tensor(%storage_01, 0 /* ty=int64 */, meta[relay.Constant][1] /* ty=Tensor[(0), int64] */, meta[relay.attrs.AllocTensorAttrs][1]) /* ty=int64 */;
  %3 = fn (%p01: Tensor[(4), int64], Primitive=1) -> int64 {
    prod(%p01) /* ty=int64 */
  };
  %4 = (%shape_func_out_0,);
  %5 = (%tensor_01,);
  let %x1: () = vm.invoke_tvm_op(%3, %4, %5) /* ty=() */;
  let %storage_02: Storage[] = memory.alloc_storage(8 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][2]) /* ty=Storage[] */;
  let %tensor_02: int64 = memory.alloc_tensor(%storage_02, 0 /* ty=int64 */, meta[relay.Constant][2] /* ty=Tensor[(0), int64] */, meta[relay.attrs.AllocTensorAttrs][2]) /* ty=int64 */;
  %6 = fn (%p02: int64, Primitive=1) -> int64 {
    multiply(%p02, 4 /* ty=int64 */) /* ty=int64 */
  };
  %7 = (%tensor_01,);
  %8 = (%tensor_02,);
  let %x2: () = vm.invoke_tvm_op(%6, %7, %8) /* ty=() */;
  let %storage_03: Storage[] = memory.alloc_storage(%tensor_02, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][3]) /* ty=Storage[] */;
  let %out_0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = memory.alloc_tensor(%storage_03, 0 /* ty=int64 */, %shape_func_out_0, meta[relay.attrs.AllocTensorAttrs][3]) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */;
  %9 = (%x,);
  %10 = (%out_0,);
  let %x3: () = vm.invoke_tvm_op(%0, %9, %10) /* ty=() */;
  let %x4: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %out_0;
  %x4
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass LabelOps
type Storage {
  
}

def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], hash="1de15289f6eab5da") -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  let %in_shape_0: Tensor[(4), int64] = vm.shape_of(%x, meta[relay.attrs.ShapeOfAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %storage_0: Storage[] = memory.alloc_storage(32 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][0]) /* ty=Storage[] */;
  let %tensor_0: Tensor[(4), int64] = memory.alloc_tensor(%storage_0, 0 /* ty=int64 */, meta[relay.Constant][0] /* ty=Tensor[(1), int64] */, meta[relay.attrs.AllocTensorAttrs][0]) /* ty=Tensor[(4), int64] */;
  let %shape_func_out_0: Tensor[(4), int64] = %tensor_0;
  %0 = fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1, hash="f9a165078ab8ab77") -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
    nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
  };
  %1 = (%in_shape_0,);
  %2 = (%shape_func_out_0,);
  let %shape_func: () = vm.shape_func(%0, %1, %2, meta[relay.attrs.ShapeFuncAttrs][0]) /* ty=() */;
  let %storage_01: Storage[] = memory.alloc_storage(8 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][1]) /* ty=Storage[] */;
  let %tensor_01: int64 = memory.alloc_tensor(%storage_01, 0 /* ty=int64 */, meta[relay.Constant][1] /* ty=Tensor[(0), int64] */, meta[relay.attrs.AllocTensorAttrs][1]) /* ty=int64 */;
  %3 = fn (%p01: Tensor[(4), int64], Primitive=1, hash="75ec56f3169a1497") -> int64 {
    prod(%p01) /* ty=int64 */
  };
  %4 = (%shape_func_out_0,);
  %5 = (%tensor_01,);
  let %x1: () = vm.invoke_tvm_op(%3, %4, %5) /* ty=() */;
  let %storage_02: Storage[] = memory.alloc_storage(8 /* ty=int64 */, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][2]) /* ty=Storage[] */;
  let %tensor_02: int64 = memory.alloc_tensor(%storage_02, 0 /* ty=int64 */, meta[relay.Constant][2] /* ty=Tensor[(0), int64] */, meta[relay.attrs.AllocTensorAttrs][2]) /* ty=int64 */;
  %6 = fn (%p02: int64, Primitive=1, hash="e2e2680f0ff08f46") -> int64 {
    multiply(%p02, 4 /* ty=int64 */) /* ty=int64 */
  };
  %7 = (%tensor_01,);
  %8 = (%tensor_02,);
  let %x2: () = vm.invoke_tvm_op(%6, %7, %8) /* ty=() */;
  let %storage_03: Storage[] = memory.alloc_storage(%tensor_02, 64 /* ty=int64 */, meta[relay.attrs.AllocStorageAttrs][3]) /* ty=Storage[] */;
  let %out_0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = memory.alloc_tensor(%storage_03, 0 /* ty=int64 */, %shape_func_out_0, meta[relay.attrs.AllocTensorAttrs][3]) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */;
  %9 = (%x,);
  %10 = (%out_0,);
  let %x3: () = vm.invoke_tvm_op(%0, %9, %10) /* ty=() */;
  let %x4: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] = %out_0;
  %x4
}


[14:05:56] /workspace/home/codes/tvm/src/driver/driver_api.cc:139: LOWER INFERBOUND BEFORE
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0, ): range(min=0, ext=4)
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0, range(min=0, ext=4)): range(min=0, ext=4)
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, 3]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, 3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/driver/driver_api.cc:149: Func before opt
[14:05:56] /workspace/home/codes/tvm/src/driver/driver_api.cc:150: primfn(placeholder_1: handle, compute_1: handle) -> ()
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  attr [compute] "realize_scope" = "";
  realize(compute, [0:4], True {
    for (i0: int32, 0, 4) {
      compute[i0] = placeholder[i0]
    }
  })
}
[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectPrefetch
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  attr [compute] "realize_scope" = "";
  realize(compute, [0:4], True {
    for (i0: int32, 0, 4) {
      compute[i0] = placeholder[i0]
    }
  })
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.StorageFlatten
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16Promote
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16CastElimination
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16TypeLowering
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16Legalize
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.NarrowDataType
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LoopPartition
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.VectorizeLoop
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectVirtualThread
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectDoubleBuffer
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.StorageRewrite
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.UnrollLoop
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.RemoveNoOp
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.RewriteUnsafeSelect
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}


[14:05:56] /workspace/home/codes/tvm/src/relay/backend/vm/compiler.cc:548: Lower Function Start
[14:05:56] /workspace/home/codes/tvm/src/relay/backend/vm/compiler.cc:549: fn (%p0: Tensor[(4), int64], Primitive=1, hash="75ec56f3169a1497") -> int64 {
  prod(%p0) /* ty=int64 */
}
[14:05:56] /workspace/home/codes/tvm/src/relay/backend/compile_engine.cc:767: POS1
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(k0, range(min=0, ext=4)): range(min=0, ext=4)
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(k0, ): range(min=0, ext=4)
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(singleton, range(min=0, ext=1)): range(min=0, ext=1)
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k0: int32, IntervalSet[0, 3]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert singleton: int32, IntervalSet[0, 0]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k0: int32, IntervalSet[0, 3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k0: int32, IntervalSet[0, 3]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert singleton: int32, IntervalSet[0, 0]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k0: int32, IntervalSet[0, 3]
[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectPrefetch
primfn(placeholder_1: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, placeholder_red_1: placeholder_red} {
  attr [placeholder_red] "realize_scope" = "";
  realize(placeholder_red, [], True {
    placeholder_red[] = 1i64
    for (k0: int32, 0, 4) {
      placeholder_red[] = (placeholder_red[]*placeholder[k0])
    }
  })
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.StorageFlatten
primfn(placeholder_1: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_2[k0])
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16Promote
primfn(placeholder_1: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_2[k0])
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16CastElimination
primfn(placeholder_1: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_2[k0])
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16TypeLowering
primfn(placeholder_1: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_2[k0])
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16Legalize
primfn(placeholder_1: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_2[k0])
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.NarrowDataType
primfn(placeholder_1: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_2[k0])
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify
primfn(placeholder_1: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_2[k0])
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LoopPartition
primfn(placeholder_1: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_2[k0])
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.VectorizeLoop
primfn(placeholder_1: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_2[k0])
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectVirtualThread
primfn(placeholder_1: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_2[k0])
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectDoubleBuffer
primfn(placeholder_1: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_2[k0])
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.StorageRewrite
primfn(placeholder_1: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_2[k0])
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.UnrollLoop
primfn(placeholder_1: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_2[k0])
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify
primfn(placeholder_1: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_2[k0])
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.RemoveNoOp
primfn(placeholder_1: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_2[k0])
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.RewriteUnsafeSelect
primfn(placeholder_1: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_2[k0])
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.HoistIfThenElse
primfn(placeholder_1: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_2[k0])
  }
}


[14:05:56] /workspace/home/codes/tvm/src/relay/backend/compile_engine.cc:778: POS4
[14:05:56] /workspace/home/codes/tvm/src/relay/backend/vm/compiler.cc:551: Lower Function End
[14:05:56] /workspace/home/codes/tvm/src/relay/backend/vm/compiler.cc:548: Lower Function Start
[14:05:56] /workspace/home/codes/tvm/src/relay/backend/vm/compiler.cc:549: fn (%p0: int64, Primitive=1, hash="e2e2680f0ff08f46") -> int64 {
  multiply(%p0, 4 /* ty=int64 */) /* ty=int64 */
}
[14:05:56] /workspace/home/codes/tvm/src/relay/backend/compile_engine.cc:767: POS1
[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectPrefetch
primfn(placeholder_1: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_1: placeholder, T_multiply_1: T_multiply} {
  attr [T_multiply] "realize_scope" = "";
  realize(T_multiply, [], True {
    T_multiply[] = (placeholder[]*4i64)
  })
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.StorageFlatten
primfn(placeholder_1: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_1: placeholder, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_2[0]*4i64)
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16Promote
primfn(placeholder_1: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_1: placeholder, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_2[0]*4i64)
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16CastElimination
primfn(placeholder_1: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_1: placeholder, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_2[0]*4i64)
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16TypeLowering
primfn(placeholder_1: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_1: placeholder, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_2[0]*4i64)
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16Legalize
primfn(placeholder_1: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_1: placeholder, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_2[0]*4i64)
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.NarrowDataType
primfn(placeholder_1: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_1: placeholder, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_2[0]*4i64)
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify
primfn(placeholder_1: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_1: placeholder, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_2[0]*4i64)
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LoopPartition
primfn(placeholder_1: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_1: placeholder, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_2[0]*4i64)
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.VectorizeLoop
primfn(placeholder_1: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_1: placeholder, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_2[0]*4i64)
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectVirtualThread
primfn(placeholder_1: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_1: placeholder, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_2[0]*4i64)
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectDoubleBuffer
primfn(placeholder_1: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_1: placeholder, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_2[0]*4i64)
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.StorageRewrite
primfn(placeholder_1: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_1: placeholder, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_2[0]*4i64)
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.UnrollLoop
primfn(placeholder_1: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_1: placeholder, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_2[0]*4i64)
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify
primfn(placeholder_1: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_1: placeholder, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_2[0]*4i64)
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.RemoveNoOp
primfn(placeholder_1: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_1: placeholder, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_2[0]*4i64)
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.RewriteUnsafeSelect
primfn(placeholder_1: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_1: placeholder, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_2[0]*4i64)
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.HoistIfThenElse
primfn(placeholder_1: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_1: placeholder, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_2[0]*4i64)
}


[14:05:56] /workspace/home/codes/tvm/src/relay/backend/compile_engine.cc:778: POS4
[14:05:56] /workspace/home/codes/tvm/src/relay/backend/vm/compiler.cc:551: Lower Function End
[14:05:56] /workspace/home/codes/tvm/src/relay/backend/vm/compiler.cc:548: Lower Function Start
[14:05:56] /workspace/home/codes/tvm/src/relay/backend/vm/compiler.cc:549: fn (%p0: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32], Primitive=1, hash="f9a165078ab8ab77") -> Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] {
  nn.softmax(%p0) /* ty=Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32] */
}

[14:05:56] /workspace/home/codes/tvm/src/relay/backend/compile_engine.cc:767: POS1
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (floormod((((d0: int32*d1: int32)*d2: int32)*d3: int32), 512) == 0)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0: int32]: IntervalSet[0, (d0 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove ((d0: int32 - 1) <= (d0 - 1))
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d1, d1], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i1: int32]: IntervalSet[0, (d1 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove ((d1: int32 - 1) <= (d1 - 1))
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d2, d2], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i2: int32]: IntervalSet[0, (d2 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove ((d2: int32 - 1) <= (d2 - 1))
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (floormod(((d0: int32*d1: int32)*d2: int32), 512) == 0)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0: int32]: IntervalSet[0, (d0 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove ((d0: int32 - 1) <= (d0 - 1))
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d1, d1], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i1: int32]: IntervalSet[0, (d1 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove ((d1: int32 - 1) <= (d1 - 1))
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d2, d2], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i2: int32]: IntervalSet[0, (d2 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove ((d2: int32 - 1) <= (d2 - 1))
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var k: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d3, d3], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ k: int32]: IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove ((d3: int32 - 1) <= (d3 - 1))
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0: int32]: IntervalSet[0, (d0 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove ((d0: int32 - 1) <= (d0 - 1))
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d1, d1], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i1: int32]: IntervalSet[0, (d1 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove ((d1: int32 - 1) <= (d1 - 1))
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d2, d2], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i2: int32]: IntervalSet[0, (d2 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove ((d2: int32 - 1) <= (d2 - 1))
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d3, d3], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i3: int32]: IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove ((d3: int32 - 1) <= (d3 - 1))
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (floormod((((d0: int32*d1: int32)*d2: int32)*d3: int32), 512) == 0)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i0: int32]: IntervalSet[0, (d0 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove ((d0: int32 - 1) <= (d0 - 1))
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d1, d1], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i1: int32]: IntervalSet[0, (d1 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove ((d1: int32 - 1) <= (d1 - 1))
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var i2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d2, d2], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ i2: int32]: IntervalSet[0, (d2 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove ((d2: int32 - 1) <= (d2 - 1))
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (floormod(((d0: int32*d1: int32)*d2: int32), 512) == 0)
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(threadIdx.x, , threadIdx.x): range(min=0, ext=512)
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(k, ): range(min=0, ext=d3)
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0.i1.fused.i2.fused.inner, ): range(min=0, ext=512)
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i2, range(min=0, ext=d2)): range(min=0, ext=d2)
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i1, range(min=0, ext=d1)): range(min=0, ext=d1)
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(blockIdx.x, , blockIdx.x): range(min=0, ext=floordiv(((((d0*d1)*d2)*d3) + 511), 512))
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0.i1.fused.i2.fused, ): range(min=0, ext=((d0*d1)*d2))
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0.i1.fused.i2.fused.i3.fused.outer, ): range(min=0, ext=floordiv(((((d0*d1)*d2)*d3) + 511), 512))
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0.i1.fused.i2.fused.i3.fused.inner, ): range(min=0, ext=512)
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0.i1.fused.i2.fused, ): range(min=0, ext=((d0*d1)*d2))
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0.i1.fused, ): range(min=0, ext=(d0*d1))
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i3, range(min=0, ext=d3)): range(min=0, ext=d3)
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(threadIdx.x, , threadIdx.x): range(min=0, ext=512)
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0.i1.fused.i2.fused.i3.fused.inner, ): range(min=0, ext=512)
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(blockIdx.x, , blockIdx.x): range(min=0, ext=floordiv((((d0*d1)*d2) + 511), 512))
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0.i1.fused.i2.fused.outer, ): range(min=0, ext=floordiv((((d0*d1)*d2) + 511), 512))
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0.i1.fused, ): range(min=0, ext=(d0*d1))
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i1, range(min=0, ext=d1)): range(min=0, ext=d1)
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(threadIdx.x, , threadIdx.x): range(min=0, ext=512)
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0.i1.fused.i2.fused.i3.fused, ): range(min=0, ext=(((d0*d1)*d2)*d3))
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(blockIdx.x, , blockIdx.x): range(min=0, ext=floordiv(((((d0*d1)*d2)*d3) + 511), 512))
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0.i1.fused, ): range(min=0, ext=(d0*d1))
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0, range(min=0, ext=d0)): range(min=0, ext=d0)
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0.i1.fused.i2.fused.i3.fused, ): range(min=0, ext=(((d0*d1)*d2)*d3))
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i1, range(min=0, ext=d1)): range(min=0, ext=d1)
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i3, range(min=0, ext=d3)): range(min=0, ext=d3)
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(k, range(min=0, ext=d3)): range(min=0, ext=d3)
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i2, range(min=0, ext=d2)): range(min=0, ext=d2)
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0.i1.fused.i2.fused.outer, ): range(min=0, ext=floordiv((((d0*d1)*d2) + 511), 512))
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0.i1.fused.i2.fused, ): range(min=0, ext=((d0*d1)*d2))
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(threadIdx.x, , threadIdx.x): range(min=0, ext=512)
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0.i1.fused, ): range(min=0, ext=(d0*d1))
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(k, range(min=0, ext=d3)): range(min=0, ext=d3)
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0, range(min=0, ext=d0)): range(min=0, ext=d0)
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0, range(min=0, ext=d0)): range(min=0, ext=d0)
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(blockIdx.x, , blockIdx.x): range(min=0, ext=floordiv((((d0*d1)*d2) + 511), 512))
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i1, range(min=0, ext=d1)): range(min=0, ext=d1)
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i2, range(min=0, ext=d2)): range(min=0, ext=d2)
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0.i1.fused.i2.fused.i3.fused.outer, ): range(min=0, ext=floordiv(((((d0*d1)*d2)*d3) + 511), 512))
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i2, range(min=0, ext=d2)): range(min=0, ext=d2)
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0.i1.fused.i2.fused, ): range(min=0, ext=((d0*d1)*d2))
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0, range(min=0, ext=d0)): range(min=0, ext=d0)
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(i0.i1.fused.i2.fused.inner, ): range(min=0, ext=512)
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/bound.cc:256: iter_var(k, ): range(min=0, ext=d3)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove ((((d0: int32*d1: int32)*d2: int32)*d3: int32) == (512*floordiv(((((d0*d1)*d2)*d3) + 511), 512)))
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, (d0 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, (d2 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, (d2 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, (d2 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused: int32, IntervalSet[0, (((d0*d1)*d2) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, (d1 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, (d2 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, (d1 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused: int32, IntervalSet[0, (((d0*d1)*d2) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, (d1 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert threadIdx.x: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, (d0 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.i3.fused.inner: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert blockIdx.x: int32, IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert blockIdx.x: int32, IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.inner: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused: int32, IntervalSet[0, (((d0*d1)*d2) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i3: int32, IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.i3.fused: int32, IntervalSet[0, ((((d0*d1)*d2)*d3) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, (d0 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused: int32, IntervalSet[0, ((d0*d1) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.i3.fused.inner: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.i3.fused: int32, IntervalSet[0, ((((d0*d1)*d2)*d3) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i3: int32, IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert blockIdx.x: int32, IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused: int32, IntervalSet[0, (((d0*d1)*d2) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.i3.fused.outer: int32, IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused: int32, IntervalSet[0, ((d0*d1) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.outer: int32, IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused: int32, IntervalSet[0, ((d0*d1) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.outer: int32, IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, (d1 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, (d0 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert threadIdx.x: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert threadIdx.x: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert blockIdx.x: int32, IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.i3.fused.outer: int32, IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert threadIdx.x: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused: int32, IntervalSet[0, ((d0*d1) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.inner: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, 511], b after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, (511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512))], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2), floordiv(select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2)), select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2), floordiv(select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2)), select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(select((d2 >= 0), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2), floordiv(select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2)), d1), floordiv(select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2)), d1)), select((d1 >= 0), floordiv(select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2)), d1), floordiv(select((d2 >= 0), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2), floordiv(select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2)), d1))]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:558: value: floordiv(floordiv(floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d3: int32), d2: int32), d1: int32), vmax: select((d1: int32 >= 0), floordiv(select((d2: int32 >= 0), floordiv(select((d3: int32 >= 0), floordiv((511 + ((floordiv(((((d0: int32*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2)), d1), floordiv(select((d2 >= 0), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2), floordiv(select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2)), d1))
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (select((d1: int32 >= 0), floordiv(select((d2: int32 >= 0), floordiv(select((d3: int32 >= 0), floordiv((511 + ((floordiv(((((d0: int32*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2)), d1), floordiv(select((d2 >= 0), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2), floordiv(select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2)), d1)) < d0)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, 511], b after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, (511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512))], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2), floordiv(select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2)), select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2), floordiv(select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2)), select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d1: int32, Bound: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d1 >= 0), d1, (0 - d1)) - 1)), (select((d1 >= 0), d1, (0 - d1)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:558: value: floormod(floordiv(floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d3: int32), d2: int32), d1: int32), vmax: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove ((select((d1: int32 >= 0), d1, (0 - d1)) - 1) < d1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, 511], b after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, (511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512))], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d2: int32, Bound: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d2 >= 0), d2, (0 - d2)) - 1)), (select((d2 >= 0), d2, (0 - d2)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:558: value: floormod(floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d3: int32), d2: int32), vmax: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove ((select((d2: int32 >= 0), d2, (0 - d2)) - 1) < d2)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, 511], b after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, (511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512))], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d3: int32, Bound: (select((d3: int32 >= 0), d3, (0 - d3)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d3 >= 0), d3, (0 - d3)) - 1)), (select((d3 >= 0), d3, (0 - d3)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:558: value: floormod((threadIdx.x: int32 + (blockIdx.x: int32*512)), d3: int32), vmax: (select((d3: int32 >= 0), d3, (0 - d3)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove ((select((d3: int32 >= 0), d3, (0 - d3)) - 1) < d3)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, 511], b after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, (511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512))], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2), floordiv(select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2)), select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2))]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:558: value: floordiv(floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d3: int32), d2: int32), vmax: select((d2: int32 >= 0), floordiv(select((d3: int32 >= 0), floordiv((511 + ((floordiv(((((d0: int32*d1: int32)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2))
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (select((d2: int32 >= 0), floordiv(select((d3: int32 >= 0), floordiv((511 + ((floordiv(((((d0: int32*d1: int32)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2)) < (d0*d1))
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, 511], b after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, (511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512))], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:558: value: floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d3: int32), vmax: select((d3: int32 >= 0), floordiv((511 + ((floordiv(((((d0: int32*d1: int32)*d2: int32)*d3) + 511), 512) - 1)*512)), d3), 0)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (select((d3: int32 >= 0), floordiv((511 + ((floordiv(((((d0: int32*d1: int32)*d2: int32)*d3) + 511), 512) - 1)*512)), d3), 0) < ((d0*d1)*d2))
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, 511], b after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, (511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512))]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:558: value: (threadIdx.x: int32 + (blockIdx.x: int32*512)), vmax: (511 + ((floordiv(((((d0: int32*d1: int32)*d2: int32)*d3: int32) + 511), 512) - 1)*512))
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove ((511 + ((floordiv(((((d0: int32*d1: int32)*d2: int32)*d3: int32) + 511), 512) - 1)*512)) < (((d0*d1)*d2)*d3))
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove (d0: int32 == d0)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove (d1: int32 == d1)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove (d2: int32 == d2)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove (d3: int32 == d3)
[14:05:56] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floordiv(floordiv(floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d3: int32), d2: int32), d1: int32) < d0: int32)
[14:05:56] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floormod(floordiv(floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d3: int32), d2: int32), d1: int32) < d1)
[14:05:56] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floormod(floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d3: int32), d2: int32) < d2)
[14:05:56] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floormod((threadIdx.x: int32 + (blockIdx.x: int32*512)), d3: int32) < d3)
[14:05:56] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floordiv(floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d3: int32), d2: int32) < (d0: int32*d1: int32))
[14:05:56] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d3: int32) < ((d0: int32*d1: int32)*d2: int32))
[14:05:56] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! ((threadIdx.x: int32 + (blockIdx.x: int32*512)) < (((d0: int32*d1: int32)*d2: int32)*d3: int32))
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (((d0: int32*d1: int32)*d2: int32) == (512*floordiv((((d0*d1)*d2) + 511), 512)))
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, (d0 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, (d2 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, (d2 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, (d2 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused: int32, IntervalSet[0, (((d0*d1)*d2) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, (d1 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, (d2 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, (d1 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused: int32, IntervalSet[0, (((d0*d1)*d2) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, (d1 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert threadIdx.x: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, (d0 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.i3.fused.inner: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert blockIdx.x: int32, IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert blockIdx.x: int32, IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.inner: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused: int32, IntervalSet[0, (((d0*d1)*d2) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i3: int32, IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.i3.fused: int32, IntervalSet[0, ((((d0*d1)*d2)*d3) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, (d0 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused: int32, IntervalSet[0, ((d0*d1) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.i3.fused.inner: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.i3.fused: int32, IntervalSet[0, ((((d0*d1)*d2)*d3) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i3: int32, IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert blockIdx.x: int32, IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused: int32, IntervalSet[0, (((d0*d1)*d2) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.i3.fused.outer: int32, IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused: int32, IntervalSet[0, ((d0*d1) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.outer: int32, IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused: int32, IntervalSet[0, ((d0*d1) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.outer: int32, IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, (d1 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, (d0 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert threadIdx.x: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert threadIdx.x: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert blockIdx.x: int32, IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.i3.fused.outer: int32, IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert threadIdx.x: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused: int32, IntervalSet[0, ((d0*d1) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.inner: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, 511], b after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, (511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2)), select((d2 >= 0), floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2)), select((d2 >= 0), floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2), 0)], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(select((d2 >= 0), 0, floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2)), d1), floordiv(select((d2 >= 0), floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2), 0), d1)), select((d1 >= 0), floordiv(select((d2 >= 0), floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2), 0), d1), floordiv(select((d2 >= 0), 0, floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2)), d1))]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:558: value: floordiv(floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d2: int32), d1: int32), vmax: select((d1: int32 >= 0), floordiv(select((d2: int32 >= 0), floordiv((511 + ((floordiv((((d0: int32*d1)*d2) + 511), 512) - 1)*512)), d2), 0), d1), floordiv(select((d2 >= 0), 0, floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2)), d1))
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (select((d1: int32 >= 0), floordiv(select((d2: int32 >= 0), floordiv((511 + ((floordiv((((d0: int32*d1)*d2) + 511), 512) - 1)*512)), d2), 0), d1), floordiv(select((d2 >= 0), 0, floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2)), d1)) < d0)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, 511], b after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, (511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2)), select((d2 >= 0), floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2)), select((d2 >= 0), floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2), 0)], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d1: int32, Bound: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d1 >= 0), d1, (0 - d1)) - 1)), (select((d1 >= 0), d1, (0 - d1)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:558: value: floormod(floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d2: int32), d1: int32), vmax: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove ((select((d1: int32 >= 0), d1, (0 - d1)) - 1) < d1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, 511], b after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, (511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d2: int32, Bound: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d2 >= 0), d2, (0 - d2)) - 1)), (select((d2 >= 0), d2, (0 - d2)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:558: value: floormod((threadIdx.x: int32 + (blockIdx.x: int32*512)), d2: int32), vmax: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove ((select((d2: int32 >= 0), d2, (0 - d2)) - 1) < d2)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, 511], b after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, (511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2)), select((d2 >= 0), floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2), 0)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:558: value: floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d2: int32), vmax: select((d2: int32 >= 0), floordiv((511 + ((floordiv((((d0: int32*d1: int32)*d2) + 511), 512) - 1)*512)), d2), 0)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (select((d2: int32 >= 0), floordiv((511 + ((floordiv((((d0: int32*d1: int32)*d2) + 511), 512) - 1)*512)), d2), 0) < (d0*d1))
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, 511], b after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, (511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512))]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:558: value: (threadIdx.x: int32 + (blockIdx.x: int32*512)), vmax: (511 + ((floordiv((((d0: int32*d1: int32)*d2: int32) + 511), 512) - 1)*512))
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove ((511 + ((floordiv((((d0: int32*d1: int32)*d2: int32) + 511), 512) - 1)*512)) < ((d0*d1)*d2))
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove (d0: int32 == d0)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove (d1: int32 == d1)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove (d2: int32 == d2)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove (d3: int32 == d3)
[14:05:56] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floordiv(floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d2: int32), d1: int32) < d0: int32)
[14:05:56] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floormod(floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d2: int32), d1: int32) < d1)
[14:05:56] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floormod((threadIdx.x: int32 + (blockIdx.x: int32*512)), d2: int32) < d2)
[14:05:56] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d2: int32) < (d0: int32*d1: int32))
[14:05:56] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! ((threadIdx.x: int32 + (blockIdx.x: int32*512)) < ((d0: int32*d1: int32)*d2: int32))
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (((d0: int32*d1: int32)*d2: int32) == (512*floordiv((((d0*d1)*d2) + 511), 512)))
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, (d0 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, (d2 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, (d2 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, (d2 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused: int32, IntervalSet[0, (((d0*d1)*d2) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, (d1 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, (d2 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, (d1 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused: int32, IntervalSet[0, (((d0*d1)*d2) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, (d1 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert threadIdx.x: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, (d0 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.i3.fused.inner: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert blockIdx.x: int32, IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert blockIdx.x: int32, IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.inner: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused: int32, IntervalSet[0, (((d0*d1)*d2) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i3: int32, IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.i3.fused: int32, IntervalSet[0, ((((d0*d1)*d2)*d3) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, (d0 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused: int32, IntervalSet[0, ((d0*d1) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.i3.fused.inner: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.i3.fused: int32, IntervalSet[0, ((((d0*d1)*d2)*d3) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i3: int32, IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert blockIdx.x: int32, IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused: int32, IntervalSet[0, (((d0*d1)*d2) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.i3.fused.outer: int32, IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused: int32, IntervalSet[0, ((d0*d1) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.outer: int32, IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused: int32, IntervalSet[0, ((d0*d1) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.outer: int32, IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, (d1 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, (d0 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert threadIdx.x: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert threadIdx.x: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert blockIdx.x: int32, IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.i3.fused.outer: int32, IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert threadIdx.x: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused: int32, IntervalSet[0, ((d0*d1) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.inner: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, 511], b after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, (511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2)), select((d2 >= 0), floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2)), select((d2 >= 0), floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2), 0)], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(select((d2 >= 0), 0, floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2)), d1), floordiv(select((d2 >= 0), floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2), 0), d1)), select((d1 >= 0), floordiv(select((d2 >= 0), floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2), 0), d1), floordiv(select((d2 >= 0), 0, floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2)), d1))]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:558: value: floordiv(floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d2: int32), d1: int32), vmax: select((d1: int32 >= 0), floordiv(select((d2: int32 >= 0), floordiv((511 + ((floordiv((((d0: int32*d1)*d2) + 511), 512) - 1)*512)), d2), 0), d1), floordiv(select((d2 >= 0), 0, floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2)), d1))
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (select((d1: int32 >= 0), floordiv(select((d2: int32 >= 0), floordiv((511 + ((floordiv((((d0: int32*d1)*d2) + 511), 512) - 1)*512)), d2), 0), d1), floordiv(select((d2 >= 0), 0, floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2)), d1)) < d0)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, 511], b after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, (511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2)), select((d2 >= 0), floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2)), select((d2 >= 0), floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2), 0)], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d1: int32, Bound: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d1 >= 0), d1, (0 - d1)) - 1)), (select((d1 >= 0), d1, (0 - d1)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:558: value: floormod(floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d2: int32), d1: int32), vmax: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove ((select((d1: int32 >= 0), d1, (0 - d1)) - 1) < d1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, 511], b after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, (511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d2: int32, Bound: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d2 >= 0), d2, (0 - d2)) - 1)), (select((d2 >= 0), d2, (0 - d2)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:558: value: floormod((threadIdx.x: int32 + (blockIdx.x: int32*512)), d2: int32), vmax: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove ((select((d2: int32 >= 0), d2, (0 - d2)) - 1) < d2)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, 511], b after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, (511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2)), select((d2 >= 0), floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2), 0)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:558: value: floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d2: int32), vmax: select((d2: int32 >= 0), floordiv((511 + ((floordiv((((d0: int32*d1: int32)*d2) + 511), 512) - 1)*512)), d2), 0)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (select((d2: int32 >= 0), floordiv((511 + ((floordiv((((d0: int32*d1: int32)*d2) + 511), 512) - 1)*512)), d2), 0) < (d0*d1))
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, 511], b after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, (511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512))]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:558: value: (threadIdx.x: int32 + (blockIdx.x: int32*512)), vmax: (511 + ((floordiv((((d0: int32*d1: int32)*d2: int32) + 511), 512) - 1)*512))
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove ((511 + ((floordiv((((d0: int32*d1: int32)*d2: int32) + 511), 512) - 1)*512)) < ((d0*d1)*d2))
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove ((((d0: int32*d1: int32)*d2: int32)*d3: int32) == (512*floordiv(((((d0*d1)*d2)*d3) + 511), 512)))
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, (d0 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, (d2 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, (d2 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, (d2 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused: int32, IntervalSet[0, (((d0*d1)*d2) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, (d1 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, (d2 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, (d1 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused: int32, IntervalSet[0, (((d0*d1)*d2) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, (d1 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert threadIdx.x: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, (d0 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.i3.fused.inner: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert blockIdx.x: int32, IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert blockIdx.x: int32, IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.inner: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused: int32, IntervalSet[0, (((d0*d1)*d2) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i3: int32, IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.i3.fused: int32, IntervalSet[0, ((((d0*d1)*d2)*d3) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, (d0 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused: int32, IntervalSet[0, ((d0*d1) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.i3.fused.inner: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.i3.fused: int32, IntervalSet[0, ((((d0*d1)*d2)*d3) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i3: int32, IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert blockIdx.x: int32, IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused: int32, IntervalSet[0, (((d0*d1)*d2) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.i3.fused.outer: int32, IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused: int32, IntervalSet[0, ((d0*d1) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.outer: int32, IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused: int32, IntervalSet[0, ((d0*d1) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.outer: int32, IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, (d1 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, (d0 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert threadIdx.x: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert threadIdx.x: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert blockIdx.x: int32, IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.i3.fused.outer: int32, IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert threadIdx.x: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused: int32, IntervalSet[0, ((d0*d1) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.inner: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, 511], b after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, (511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512))], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2), floordiv(select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2)), select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2), floordiv(select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2)), select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(select((d2 >= 0), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2), floordiv(select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2)), d1), floordiv(select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2)), d1)), select((d1 >= 0), floordiv(select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2)), d1), floordiv(select((d2 >= 0), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2), floordiv(select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2)), d1))]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:558: value: floordiv(floordiv(floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d3: int32), d2: int32), d1: int32), vmax: select((d1: int32 >= 0), floordiv(select((d2: int32 >= 0), floordiv(select((d3: int32 >= 0), floordiv((511 + ((floordiv(((((d0: int32*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2)), d1), floordiv(select((d2 >= 0), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2), floordiv(select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2)), d1))
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (select((d1: int32 >= 0), floordiv(select((d2: int32 >= 0), floordiv(select((d3: int32 >= 0), floordiv((511 + ((floordiv(((((d0: int32*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2)), d1), floordiv(select((d2 >= 0), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2), floordiv(select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2)), d1)) < d0)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, 511], b after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, (511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512))], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2), floordiv(select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2)), select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2), floordiv(select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2)), select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d1: int32, Bound: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d1 >= 0), d1, (0 - d1)) - 1)), (select((d1 >= 0), d1, (0 - d1)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:558: value: floormod(floordiv(floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d3: int32), d2: int32), d1: int32), vmax: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove ((select((d1: int32 >= 0), d1, (0 - d1)) - 1) < d1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, 511], b after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, (511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512))], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d2: int32, Bound: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d2 >= 0), d2, (0 - d2)) - 1)), (select((d2 >= 0), d2, (0 - d2)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:558: value: floormod(floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d3: int32), d2: int32), vmax: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove ((select((d2: int32 >= 0), d2, (0 - d2)) - 1) < d2)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, 511], b after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, (511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512))], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d3: int32, Bound: (select((d3: int32 >= 0), d3, (0 - d3)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d3 >= 0), d3, (0 - d3)) - 1)), (select((d3 >= 0), d3, (0 - d3)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:558: value: floormod((threadIdx.x: int32 + (blockIdx.x: int32*512)), d3: int32), vmax: (select((d3: int32 >= 0), d3, (0 - d3)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove ((select((d3: int32 >= 0), d3, (0 - d3)) - 1) < d3)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, 511], b after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, (511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512))], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2), floordiv(select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2)), select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2))]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:558: value: floordiv(floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d3: int32), d2: int32), vmax: select((d2: int32 >= 0), floordiv(select((d3: int32 >= 0), floordiv((511 + ((floordiv(((((d0: int32*d1: int32)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2))
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (select((d2: int32 >= 0), floordiv(select((d3: int32 >= 0), floordiv((511 + ((floordiv(((((d0: int32*d1: int32)*d2)*d3) + 511), 512) - 1)*512)), d3), 0), d2), floordiv(select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), d2)) < (d0*d1))
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, 511], b after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, (511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512))], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3)), select((d3 >= 0), floordiv((511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:558: value: floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d3: int32), vmax: select((d3: int32 >= 0), floordiv((511 + ((floordiv(((((d0: int32*d1: int32)*d2: int32)*d3) + 511), 512) - 1)*512)), d3), 0)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (select((d3: int32 >= 0), floordiv((511 + ((floordiv(((((d0: int32*d1: int32)*d2: int32)*d3) + 511), 512) - 1)*512)), d3), 0) < ((d0*d1)*d2))
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, 511], b after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, (511 + ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512))]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:558: value: (threadIdx.x: int32 + (blockIdx.x: int32*512)), vmax: (511 + ((floordiv(((((d0: int32*d1: int32)*d2: int32)*d3: int32) + 511), 512) - 1)*512))
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove ((511 + ((floordiv(((((d0: int32*d1: int32)*d2: int32)*d3: int32) + 511), 512) - 1)*512)) < (((d0*d1)*d2)*d3))
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove (d0: int32 == d0)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove (d1: int32 == d1)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove (d2: int32 == d2)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove (d3: int32 == d3)
[14:05:56] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floordiv(floordiv(floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d3: int32), d2: int32), d1: int32) < d0: int32)
[14:05:56] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floormod(floordiv(floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d3: int32), d2: int32), d1: int32) < d1)
[14:05:56] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floormod(floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d3: int32), d2: int32) < d2)
[14:05:56] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floormod((threadIdx.x: int32 + (blockIdx.x: int32*512)), d3: int32) < d3)
[14:05:56] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floordiv(floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d3: int32), d2: int32) < (d0: int32*d1: int32))
[14:05:56] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d3: int32) < ((d0: int32*d1: int32)*d2: int32))
[14:05:56] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! ((threadIdx.x: int32 + (blockIdx.x: int32*512)) < (((d0: int32*d1: int32)*d2: int32)*d3: int32))
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (((d0: int32*d1: int32)*d2: int32) == (512*floordiv((((d0*d1)*d2) + 511), 512)))
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, (d0 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, (d2 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, (d2 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, (d2 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused: int32, IntervalSet[0, (((d0*d1)*d2) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, (d1 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, (d2 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, (d1 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused: int32, IntervalSet[0, (((d0*d1)*d2) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, (d1 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert threadIdx.x: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, (d0 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.i3.fused.inner: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert blockIdx.x: int32, IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert blockIdx.x: int32, IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.inner: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused: int32, IntervalSet[0, (((d0*d1)*d2) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i3: int32, IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.i3.fused: int32, IntervalSet[0, ((((d0*d1)*d2)*d3) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, (d0 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused: int32, IntervalSet[0, ((d0*d1) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.i3.fused.inner: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.i3.fused: int32, IntervalSet[0, ((((d0*d1)*d2)*d3) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i3: int32, IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert blockIdx.x: int32, IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused: int32, IntervalSet[0, (((d0*d1)*d2) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.i3.fused.outer: int32, IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused: int32, IntervalSet[0, ((d0*d1) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.outer: int32, IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused: int32, IntervalSet[0, ((d0*d1) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.outer: int32, IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, (d1 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, (d0 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert threadIdx.x: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert threadIdx.x: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert blockIdx.x: int32, IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.i3.fused.outer: int32, IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert threadIdx.x: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused: int32, IntervalSet[0, ((d0*d1) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.inner: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, 511], b after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, (511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2)), select((d2 >= 0), floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2)), select((d2 >= 0), floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2), 0)], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(select((d2 >= 0), 0, floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2)), d1), floordiv(select((d2 >= 0), floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2), 0), d1)), select((d1 >= 0), floordiv(select((d2 >= 0), floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2), 0), d1), floordiv(select((d2 >= 0), 0, floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2)), d1))]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:558: value: floordiv(floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d2: int32), d1: int32), vmax: select((d1: int32 >= 0), floordiv(select((d2: int32 >= 0), floordiv((511 + ((floordiv((((d0: int32*d1)*d2) + 511), 512) - 1)*512)), d2), 0), d1), floordiv(select((d2 >= 0), 0, floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2)), d1))
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (select((d1: int32 >= 0), floordiv(select((d2: int32 >= 0), floordiv((511 + ((floordiv((((d0: int32*d1)*d2) + 511), 512) - 1)*512)), d2), 0), d1), floordiv(select((d2 >= 0), 0, floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2)), d1)) < d0)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, 511], b after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, (511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2)), select((d2 >= 0), floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2)), select((d2 >= 0), floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2), 0)], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d1: int32, Bound: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d1 >= 0), d1, (0 - d1)) - 1)), (select((d1 >= 0), d1, (0 - d1)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:558: value: floormod(floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d2: int32), d1: int32), vmax: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove ((select((d1: int32 >= 0), d1, (0 - d1)) - 1) < d1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, 511], b after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, (511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d2: int32, Bound: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d2 >= 0), d2, (0 - d2)) - 1)), (select((d2 >= 0), d2, (0 - d2)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:558: value: floormod((threadIdx.x: int32 + (blockIdx.x: int32*512)), d2: int32), vmax: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove ((select((d2: int32 >= 0), d2, (0 - d2)) - 1) < d2)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, 511], b after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, (511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2)), select((d2 >= 0), floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2), 0)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:558: value: floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d2: int32), vmax: select((d2: int32 >= 0), floordiv((511 + ((floordiv((((d0: int32*d1: int32)*d2) + 511), 512) - 1)*512)), d2), 0)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (select((d2: int32 >= 0), floordiv((511 + ((floordiv((((d0: int32*d1: int32)*d2) + 511), 512) - 1)*512)), d2), 0) < (d0*d1))
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, 511], b after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, (511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512))]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:558: value: (threadIdx.x: int32 + (blockIdx.x: int32*512)), vmax: (511 + ((floordiv((((d0: int32*d1: int32)*d2: int32) + 511), 512) - 1)*512))
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove ((511 + ((floordiv((((d0: int32*d1: int32)*d2: int32) + 511), 512) - 1)*512)) < ((d0*d1)*d2))
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove (d0: int32 == d0)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove (d1: int32 == d1)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove (d2: int32 == d2)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove (d3: int32 == d3)
[14:05:56] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floordiv(floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d2: int32), d1: int32) < d0: int32)
[14:05:56] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floormod(floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d2: int32), d1: int32) < d1)
[14:05:56] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floormod((threadIdx.x: int32 + (blockIdx.x: int32*512)), d2: int32) < d2)
[14:05:56] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! (floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d2: int32) < (d0: int32*d1: int32))
[14:05:56] /workspace/home/codes/tvm/src/te/operation/compute_op.cc:449: Likely! ((threadIdx.x: int32 + (blockIdx.x: int32*512)) < ((d0: int32*d1: int32)*d2: int32))
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (((d0: int32*d1: int32)*d2: int32) == (512*floordiv((((d0*d1)*d2) + 511), 512)))
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, (d0 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, (d2 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, (d2 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, (d2 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused: int32, IntervalSet[0, (((d0*d1)*d2) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, (d1 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i2: int32, IntervalSet[0, (d2 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, (d1 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused: int32, IntervalSet[0, (((d0*d1)*d2) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, (d1 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert threadIdx.x: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, (d0 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.i3.fused.inner: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert blockIdx.x: int32, IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert blockIdx.x: int32, IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.inner: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused: int32, IntervalSet[0, (((d0*d1)*d2) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i3: int32, IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.i3.fused: int32, IntervalSet[0, ((((d0*d1)*d2)*d3) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, (d0 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused: int32, IntervalSet[0, ((d0*d1) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.i3.fused.inner: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.i3.fused: int32, IntervalSet[0, ((((d0*d1)*d2)*d3) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i3: int32, IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert blockIdx.x: int32, IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused: int32, IntervalSet[0, (((d0*d1)*d2) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.i3.fused.outer: int32, IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused: int32, IntervalSet[0, ((d0*d1) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.outer: int32, IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused: int32, IntervalSet[0, ((d0*d1) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.outer: int32, IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i1: int32, IntervalSet[0, (d1 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0: int32, IntervalSet[0, (d0 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert threadIdx.x: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert threadIdx.x: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert k: int32, IntervalSet[0, (d3 - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert blockIdx.x: int32, IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.i3.fused.outer: int32, IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert threadIdx.x: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused: int32, IntervalSet[0, ((d0*d1) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:543: insert i0.i1.fused.i2.fused.inner: int32, IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, 511], b after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, (511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2)), select((d2 >= 0), floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2)), select((d2 >= 0), floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2), 0)], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(select((d2 >= 0), 0, floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2)), d1), floordiv(select((d2 >= 0), floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2), 0), d1)), select((d1 >= 0), floordiv(select((d2 >= 0), floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2), 0), d1), floordiv(select((d2 >= 0), 0, floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2)), d1))]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:558: value: floordiv(floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d2: int32), d1: int32), vmax: select((d1: int32 >= 0), floordiv(select((d2: int32 >= 0), floordiv((511 + ((floordiv((((d0: int32*d1)*d2) + 511), 512) - 1)*512)), d2), 0), d1), floordiv(select((d2 >= 0), 0, floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2)), d1))
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (select((d1: int32 >= 0), floordiv(select((d2: int32 >= 0), floordiv((511 + ((floordiv((((d0: int32*d1)*d2) + 511), 512) - 1)*512)), d2), 0), d1), floordiv(select((d2 >= 0), 0, floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2)), d1)) < d0)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, 511], b after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, (511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2)), select((d2 >= 0), floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), 0, floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2)), select((d2 >= 0), floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2), 0)], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d1: int32, Bound: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d1 >= 0), d1, (0 - d1)) - 1)), (select((d1 >= 0), d1, (0 - d1)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:558: value: floormod(floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d2: int32), d1: int32), vmax: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove ((select((d1: int32 >= 0), d1, (0 - d1)) - 1) < d1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, 511], b after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, (511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d2: int32, Bound: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d2 >= 0), d2, (0 - d2)) - 1)), (select((d2 >= 0), d2, (0 - d2)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:558: value: floormod((threadIdx.x: int32 + (blockIdx.x: int32*512)), d2: int32), vmax: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove ((select((d2: int32 >= 0), d2, (0 - d2)) - 1) < d2)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, 511], b after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, (511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2)), select((d2 >= 0), floordiv((511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)), d2), 0)]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:558: value: floordiv((threadIdx.x: int32 + (blockIdx.x: int32*512)), d2: int32), vmax: select((d2: int32 >= 0), floordiv((511 + ((floordiv((((d0: int32*d1: int32)*d2) + 511), 512) - 1)*512)), d2), 0)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (select((d2: int32 >= 0), floordiv((511 + ((floordiv((((d0: int32*d1: int32)*d2) + 511), 512) - 1)*512)), d2), 0) < (d0*d1))
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, 511], b after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, (511 + ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512))]
[14:05:56] /workspace/home/codes/tvm/src/te/schedule/message_passing.cc:558: value: (threadIdx.x: int32 + (blockIdx.x: int32*512)), vmax: (511 + ((floordiv((((d0: int32*d1: int32)*d2: int32) + 511), 512) - 1)*512))
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove ((511 + ((floordiv((((d0: int32*d1: int32)*d2: int32) + 511), 512) - 1)*512)) < ((d0*d1)*d2))
[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectPrefetch
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  attr [T_softmax_maxelem: Buffer(T_softmax_maxelem_1: Pointer(float32), float32, [d0, d1, d2], [])] "realize_scope" = "";
  realize(T_softmax_maxelem, [0:d0, 0:d1, 0:d2], True {
    attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
    attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512 {
      if @tir.likely((floordiv(floordiv((threadIdx.x + (blockIdx.x*512)), d2), d1) < d0), dtype=bool) {
        if @tir.likely((floormod(floordiv((threadIdx.x + (blockIdx.x*512)), d2), d1) < d1), dtype=bool) {
          if @tir.likely((floormod((threadIdx.x + (blockIdx.x*512)), d2) < d2), dtype=bool) {
            if @tir.likely((floordiv((threadIdx.x + (blockIdx.x*512)), d2) < (d0*d1)), dtype=bool) {
              if @tir.likely(((threadIdx.x + (blockIdx.x*512)) < ((d0*d1)*d2)), dtype=bool) {
                T_softmax_maxelem[floordiv(floordiv((threadIdx.x + (blockIdx.x*512)), d2), d1), floormod(floordiv((threadIdx.x + (blockIdx.x*512)), d2), d1), floormod((threadIdx.x + (blockIdx.x*512)), d2)] = -3.40282e+38f32
              }
            }
          }
        }
      }
      for (k: int32, 0, d3) {
        if @tir.likely((floordiv(floordiv((threadIdx.x + (blockIdx.x*512)), d2), d1) < d0), dtype=bool) {
          if @tir.likely((floormod(floordiv((threadIdx.x + (blockIdx.x*512)), d2), d1) < d1), dtype=bool) {
            if @tir.likely((floormod((threadIdx.x + (blockIdx.x*512)), d2) < d2), dtype=bool) {
              if @tir.likely((floordiv((threadIdx.x + (blockIdx.x*512)), d2) < (d0*d1)), dtype=bool) {
                if @tir.likely(((threadIdx.x + (blockIdx.x*512)) < ((d0*d1)*d2)), dtype=bool) {
                  T_softmax_maxelem[floordiv(floordiv((threadIdx.x + (blockIdx.x*512)), d2), d1), floormod(floordiv((threadIdx.x + (blockIdx.x*512)), d2), d1), floormod((threadIdx.x + (blockIdx.x*512)), d2)] = max(T_softmax_maxelem[floordiv(floordiv((threadIdx.x + (blockIdx.x*512)), d2), d1), floormod(floordiv((threadIdx.x + (blockIdx.x*512)), d2), d1), floormod((threadIdx.x + (blockIdx.x*512)), d2)], placeholder[floordiv(floordiv((threadIdx.x + (blockIdx.x*512)), d2), d1), floormod(floordiv((threadIdx.x + (blockIdx.x*512)), d2), d1), floormod((threadIdx.x + (blockIdx.x*512)), d2), k])
                }
              }
            }
          }
        }
      }
    }
    attr [T_softmax_exp: Buffer(T_softmax_exp_1: Pointer(float32), float32, [d0, d1, d2, d3], [])] "realize_scope" = "";
    realize(T_softmax_exp, [0:d0, 0:d1, 0:d2, 0:d3], True {
      attr [IterVar(blockIdx.x_1: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
      attr [IterVar(threadIdx.x_1: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
      if @tir.likely((floordiv(floordiv(floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3), d2), d1) < d0), dtype=bool) {
        if @tir.likely((floormod(floordiv(floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3), d2), d1) < d1), dtype=bool) {
          if @tir.likely((floormod(floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3), d2) < d2), dtype=bool) {
            if @tir.likely((floormod((threadIdx.x_1 + (blockIdx.x_1*512)), d3) < d3), dtype=bool) {
              if @tir.likely((floordiv(floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3), d2) < (d0*d1)), dtype=bool) {
                if @tir.likely((floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3) < ((d0*d1)*d2)), dtype=bool) {
                  if @tir.likely(((threadIdx.x_1 + (blockIdx.x_1*512)) < (((d0*d1)*d2)*d3)), dtype=bool) {
                    T_softmax_exp[floordiv(floordiv(floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3), d2), d1), floormod(floordiv(floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3), d2), d1), floormod(floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3), d2), floormod((threadIdx.x_1 + (blockIdx.x_1*512)), d3)] = @tir.exp((placeholder[floordiv(floordiv(floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3), d2), d1), floormod(floordiv(floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3), d2), d1), floormod(floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3), d2), floormod((threadIdx.x_1 + (blockIdx.x_1*512)), d3)] - T_softmax_maxelem[floordiv(floordiv(floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3), d2), d1), floormod(floordiv(floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3), d2), d1), floormod(floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3), d2)]), dtype=float32)
                  }
                }
              }
            }
          }
        }
      }
      attr [T_softmax_expsum: Buffer(T_softmax_expsum_1: Pointer(float32), float32, [d0, d1, d2], [])] "realize_scope" = "";
      realize(T_softmax_expsum, [0:d0, 0:d1, 0:d2], True {
        attr [IterVar(blockIdx.x_2: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
        attr [IterVar(threadIdx.x_2: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512 {
          if @tir.likely((floordiv(floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2), d1) < d0), dtype=bool) {
            if @tir.likely((floormod(floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2), d1) < d1), dtype=bool) {
              if @tir.likely((floormod((threadIdx.x_2 + (blockIdx.x_2*512)), d2) < d2), dtype=bool) {
                if @tir.likely((floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2) < (d0*d1)), dtype=bool) {
                  if @tir.likely(((threadIdx.x_2 + (blockIdx.x_2*512)) < ((d0*d1)*d2)), dtype=bool) {
                    T_softmax_expsum[floordiv(floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2), d1), floormod(floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2), d1), floormod((threadIdx.x_2 + (blockIdx.x_2*512)), d2)] = 0f32
                  }
                }
              }
            }
          }
          for (k_1: int32, 0, d3) {
            if @tir.likely((floordiv(floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2), d1) < d0), dtype=bool) {
              if @tir.likely((floormod(floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2), d1) < d1), dtype=bool) {
                if @tir.likely((floormod((threadIdx.x_2 + (blockIdx.x_2*512)), d2) < d2), dtype=bool) {
                  if @tir.likely((floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2) < (d0*d1)), dtype=bool) {
                    if @tir.likely(((threadIdx.x_2 + (blockIdx.x_2*512)) < ((d0*d1)*d2)), dtype=bool) {
                      T_softmax_expsum[floordiv(floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2), d1), floormod(floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2), d1), floormod((threadIdx.x_2 + (blockIdx.x_2*512)), d2)] = (T_softmax_expsum[floordiv(floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2), d1), floormod(floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2), d1), floormod((threadIdx.x_2 + (blockIdx.x_2*512)), d2)] + T_softmax_exp[floordiv(floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2), d1), floormod(floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2), d1), floormod((threadIdx.x_2 + (blockIdx.x_2*512)), d2), k_1])
                    }
                  }
                }
              }
            }
          }
        }
        attr [T_softmax_norm] "realize_scope" = "";
        realize(T_softmax_norm, [0:d0, 0:d1, 0:d2, 0:d3], True {
          attr [IterVar(blockIdx.x_3: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
          attr [IterVar(threadIdx.x_3: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
          if @tir.likely((floordiv(floordiv(floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3), d2), d1) < d0), dtype=bool) {
            if @tir.likely((floormod(floordiv(floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3), d2), d1) < d1), dtype=bool) {
              if @tir.likely((floormod(floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3), d2) < d2), dtype=bool) {
                if @tir.likely((floormod((threadIdx.x_3 + (blockIdx.x_3*512)), d3) < d3), dtype=bool) {
                  if @tir.likely((floordiv(floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3), d2) < (d0*d1)), dtype=bool) {
                    if @tir.likely((floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3) < ((d0*d1)*d2)), dtype=bool) {
                      if @tir.likely(((threadIdx.x_3 + (blockIdx.x_3*512)) < (((d0*d1)*d2)*d3)), dtype=bool) {
                        T_softmax_norm[floordiv(floordiv(floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3), d2), d1), floormod(floordiv(floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3), d2), d1), floormod(floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3), d2), floormod((threadIdx.x_3 + (blockIdx.x_3*512)), d3)] = (T_softmax_exp[floordiv(floordiv(floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3), d2), d1), floormod(floordiv(floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3), d2), d1), floormod(floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3), d2), floormod((threadIdx.x_3 + (blockIdx.x_3*512)), d3)] / T_softmax_expsum[floordiv(floordiv(floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3), d2), d1), floormod(floordiv(floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3), d2), d1), floormod(floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3), d2)])
                      }
                    }
                  }
                }
              }
            }
          }
        })
      })
    })
  })
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.StorageFlatten
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
  allocate(T_softmax_maxelem, float32, [d0, d1, d2]) {
    attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
    attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512 {
      if @tir.likely((floordiv(floordiv((threadIdx.x + (blockIdx.x*512)), d2), d1) < d0), dtype=bool) {
        if @tir.likely((floormod(floordiv((threadIdx.x + (blockIdx.x*512)), d2), d1) < d1), dtype=bool) {
          if @tir.likely((floormod((threadIdx.x + (blockIdx.x*512)), d2) < d2), dtype=bool) {
            if @tir.likely((floordiv((threadIdx.x + (blockIdx.x*512)), d2) < (d0*d1)), dtype=bool) {
              if @tir.likely(((threadIdx.x + (blockIdx.x*512)) < ((d0*d1)*d2)), dtype=bool) {
                T_softmax_maxelem[(threadIdx.x + (blockIdx.x*512))] = -3.40282e+38f32
              }
            }
          }
        }
      }
      for (k: int32, 0, d3) {
        if @tir.likely((floordiv(floordiv((threadIdx.x + (blockIdx.x*512)), d2), d1) < d0), dtype=bool) {
          if @tir.likely((floormod(floordiv((threadIdx.x + (blockIdx.x*512)), d2), d1) < d1), dtype=bool) {
            if @tir.likely((floormod((threadIdx.x + (blockIdx.x*512)), d2) < d2), dtype=bool) {
              if @tir.likely((floordiv((threadIdx.x + (blockIdx.x*512)), d2) < (d0*d1)), dtype=bool) {
                if @tir.likely(((threadIdx.x + (blockIdx.x*512)) < ((d0*d1)*d2)), dtype=bool) {
                  T_softmax_maxelem[(threadIdx.x + (blockIdx.x*512))] = max((float32*)T_softmax_maxelem[(threadIdx.x + (blockIdx.x*512))], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k*stride_7))])
                }
              }
            }
          }
        }
      }
    }
    attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_exp, float32, [d0, d1, d2, d3]) {
      attr [IterVar(blockIdx.x_1: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
      attr [IterVar(threadIdx.x_1: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
      if @tir.likely((floordiv(floordiv(floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3), d2), d1) < d0), dtype=bool) {
        if @tir.likely((floormod(floordiv(floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3), d2), d1) < d1), dtype=bool) {
          if @tir.likely((floormod(floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3), d2) < d2), dtype=bool) {
            if @tir.likely((floormod((threadIdx.x_1 + (blockIdx.x_1*512)), d3) < d3), dtype=bool) {
              if @tir.likely((floordiv(floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3), d2) < (d0*d1)), dtype=bool) {
                if @tir.likely((floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3) < ((d0*d1)*d2)), dtype=bool) {
                  if @tir.likely(((threadIdx.x_1 + (blockIdx.x_1*512)) < (((d0*d1)*d2)*d3)), dtype=bool) {
                    T_softmax_exp[(threadIdx.x_1 + (blockIdx.x_1*512))] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                  }
                }
              }
            }
          }
        }
      }
      attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
      allocate(T_softmax_expsum, float32, [d0, d1, d2]) {
        attr [IterVar(blockIdx.x_2: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
        attr [IterVar(threadIdx.x_2: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512 {
          if @tir.likely((floordiv(floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2), d1) < d0), dtype=bool) {
            if @tir.likely((floormod(floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2), d1) < d1), dtype=bool) {
              if @tir.likely((floormod((threadIdx.x_2 + (blockIdx.x_2*512)), d2) < d2), dtype=bool) {
                if @tir.likely((floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2) < (d0*d1)), dtype=bool) {
                  if @tir.likely(((threadIdx.x_2 + (blockIdx.x_2*512)) < ((d0*d1)*d2)), dtype=bool) {
                    T_softmax_expsum[(threadIdx.x_2 + (blockIdx.x_2*512))] = 0f32
                  }
                }
              }
            }
          }
          for (k_1: int32, 0, d3) {
            if @tir.likely((floordiv(floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2), d1) < d0), dtype=bool) {
              if @tir.likely((floormod(floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2), d1) < d1), dtype=bool) {
                if @tir.likely((floormod((threadIdx.x_2 + (blockIdx.x_2*512)), d2) < d2), dtype=bool) {
                  if @tir.likely((floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2) < (d0*d1)), dtype=bool) {
                    if @tir.likely(((threadIdx.x_2 + (blockIdx.x_2*512)) < ((d0*d1)*d2)), dtype=bool) {
                      T_softmax_expsum[(threadIdx.x_2 + (blockIdx.x_2*512))] = ((float32*)T_softmax_expsum[(threadIdx.x_2 + (blockIdx.x_2*512))] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_1)])
                    }
                  }
                }
              }
            }
          }
        }
        attr [IterVar(blockIdx.x_3: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
        attr [IterVar(threadIdx.x_3: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
        if @tir.likely((floordiv(floordiv(floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3), d2), d1) < d0), dtype=bool) {
          if @tir.likely((floormod(floordiv(floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3), d2), d1) < d1), dtype=bool) {
            if @tir.likely((floormod(floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3), d2) < d2), dtype=bool) {
              if @tir.likely((floormod((threadIdx.x_3 + (blockIdx.x_3*512)), d3) < d3), dtype=bool) {
                if @tir.likely((floordiv(floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3), d2) < (d0*d1)), dtype=bool) {
                  if @tir.likely((floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3) < ((d0*d1)*d2)), dtype=bool) {
                    if @tir.likely(((threadIdx.x_3 + (blockIdx.x_3*512)) < (((d0*d1)*d2)*d3)), dtype=bool) {
                      T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[(threadIdx.x_3 + (blockIdx.x_3*512))] / (float32*)T_softmax_expsum[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16Promote
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
  allocate(T_softmax_maxelem, float32, [d0, d1, d2]) {
    attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
    attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512 {
      if @tir.likely((floordiv(floordiv((threadIdx.x + (blockIdx.x*512)), d2), d1) < d0), dtype=bool) {
        if @tir.likely((floormod(floordiv((threadIdx.x + (blockIdx.x*512)), d2), d1) < d1), dtype=bool) {
          if @tir.likely((floormod((threadIdx.x + (blockIdx.x*512)), d2) < d2), dtype=bool) {
            if @tir.likely((floordiv((threadIdx.x + (blockIdx.x*512)), d2) < (d0*d1)), dtype=bool) {
              if @tir.likely(((threadIdx.x + (blockIdx.x*512)) < ((d0*d1)*d2)), dtype=bool) {
                T_softmax_maxelem[(threadIdx.x + (blockIdx.x*512))] = -3.40282e+38f32
              }
            }
          }
        }
      }
      for (k: int32, 0, d3) {
        if @tir.likely((floordiv(floordiv((threadIdx.x + (blockIdx.x*512)), d2), d1) < d0), dtype=bool) {
          if @tir.likely((floormod(floordiv((threadIdx.x + (blockIdx.x*512)), d2), d1) < d1), dtype=bool) {
            if @tir.likely((floormod((threadIdx.x + (blockIdx.x*512)), d2) < d2), dtype=bool) {
              if @tir.likely((floordiv((threadIdx.x + (blockIdx.x*512)), d2) < (d0*d1)), dtype=bool) {
                if @tir.likely(((threadIdx.x + (blockIdx.x*512)) < ((d0*d1)*d2)), dtype=bool) {
                  T_softmax_maxelem[(threadIdx.x + (blockIdx.x*512))] = max((float32*)T_softmax_maxelem[(threadIdx.x + (blockIdx.x*512))], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k*stride_7))])
                }
              }
            }
          }
        }
      }
    }
    attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_exp, float32, [d0, d1, d2, d3]) {
      attr [IterVar(blockIdx.x_1: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
      attr [IterVar(threadIdx.x_1: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
      if @tir.likely((floordiv(floordiv(floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3), d2), d1) < d0), dtype=bool) {
        if @tir.likely((floormod(floordiv(floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3), d2), d1) < d1), dtype=bool) {
          if @tir.likely((floormod(floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3), d2) < d2), dtype=bool) {
            if @tir.likely((floormod((threadIdx.x_1 + (blockIdx.x_1*512)), d3) < d3), dtype=bool) {
              if @tir.likely((floordiv(floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3), d2) < (d0*d1)), dtype=bool) {
                if @tir.likely((floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3) < ((d0*d1)*d2)), dtype=bool) {
                  if @tir.likely(((threadIdx.x_1 + (blockIdx.x_1*512)) < (((d0*d1)*d2)*d3)), dtype=bool) {
                    T_softmax_exp[(threadIdx.x_1 + (blockIdx.x_1*512))] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                  }
                }
              }
            }
          }
        }
      }
      attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
      allocate(T_softmax_expsum, float32, [d0, d1, d2]) {
        attr [IterVar(blockIdx.x_2: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
        attr [IterVar(threadIdx.x_2: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512 {
          if @tir.likely((floordiv(floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2), d1) < d0), dtype=bool) {
            if @tir.likely((floormod(floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2), d1) < d1), dtype=bool) {
              if @tir.likely((floormod((threadIdx.x_2 + (blockIdx.x_2*512)), d2) < d2), dtype=bool) {
                if @tir.likely((floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2) < (d0*d1)), dtype=bool) {
                  if @tir.likely(((threadIdx.x_2 + (blockIdx.x_2*512)) < ((d0*d1)*d2)), dtype=bool) {
                    T_softmax_expsum[(threadIdx.x_2 + (blockIdx.x_2*512))] = 0f32
                  }
                }
              }
            }
          }
          for (k_1: int32, 0, d3) {
            if @tir.likely((floordiv(floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2), d1) < d0), dtype=bool) {
              if @tir.likely((floormod(floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2), d1) < d1), dtype=bool) {
                if @tir.likely((floormod((threadIdx.x_2 + (blockIdx.x_2*512)), d2) < d2), dtype=bool) {
                  if @tir.likely((floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2) < (d0*d1)), dtype=bool) {
                    if @tir.likely(((threadIdx.x_2 + (blockIdx.x_2*512)) < ((d0*d1)*d2)), dtype=bool) {
                      T_softmax_expsum[(threadIdx.x_2 + (blockIdx.x_2*512))] = ((float32*)T_softmax_expsum[(threadIdx.x_2 + (blockIdx.x_2*512))] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_1)])
                    }
                  }
                }
              }
            }
          }
        }
        attr [IterVar(blockIdx.x_3: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
        attr [IterVar(threadIdx.x_3: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
        if @tir.likely((floordiv(floordiv(floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3), d2), d1) < d0), dtype=bool) {
          if @tir.likely((floormod(floordiv(floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3), d2), d1) < d1), dtype=bool) {
            if @tir.likely((floormod(floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3), d2) < d2), dtype=bool) {
              if @tir.likely((floormod((threadIdx.x_3 + (blockIdx.x_3*512)), d3) < d3), dtype=bool) {
                if @tir.likely((floordiv(floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3), d2) < (d0*d1)), dtype=bool) {
                  if @tir.likely((floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3) < ((d0*d1)*d2)), dtype=bool) {
                    if @tir.likely(((threadIdx.x_3 + (blockIdx.x_3*512)) < (((d0*d1)*d2)*d3)), dtype=bool) {
                      T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[(threadIdx.x_3 + (blockIdx.x_3*512))] / (float32*)T_softmax_expsum[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16CastElimination
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
  allocate(T_softmax_maxelem, float32, [d0, d1, d2]) {
    attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
    attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512 {
      if @tir.likely((floordiv(floordiv((threadIdx.x + (blockIdx.x*512)), d2), d1) < d0), dtype=bool) {
        if @tir.likely((floormod(floordiv((threadIdx.x + (blockIdx.x*512)), d2), d1) < d1), dtype=bool) {
          if @tir.likely((floormod((threadIdx.x + (blockIdx.x*512)), d2) < d2), dtype=bool) {
            if @tir.likely((floordiv((threadIdx.x + (blockIdx.x*512)), d2) < (d0*d1)), dtype=bool) {
              if @tir.likely(((threadIdx.x + (blockIdx.x*512)) < ((d0*d1)*d2)), dtype=bool) {
                T_softmax_maxelem[(threadIdx.x + (blockIdx.x*512))] = -3.40282e+38f32
              }
            }
          }
        }
      }
      for (k: int32, 0, d3) {
        if @tir.likely((floordiv(floordiv((threadIdx.x + (blockIdx.x*512)), d2), d1) < d0), dtype=bool) {
          if @tir.likely((floormod(floordiv((threadIdx.x + (blockIdx.x*512)), d2), d1) < d1), dtype=bool) {
            if @tir.likely((floormod((threadIdx.x + (blockIdx.x*512)), d2) < d2), dtype=bool) {
              if @tir.likely((floordiv((threadIdx.x + (blockIdx.x*512)), d2) < (d0*d1)), dtype=bool) {
                if @tir.likely(((threadIdx.x + (blockIdx.x*512)) < ((d0*d1)*d2)), dtype=bool) {
                  T_softmax_maxelem[(threadIdx.x + (blockIdx.x*512))] = max((float32*)T_softmax_maxelem[(threadIdx.x + (blockIdx.x*512))], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k*stride_7))])
                }
              }
            }
          }
        }
      }
    }
    attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_exp, float32, [d0, d1, d2, d3]) {
      attr [IterVar(blockIdx.x_1: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
      attr [IterVar(threadIdx.x_1: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
      if @tir.likely((floordiv(floordiv(floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3), d2), d1) < d0), dtype=bool) {
        if @tir.likely((floormod(floordiv(floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3), d2), d1) < d1), dtype=bool) {
          if @tir.likely((floormod(floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3), d2) < d2), dtype=bool) {
            if @tir.likely((floormod((threadIdx.x_1 + (blockIdx.x_1*512)), d3) < d3), dtype=bool) {
              if @tir.likely((floordiv(floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3), d2) < (d0*d1)), dtype=bool) {
                if @tir.likely((floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3) < ((d0*d1)*d2)), dtype=bool) {
                  if @tir.likely(((threadIdx.x_1 + (blockIdx.x_1*512)) < (((d0*d1)*d2)*d3)), dtype=bool) {
                    T_softmax_exp[(threadIdx.x_1 + (blockIdx.x_1*512))] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                  }
                }
              }
            }
          }
        }
      }
      attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
      allocate(T_softmax_expsum, float32, [d0, d1, d2]) {
        attr [IterVar(blockIdx.x_2: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
        attr [IterVar(threadIdx.x_2: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512 {
          if @tir.likely((floordiv(floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2), d1) < d0), dtype=bool) {
            if @tir.likely((floormod(floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2), d1) < d1), dtype=bool) {
              if @tir.likely((floormod((threadIdx.x_2 + (blockIdx.x_2*512)), d2) < d2), dtype=bool) {
                if @tir.likely((floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2) < (d0*d1)), dtype=bool) {
                  if @tir.likely(((threadIdx.x_2 + (blockIdx.x_2*512)) < ((d0*d1)*d2)), dtype=bool) {
                    T_softmax_expsum[(threadIdx.x_2 + (blockIdx.x_2*512))] = 0f32
                  }
                }
              }
            }
          }
          for (k_1: int32, 0, d3) {
            if @tir.likely((floordiv(floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2), d1) < d0), dtype=bool) {
              if @tir.likely((floormod(floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2), d1) < d1), dtype=bool) {
                if @tir.likely((floormod((threadIdx.x_2 + (blockIdx.x_2*512)), d2) < d2), dtype=bool) {
                  if @tir.likely((floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2) < (d0*d1)), dtype=bool) {
                    if @tir.likely(((threadIdx.x_2 + (blockIdx.x_2*512)) < ((d0*d1)*d2)), dtype=bool) {
                      T_softmax_expsum[(threadIdx.x_2 + (blockIdx.x_2*512))] = ((float32*)T_softmax_expsum[(threadIdx.x_2 + (blockIdx.x_2*512))] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_1)])
                    }
                  }
                }
              }
            }
          }
        }
        attr [IterVar(blockIdx.x_3: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
        attr [IterVar(threadIdx.x_3: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
        if @tir.likely((floordiv(floordiv(floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3), d2), d1) < d0), dtype=bool) {
          if @tir.likely((floormod(floordiv(floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3), d2), d1) < d1), dtype=bool) {
            if @tir.likely((floormod(floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3), d2) < d2), dtype=bool) {
              if @tir.likely((floormod((threadIdx.x_3 + (blockIdx.x_3*512)), d3) < d3), dtype=bool) {
                if @tir.likely((floordiv(floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3), d2) < (d0*d1)), dtype=bool) {
                  if @tir.likely((floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3) < ((d0*d1)*d2)), dtype=bool) {
                    if @tir.likely(((threadIdx.x_3 + (blockIdx.x_3*512)) < (((d0*d1)*d2)*d3)), dtype=bool) {
                      T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[(threadIdx.x_3 + (blockIdx.x_3*512))] / (float32*)T_softmax_expsum[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16TypeLowering
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
  allocate(T_softmax_maxelem, float32, [d0, d1, d2]) {
    attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
    attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512 {
      if @tir.likely((floordiv(floordiv((threadIdx.x + (blockIdx.x*512)), d2), d1) < d0), dtype=bool) {
        if @tir.likely((floormod(floordiv((threadIdx.x + (blockIdx.x*512)), d2), d1) < d1), dtype=bool) {
          if @tir.likely((floormod((threadIdx.x + (blockIdx.x*512)), d2) < d2), dtype=bool) {
            if @tir.likely((floordiv((threadIdx.x + (blockIdx.x*512)), d2) < (d0*d1)), dtype=bool) {
              if @tir.likely(((threadIdx.x + (blockIdx.x*512)) < ((d0*d1)*d2)), dtype=bool) {
                T_softmax_maxelem[(threadIdx.x + (blockIdx.x*512))] = -3.40282e+38f32
              }
            }
          }
        }
      }
      for (k: int32, 0, d3) {
        if @tir.likely((floordiv(floordiv((threadIdx.x + (blockIdx.x*512)), d2), d1) < d0), dtype=bool) {
          if @tir.likely((floormod(floordiv((threadIdx.x + (blockIdx.x*512)), d2), d1) < d1), dtype=bool) {
            if @tir.likely((floormod((threadIdx.x + (blockIdx.x*512)), d2) < d2), dtype=bool) {
              if @tir.likely((floordiv((threadIdx.x + (blockIdx.x*512)), d2) < (d0*d1)), dtype=bool) {
                if @tir.likely(((threadIdx.x + (blockIdx.x*512)) < ((d0*d1)*d2)), dtype=bool) {
                  T_softmax_maxelem[(threadIdx.x + (blockIdx.x*512))] = max((float32*)T_softmax_maxelem[(threadIdx.x + (blockIdx.x*512))], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k*stride_7))])
                }
              }
            }
          }
        }
      }
    }
    attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_exp, float32, [d0, d1, d2, d3]) {
      attr [IterVar(blockIdx.x_1: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
      attr [IterVar(threadIdx.x_1: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
      if @tir.likely((floordiv(floordiv(floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3), d2), d1) < d0), dtype=bool) {
        if @tir.likely((floormod(floordiv(floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3), d2), d1) < d1), dtype=bool) {
          if @tir.likely((floormod(floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3), d2) < d2), dtype=bool) {
            if @tir.likely((floormod((threadIdx.x_1 + (blockIdx.x_1*512)), d3) < d3), dtype=bool) {
              if @tir.likely((floordiv(floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3), d2) < (d0*d1)), dtype=bool) {
                if @tir.likely((floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3) < ((d0*d1)*d2)), dtype=bool) {
                  if @tir.likely(((threadIdx.x_1 + (blockIdx.x_1*512)) < (((d0*d1)*d2)*d3)), dtype=bool) {
                    T_softmax_exp[(threadIdx.x_1 + (blockIdx.x_1*512))] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                  }
                }
              }
            }
          }
        }
      }
      attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
      allocate(T_softmax_expsum, float32, [d0, d1, d2]) {
        attr [IterVar(blockIdx.x_2: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
        attr [IterVar(threadIdx.x_2: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512 {
          if @tir.likely((floordiv(floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2), d1) < d0), dtype=bool) {
            if @tir.likely((floormod(floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2), d1) < d1), dtype=bool) {
              if @tir.likely((floormod((threadIdx.x_2 + (blockIdx.x_2*512)), d2) < d2), dtype=bool) {
                if @tir.likely((floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2) < (d0*d1)), dtype=bool) {
                  if @tir.likely(((threadIdx.x_2 + (blockIdx.x_2*512)) < ((d0*d1)*d2)), dtype=bool) {
                    T_softmax_expsum[(threadIdx.x_2 + (blockIdx.x_2*512))] = 0f32
                  }
                }
              }
            }
          }
          for (k_1: int32, 0, d3) {
            if @tir.likely((floordiv(floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2), d1) < d0), dtype=bool) {
              if @tir.likely((floormod(floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2), d1) < d1), dtype=bool) {
                if @tir.likely((floormod((threadIdx.x_2 + (blockIdx.x_2*512)), d2) < d2), dtype=bool) {
                  if @tir.likely((floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2) < (d0*d1)), dtype=bool) {
                    if @tir.likely(((threadIdx.x_2 + (blockIdx.x_2*512)) < ((d0*d1)*d2)), dtype=bool) {
                      T_softmax_expsum[(threadIdx.x_2 + (blockIdx.x_2*512))] = ((float32*)T_softmax_expsum[(threadIdx.x_2 + (blockIdx.x_2*512))] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_1)])
                    }
                  }
                }
              }
            }
          }
        }
        attr [IterVar(blockIdx.x_3: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
        attr [IterVar(threadIdx.x_3: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
        if @tir.likely((floordiv(floordiv(floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3), d2), d1) < d0), dtype=bool) {
          if @tir.likely((floormod(floordiv(floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3), d2), d1) < d1), dtype=bool) {
            if @tir.likely((floormod(floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3), d2) < d2), dtype=bool) {
              if @tir.likely((floormod((threadIdx.x_3 + (blockIdx.x_3*512)), d3) < d3), dtype=bool) {
                if @tir.likely((floordiv(floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3), d2) < (d0*d1)), dtype=bool) {
                  if @tir.likely((floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3) < ((d0*d1)*d2)), dtype=bool) {
                    if @tir.likely(((threadIdx.x_3 + (blockIdx.x_3*512)) < (((d0*d1)*d2)*d3)), dtype=bool) {
                      T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[(threadIdx.x_3 + (blockIdx.x_3*512))] / (float32*)T_softmax_expsum[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.BF16Legalize
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
  allocate(T_softmax_maxelem, float32, [d0, d1, d2]) {
    attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
    attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512 {
      if @tir.likely((floordiv(floordiv((threadIdx.x + (blockIdx.x*512)), d2), d1) < d0), dtype=bool) {
        if @tir.likely((floormod(floordiv((threadIdx.x + (blockIdx.x*512)), d2), d1) < d1), dtype=bool) {
          if @tir.likely((floormod((threadIdx.x + (blockIdx.x*512)), d2) < d2), dtype=bool) {
            if @tir.likely((floordiv((threadIdx.x + (blockIdx.x*512)), d2) < (d0*d1)), dtype=bool) {
              if @tir.likely(((threadIdx.x + (blockIdx.x*512)) < ((d0*d1)*d2)), dtype=bool) {
                T_softmax_maxelem[(threadIdx.x + (blockIdx.x*512))] = -3.40282e+38f32
              }
            }
          }
        }
      }
      for (k: int32, 0, d3) {
        if @tir.likely((floordiv(floordiv((threadIdx.x + (blockIdx.x*512)), d2), d1) < d0), dtype=bool) {
          if @tir.likely((floormod(floordiv((threadIdx.x + (blockIdx.x*512)), d2), d1) < d1), dtype=bool) {
            if @tir.likely((floormod((threadIdx.x + (blockIdx.x*512)), d2) < d2), dtype=bool) {
              if @tir.likely((floordiv((threadIdx.x + (blockIdx.x*512)), d2) < (d0*d1)), dtype=bool) {
                if @tir.likely(((threadIdx.x + (blockIdx.x*512)) < ((d0*d1)*d2)), dtype=bool) {
                  T_softmax_maxelem[(threadIdx.x + (blockIdx.x*512))] = max((float32*)T_softmax_maxelem[(threadIdx.x + (blockIdx.x*512))], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k*stride_7))])
                }
              }
            }
          }
        }
      }
    }
    attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_exp, float32, [d0, d1, d2, d3]) {
      attr [IterVar(blockIdx.x_1: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
      attr [IterVar(threadIdx.x_1: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
      if @tir.likely((floordiv(floordiv(floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3), d2), d1) < d0), dtype=bool) {
        if @tir.likely((floormod(floordiv(floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3), d2), d1) < d1), dtype=bool) {
          if @tir.likely((floormod(floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3), d2) < d2), dtype=bool) {
            if @tir.likely((floormod((threadIdx.x_1 + (blockIdx.x_1*512)), d3) < d3), dtype=bool) {
              if @tir.likely((floordiv(floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3), d2) < (d0*d1)), dtype=bool) {
                if @tir.likely((floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3) < ((d0*d1)*d2)), dtype=bool) {
                  if @tir.likely(((threadIdx.x_1 + (blockIdx.x_1*512)) < (((d0*d1)*d2)*d3)), dtype=bool) {
                    T_softmax_exp[(threadIdx.x_1 + (blockIdx.x_1*512))] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                  }
                }
              }
            }
          }
        }
      }
      attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
      allocate(T_softmax_expsum, float32, [d0, d1, d2]) {
        attr [IterVar(blockIdx.x_2: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
        attr [IterVar(threadIdx.x_2: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512 {
          if @tir.likely((floordiv(floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2), d1) < d0), dtype=bool) {
            if @tir.likely((floormod(floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2), d1) < d1), dtype=bool) {
              if @tir.likely((floormod((threadIdx.x_2 + (blockIdx.x_2*512)), d2) < d2), dtype=bool) {
                if @tir.likely((floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2) < (d0*d1)), dtype=bool) {
                  if @tir.likely(((threadIdx.x_2 + (blockIdx.x_2*512)) < ((d0*d1)*d2)), dtype=bool) {
                    T_softmax_expsum[(threadIdx.x_2 + (blockIdx.x_2*512))] = 0f32
                  }
                }
              }
            }
          }
          for (k_1: int32, 0, d3) {
            if @tir.likely((floordiv(floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2), d1) < d0), dtype=bool) {
              if @tir.likely((floormod(floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2), d1) < d1), dtype=bool) {
                if @tir.likely((floormod((threadIdx.x_2 + (blockIdx.x_2*512)), d2) < d2), dtype=bool) {
                  if @tir.likely((floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2) < (d0*d1)), dtype=bool) {
                    if @tir.likely(((threadIdx.x_2 + (blockIdx.x_2*512)) < ((d0*d1)*d2)), dtype=bool) {
                      T_softmax_expsum[(threadIdx.x_2 + (blockIdx.x_2*512))] = ((float32*)T_softmax_expsum[(threadIdx.x_2 + (blockIdx.x_2*512))] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_1)])
                    }
                  }
                }
              }
            }
          }
        }
        attr [IterVar(blockIdx.x_3: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
        attr [IterVar(threadIdx.x_3: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
        if @tir.likely((floordiv(floordiv(floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3), d2), d1) < d0), dtype=bool) {
          if @tir.likely((floormod(floordiv(floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3), d2), d1) < d1), dtype=bool) {
            if @tir.likely((floormod(floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3), d2) < d2), dtype=bool) {
              if @tir.likely((floormod((threadIdx.x_3 + (blockIdx.x_3*512)), d3) < d3), dtype=bool) {
                if @tir.likely((floordiv(floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3), d2) < (d0*d1)), dtype=bool) {
                  if @tir.likely((floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3) < ((d0*d1)*d2)), dtype=bool) {
                    if @tir.likely(((threadIdx.x_3 + (blockIdx.x_3*512)) < (((d0*d1)*d2)*d3)), dtype=bool) {
                      T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[(threadIdx.x_3 + (blockIdx.x_3*512))] / (float32*)T_softmax_expsum[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.NarrowDataType
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
  allocate(T_softmax_maxelem, float32, [d0, d1, d2]) {
    attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
    attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512 {
      if @tir.likely((floordiv(floordiv((threadIdx.x + (blockIdx.x*512)), d2), d1) < d0), dtype=bool) {
        if @tir.likely((floormod(floordiv((threadIdx.x + (blockIdx.x*512)), d2), d1) < d1), dtype=bool) {
          if @tir.likely((floormod((threadIdx.x + (blockIdx.x*512)), d2) < d2), dtype=bool) {
            if @tir.likely((floordiv((threadIdx.x + (blockIdx.x*512)), d2) < (d0*d1)), dtype=bool) {
              if @tir.likely(((threadIdx.x + (blockIdx.x*512)) < ((d0*d1)*d2)), dtype=bool) {
                T_softmax_maxelem[(threadIdx.x + (blockIdx.x*512))] = -3.40282e+38f32
              }
            }
          }
        }
      }
      for (k: int32, 0, d3) {
        if @tir.likely((floordiv(floordiv((threadIdx.x + (blockIdx.x*512)), d2), d1) < d0), dtype=bool) {
          if @tir.likely((floormod(floordiv((threadIdx.x + (blockIdx.x*512)), d2), d1) < d1), dtype=bool) {
            if @tir.likely((floormod((threadIdx.x + (blockIdx.x*512)), d2) < d2), dtype=bool) {
              if @tir.likely((floordiv((threadIdx.x + (blockIdx.x*512)), d2) < (d0*d1)), dtype=bool) {
                if @tir.likely(((threadIdx.x + (blockIdx.x*512)) < ((d0*d1)*d2)), dtype=bool) {
                  T_softmax_maxelem[(threadIdx.x + (blockIdx.x*512))] = max((float32*)T_softmax_maxelem[(threadIdx.x + (blockIdx.x*512))], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k*stride_7))])
                }
              }
            }
          }
        }
      }
    }
    attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_exp, float32, [d0, d1, d2, d3]) {
      attr [IterVar(blockIdx.x_1: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
      attr [IterVar(threadIdx.x_1: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
      if @tir.likely((floordiv(floordiv(floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3), d2), d1) < d0), dtype=bool) {
        if @tir.likely((floormod(floordiv(floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3), d2), d1) < d1), dtype=bool) {
          if @tir.likely((floormod(floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3), d2) < d2), dtype=bool) {
            if @tir.likely((floormod((threadIdx.x_1 + (blockIdx.x_1*512)), d3) < d3), dtype=bool) {
              if @tir.likely((floordiv(floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3), d2) < (d0*d1)), dtype=bool) {
                if @tir.likely((floordiv((threadIdx.x_1 + (blockIdx.x_1*512)), d3) < ((d0*d1)*d2)), dtype=bool) {
                  if @tir.likely(((threadIdx.x_1 + (blockIdx.x_1*512)) < (((d0*d1)*d2)*d3)), dtype=bool) {
                    T_softmax_exp[(threadIdx.x_1 + (blockIdx.x_1*512))] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                  }
                }
              }
            }
          }
        }
      }
      attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
      allocate(T_softmax_expsum, float32, [d0, d1, d2]) {
        attr [IterVar(blockIdx.x_2: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
        attr [IterVar(threadIdx.x_2: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512 {
          if @tir.likely((floordiv(floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2), d1) < d0), dtype=bool) {
            if @tir.likely((floormod(floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2), d1) < d1), dtype=bool) {
              if @tir.likely((floormod((threadIdx.x_2 + (blockIdx.x_2*512)), d2) < d2), dtype=bool) {
                if @tir.likely((floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2) < (d0*d1)), dtype=bool) {
                  if @tir.likely(((threadIdx.x_2 + (blockIdx.x_2*512)) < ((d0*d1)*d2)), dtype=bool) {
                    T_softmax_expsum[(threadIdx.x_2 + (blockIdx.x_2*512))] = 0f32
                  }
                }
              }
            }
          }
          for (k_1: int32, 0, d3) {
            if @tir.likely((floordiv(floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2), d1) < d0), dtype=bool) {
              if @tir.likely((floormod(floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2), d1) < d1), dtype=bool) {
                if @tir.likely((floormod((threadIdx.x_2 + (blockIdx.x_2*512)), d2) < d2), dtype=bool) {
                  if @tir.likely((floordiv((threadIdx.x_2 + (blockIdx.x_2*512)), d2) < (d0*d1)), dtype=bool) {
                    if @tir.likely(((threadIdx.x_2 + (blockIdx.x_2*512)) < ((d0*d1)*d2)), dtype=bool) {
                      T_softmax_expsum[(threadIdx.x_2 + (blockIdx.x_2*512))] = ((float32*)T_softmax_expsum[(threadIdx.x_2 + (blockIdx.x_2*512))] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_1)])
                    }
                  }
                }
              }
            }
          }
        }
        attr [IterVar(blockIdx.x_3: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
        attr [IterVar(threadIdx.x_3: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
        if @tir.likely((floordiv(floordiv(floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3), d2), d1) < d0), dtype=bool) {
          if @tir.likely((floormod(floordiv(floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3), d2), d1) < d1), dtype=bool) {
            if @tir.likely((floormod(floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3), d2) < d2), dtype=bool) {
              if @tir.likely((floormod((threadIdx.x_3 + (blockIdx.x_3*512)), d3) < d3), dtype=bool) {
                if @tir.likely((floordiv(floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3), d2) < (d0*d1)), dtype=bool) {
                  if @tir.likely((floordiv((threadIdx.x_3 + (blockIdx.x_3*512)), d3) < ((d0*d1)*d2)), dtype=bool) {
                    if @tir.likely(((threadIdx.x_3 + (blockIdx.x_3*512)) < (((d0*d1)*d2)*d3)), dtype=bool) {
                      T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[(threadIdx.x_3 + (blockIdx.x_3*512))] / (float32*)T_softmax_expsum[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
  allocate(T_softmax_maxelem, float32, [d0, d1, d2]) {
    attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
    attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512 {
      if @tir.likely((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0), dtype=bool) {
        if @tir.likely((floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1), dtype=bool) {
          if @tir.likely((floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2), dtype=bool) {
            if @tir.likely((floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)), dtype=bool) {
              if @tir.likely((((blockIdx.x*512) + threadIdx.x) < ((d0*d1)*d2)), dtype=bool) {
                T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = -3.40282e+38f32
              }
            }
          }
        }
      }
      for (k: int32, 0, d3) {
        if @tir.likely((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0), dtype=bool) {
          if @tir.likely((floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1), dtype=bool) {
            if @tir.likely((floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2), dtype=bool) {
              if @tir.likely((floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)), dtype=bool) {
                if @tir.likely((((blockIdx.x*512) + threadIdx.x) < ((d0*d1)*d2)), dtype=bool) {
                  T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = max((float32*)T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k*stride_7))])
                }
              }
            }
          }
        }
      }
    }
    attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_exp, float32, [d0, d1, d2, d3]) {
      attr [IterVar(blockIdx.x_1: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
      attr [IterVar(threadIdx.x_1: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
      if @tir.likely((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d0), dtype=bool) {
        if @tir.likely((floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d1), dtype=bool) {
          if @tir.likely((floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < d2), dtype=bool) {
            if @tir.likely((floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3) < d3), dtype=bool) {
              if @tir.likely((floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < (d0*d1)), dtype=bool) {
                if @tir.likely((floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3) < ((d0*d1)*d2)), dtype=bool) {
                  if @tir.likely((((blockIdx.x_1*512) + threadIdx.x_1) < (((d0*d1)*d2)*d3)), dtype=bool) {
                    T_softmax_exp[((blockIdx.x_1*512) + threadIdx.x_1)] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                  }
                }
              }
            }
          }
        }
      }
      attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
      allocate(T_softmax_expsum, float32, [d0, d1, d2]) {
        attr [IterVar(blockIdx.x_2: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
        attr [IterVar(threadIdx.x_2: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512 {
          if @tir.likely((floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0), dtype=bool) {
            if @tir.likely((floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1), dtype=bool) {
              if @tir.likely((floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2), dtype=bool) {
                if @tir.likely((floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)), dtype=bool) {
                  if @tir.likely((((blockIdx.x_2*512) + threadIdx.x_2) < ((d0*d1)*d2)), dtype=bool) {
                    T_softmax_expsum[((blockIdx.x_2*512) + threadIdx.x_2)] = 0f32
                  }
                }
              }
            }
          }
          for (k_1: int32, 0, d3) {
            if @tir.likely((floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0), dtype=bool) {
              if @tir.likely((floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1), dtype=bool) {
                if @tir.likely((floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2), dtype=bool) {
                  if @tir.likely((floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)), dtype=bool) {
                    if @tir.likely((((blockIdx.x_2*512) + threadIdx.x_2) < ((d0*d1)*d2)), dtype=bool) {
                      T_softmax_expsum[((blockIdx.x_2*512) + threadIdx.x_2)] = ((float32*)T_softmax_expsum[((blockIdx.x_2*512) + threadIdx.x_2)] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_1)])
                    }
                  }
                }
              }
            }
          }
        }
        attr [IterVar(blockIdx.x_3: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
        attr [IterVar(threadIdx.x_3: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
        if @tir.likely((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d0), dtype=bool) {
          if @tir.likely((floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d1), dtype=bool) {
            if @tir.likely((floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < d2), dtype=bool) {
              if @tir.likely((floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3) < d3), dtype=bool) {
                if @tir.likely((floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < (d0*d1)), dtype=bool) {
                  if @tir.likely((floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3) < ((d0*d1)*d2)), dtype=bool) {
                    if @tir.likely((((blockIdx.x_3*512) + threadIdx.x_3) < (((d0*d1)*d2)*d3)), dtype=bool) {
                      T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[((blockIdx.x_3*512) + threadIdx.x_3)] / (float32*)T_softmax_expsum[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}


[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), d1), floordiv(select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2)), d1)), select((d1 >= 0), floordiv(select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2)), d1), floordiv(select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), d1))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2))), max(select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2)))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(min(select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2))), d1), floordiv(max(select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))), d1)), select((d1 >= 0), floordiv(max(select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))), d1), floordiv(min(select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2))), d1))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2))), max(select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(min(select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2))), d1), floordiv(max(select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)), d1)), select((d1 >= 0), floordiv(max(select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)), d1), floordiv(min(select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2))), d1))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), d1), floordiv(select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2)), d1)), select((d1 >= 0), floordiv(select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2)), d1), floordiv(select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), d1))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2))), max(select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(min(select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2))), d1), floordiv(max(select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)), d1)), select((d1 >= 0), floordiv(max(select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)), d1), floordiv(min(select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2))), d1))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2))), max(select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2)))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(min(select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2))), d1), floordiv(max(select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))), d1)), select((d1 >= 0), floordiv(max(select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))), d1), floordiv(min(select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2))), d1))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d1: int32, Bound: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d1 >= 0), d1, (0 - d1)) - 1)), (select((d1 >= 0), d1, (0 - d1)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d1, d1], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d1: int32, Bound: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d1 >= 0), d1, (0 - d1)) - 1)), (select((d1 >= 0), d1, (0 - d1)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d2: int32, Bound: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d2 >= 0), d2, (0 - d2)) - 1)), (select((d2 >= 0), d2, (0 - d2)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d2, d2], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d2: int32, Bound: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d2 >= 0), d2, (0 - d2)) - 1)), (select((d2 >= 0), d2, (0 - d2)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (floormod(((((d0: int32*d1: int32)*d2: int32) - 1) - 511), 512) == 0)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (floormod(((d0: int32*d1: int32)*d2: int32), 512) == 0)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), d1), floordiv(select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2)), d1)), select((d1 >= 0), floordiv(select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2)), d1), floordiv(select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), d1))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2))), max(select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2)))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(min(select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2))), d1), floordiv(max(select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))), d1)), select((d1 >= 0), floordiv(max(select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))), d1), floordiv(min(select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2))), d1))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2))), max(select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(min(select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2))), d1), floordiv(max(select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)), d1)), select((d1 >= 0), floordiv(max(select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)), d1), floordiv(min(select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2))), d1))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), d1), floordiv(select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2)), d1)), select((d1 >= 0), floordiv(select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2)), d1), floordiv(select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), d1))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2))), max(select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(min(select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2))), d1), floordiv(max(select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)), d1)), select((d1 >= 0), floordiv(max(select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)), d1), floordiv(min(select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2))), d1))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2))), max(select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2)))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(min(select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2))), d1), floordiv(max(select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))), d1)), select((d1 >= 0), floordiv(max(select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))), d1), floordiv(min(select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2))), d1))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d1: int32, Bound: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d1 >= 0), d1, (0 - d1)) - 1)), (select((d1 >= 0), d1, (0 - d1)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d1, d1], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d1: int32, Bound: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d1 >= 0), d1, (0 - d1)) - 1)), (select((d1 >= 0), d1, (0 - d1)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d2: int32, Bound: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d2 >= 0), d2, (0 - d2)) - 1)), (select((d2 >= 0), d2, (0 - d2)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d2, d2], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d2: int32, Bound: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d2 >= 0), d2, (0 - d2)) - 1)), (select((d2 >= 0), d2, (0 - d2)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (floormod(((((d0: int32*d1: int32)*d2: int32) - 1) - 511), 512) == 0)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (floormod(((d0: int32*d1: int32)*d2: int32), 512) == 0)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - min(floordiv(((((d0: int32*d1: int32)*d2: int32) - 1) - 511), 512), (floordiv((((d0*d1)*d2) + 511), 512) - 1))) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - min(floordiv(((((d0: int32*d1: int32)*d2: int32) - 1) - 511), 512), (floordiv((((d0*d1)*d2) + 511), 512) - 1))) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove ((floordiv(((d0: int32*d1: int32)*d2: int32), 512) - 1) == (floordiv((((d0*d1)*d2) + 511), 512) - 1))
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove ((((floordiv((((d0: int32*d1: int32)*d2: int32) + 511), 512) - 1) - floordiv(((d0*d1)*d2), 512)) + 1) >= 0)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (floordiv(((d0: int32*d1: int32)*d2: int32), 512) == ((floordiv((((d0*d1)*d2) + 511), 512) - 1) + 1))
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2)), select((d2 >= 0), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2)), select((d2 >= 0), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2)), d1), floordiv(select((d2 >= 0), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2)), d1)), select((d1 >= 0), floordiv(select((d2 >= 0), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2)), d1), floordiv(select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2)), d1))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d2 >= 0), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2)), select((d2 >= 0), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2))), max(select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2)))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(min(select((d2 >= 0), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2)), select((d2 >= 0), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2))), d1), floordiv(max(select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2))), d1)), select((d1 >= 0), floordiv(max(select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2))), d1), floordiv(min(select((d2 >= 0), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2)), select((d2 >= 0), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2))), d1))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d2 >= 0), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2)), select((d2 >= 0), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2))), max(select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2)))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(min(select((d2 >= 0), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2)), select((d2 >= 0), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2))), d1), floordiv(max(select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2))), d1)), select((d1 >= 0), floordiv(max(select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2))), d1), floordiv(min(select((d2 >= 0), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2)), select((d2 >= 0), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2))), d1))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2)), select((d2 >= 0), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2)), select((d2 >= 0), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2)), d1), floordiv(select((d2 >= 0), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2)), d1)), select((d1 >= 0), floordiv(select((d2 >= 0), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2)), d1), floordiv(select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2)), d1))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d2 >= 0), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2)), select((d2 >= 0), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2))), max(select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2)))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(min(select((d2 >= 0), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2)), select((d2 >= 0), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2))), d1), floordiv(max(select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2))), d1)), select((d1 >= 0), floordiv(max(select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2))), d1), floordiv(min(select((d2 >= 0), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2)), select((d2 >= 0), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2))), d1))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d2 >= 0), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2)), select((d2 >= 0), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2))), max(select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2)))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(min(select((d2 >= 0), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2)), select((d2 >= 0), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2))), d1), floordiv(max(select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2))), d1)), select((d1 >= 0), floordiv(max(select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2))), d1), floordiv(min(select((d2 >= 0), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2)), select((d2 >= 0), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2))), d1))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2)), select((d2 >= 0), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2)), select((d2 >= 0), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d1: int32, Bound: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d1 >= 0), d1, (0 - d1)) - 1)), (select((d1 >= 0), d1, (0 - d1)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d1, d1], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2)), select((d2 >= 0), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2)), select((d2 >= 0), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d1: int32, Bound: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d1 >= 0), d1, (0 - d1)) - 1)), (select((d1 >= 0), d1, (0 - d1)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d2: int32, Bound: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d2 >= 0), d2, (0 - d2)) - 1)), (select((d2 >= 0), d2, (0 - d2)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d2, d2], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d2: int32, Bound: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d2 >= 0), d2, (0 - d2)) - 1)), (select((d2 >= 0), d2, (0 - d2)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d3: int32, Bound: (select((d3: int32 >= 0), d3, (0 - d3)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d3 >= 0), d3, (0 - d3)) - 1)), (select((d3 >= 0), d3, (0 - d3)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d3, d3], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d3: int32, Bound: (select((d3: int32 >= 0), d3, (0 - d3)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d3 >= 0), d3, (0 - d3)) - 1)), (select((d3 >= 0), d3, (0 - d3)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2)), select((d2 >= 0), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2)), select((d2 >= 0), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (floormod((((((d0: int32*d1: int32)*d2: int32)*d3: int32) - 1) - 511), 512) == 0)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (floormod((((d0: int32*d1: int32)*d2: int32)*d3: int32), 512) == 0)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - min(floordiv((((((d0: int32*d1: int32)*d2: int32)*d3: int32) - 1) - 511), 512), (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1))) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (floordiv((((((d0: int32*d1: int32)*d2: int32)*d3: int32) - 1) - 511), 512) == (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1))
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove ((((floordiv(((((d0: int32*d1: int32)*d2: int32)*d3: int32) + 511), 512) - 1) - floordiv((((d0*d1)*d2)*d3), 512)) + 1) >= 0)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (floordiv((((d0: int32*d1: int32)*d2: int32)*d3: int32), 512) == ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1) + 1))
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), d1), floordiv(select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2)), d1)), select((d1 >= 0), floordiv(select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2)), d1), floordiv(select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), d1))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2))), max(select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2)))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(min(select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2))), d1), floordiv(max(select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))), d1)), select((d1 >= 0), floordiv(max(select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))), d1), floordiv(min(select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2))), d1))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2))), max(select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(min(select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2))), d1), floordiv(max(select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)), d1)), select((d1 >= 0), floordiv(max(select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)), d1), floordiv(min(select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2))), d1))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), d1), floordiv(select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2)), d1)), select((d1 >= 0), floordiv(select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2)), d1), floordiv(select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), d1))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2))), max(select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(min(select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2))), d1), floordiv(max(select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)), d1)), select((d1 >= 0), floordiv(max(select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)), d1), floordiv(min(select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2))), d1))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2))), max(select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2)))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(min(select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2))), d1), floordiv(max(select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))), d1)), select((d1 >= 0), floordiv(max(select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))), d1), floordiv(min(select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2))), d1))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d1: int32, Bound: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d1 >= 0), d1, (0 - d1)) - 1)), (select((d1 >= 0), d1, (0 - d1)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d1, d1], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d1: int32, Bound: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d1 >= 0), d1, (0 - d1)) - 1)), (select((d1 >= 0), d1, (0 - d1)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d2: int32, Bound: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d2 >= 0), d2, (0 - d2)) - 1)), (select((d2 >= 0), d2, (0 - d2)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d2, d2], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d2: int32, Bound: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d2 >= 0), d2, (0 - d2)) - 1)), (select((d2 >= 0), d2, (0 - d2)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (floormod(((((d0: int32*d1: int32)*d2: int32) - 1) - 511), 512) == 0)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (floormod(((d0: int32*d1: int32)*d2: int32), 512) == 0)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), d1), floordiv(select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2)), d1)), select((d1 >= 0), floordiv(select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2)), d1), floordiv(select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), d1))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2))), max(select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2)))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(min(select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2))), d1), floordiv(max(select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))), d1)), select((d1 >= 0), floordiv(max(select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))), d1), floordiv(min(select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2))), d1))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2))), max(select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(min(select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2))), d1), floordiv(max(select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)), d1)), select((d1 >= 0), floordiv(max(select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)), d1), floordiv(min(select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2))), d1))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), d1), floordiv(select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2)), d1)), select((d1 >= 0), floordiv(select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2)), d1), floordiv(select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), d1))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2))), max(select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(min(select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2))), d1), floordiv(max(select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)), d1)), select((d1 >= 0), floordiv(max(select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)), d1), floordiv(min(select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2))), d1))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2))), max(select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2)))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(min(select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2))), d1), floordiv(max(select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))), d1)), select((d1 >= 0), floordiv(max(select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))), d1), floordiv(min(select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2))), d1))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d1: int32, Bound: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d1 >= 0), d1, (0 - d1)) - 1)), (select((d1 >= 0), d1, (0 - d1)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d1, d1], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d1: int32, Bound: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d1 >= 0), d1, (0 - d1)) - 1)), (select((d1 >= 0), d1, (0 - d1)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d2: int32, Bound: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d2 >= 0), d2, (0 - d2)) - 1)), (select((d2 >= 0), d2, (0 - d2)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d2, d2], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d2: int32, Bound: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d2 >= 0), d2, (0 - d2)) - 1)), (select((d2 >= 0), d2, (0 - d2)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv((blockIdx.x*512), d2), floordiv(((blockIdx.x*512) + 511), d2)), select((d2 >= 0), floordiv(((blockIdx.x*512) + 511), d2), floordiv((blockIdx.x*512), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), 0, floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2)), select((d2 >= 0), floordiv(((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512), d2), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(511, d2), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2)), select((d2 >= 0), floordiv((((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511), d2), floordiv(511, d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (floormod(((((d0: int32*d1: int32)*d2: int32) - 1) - 511), 512) == 0)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2) + 511), (((d0*d1)*d2) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv((((d0*d1)*d2) + 511), 512), floordiv((((d0*d1)*d2) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv((((d0*d1)*d2) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv((((d0*d1)*d2) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (floormod(((d0: int32*d1: int32)*d2: int32), 512) == 0)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - min(floordiv(((((d0: int32*d1: int32)*d2: int32) - 1) - 511), 512), (floordiv((((d0*d1)*d2) + 511), 512) - 1))) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - min(floordiv(((((d0: int32*d1: int32)*d2: int32) - 1) - 511), 512), (floordiv((((d0*d1)*d2) + 511), 512) - 1))) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove ((floordiv(((d0: int32*d1: int32)*d2: int32), 512) - 1) == (floordiv((((d0*d1)*d2) + 511), 512) - 1))
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove ((((floordiv((((d0: int32*d1: int32)*d2: int32) + 511), 512) - 1) - floordiv(((d0*d1)*d2), 512)) + 1) >= 0)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (floordiv(((d0: int32*d1: int32)*d2: int32), 512) == ((floordiv((((d0*d1)*d2) + 511), 512) - 1) + 1))
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2)), select((d2 >= 0), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2)), select((d2 >= 0), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2)), d1), floordiv(select((d2 >= 0), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2)), d1)), select((d1 >= 0), floordiv(select((d2 >= 0), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2)), d1), floordiv(select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2)), d1))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d2 >= 0), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2)), select((d2 >= 0), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2))), max(select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2)))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(min(select((d2 >= 0), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2)), select((d2 >= 0), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2))), d1), floordiv(max(select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2))), d1)), select((d1 >= 0), floordiv(max(select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2))), d1), floordiv(min(select((d2 >= 0), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2)), select((d2 >= 0), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2))), d1))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d2 >= 0), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2)), select((d2 >= 0), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2))), max(select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2)))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(min(select((d2 >= 0), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2)), select((d2 >= 0), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2))), d1), floordiv(max(select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2))), d1)), select((d1 >= 0), floordiv(max(select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2))), d1), floordiv(min(select((d2 >= 0), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2)), select((d2 >= 0), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2))), d1))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2)), select((d2 >= 0), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2)), select((d2 >= 0), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2)), d1), floordiv(select((d2 >= 0), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2)), d1)), select((d1 >= 0), floordiv(select((d2 >= 0), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2)), d1), floordiv(select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2)), d1))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d2 >= 0), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2)), select((d2 >= 0), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2))), max(select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2)))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(min(select((d2 >= 0), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2)), select((d2 >= 0), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2))), d1), floordiv(max(select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2))), d1)), select((d1 >= 0), floordiv(max(select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2))), d1), floordiv(min(select((d2 >= 0), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2)), select((d2 >= 0), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2))), d1))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d2 >= 0), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2)), select((d2 >= 0), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2))), max(select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2)))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d1: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d1 >= 0), floordiv(min(select((d2 >= 0), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2)), select((d2 >= 0), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2))), d1), floordiv(max(select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2))), d1)), select((d1 >= 0), floordiv(max(select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2))), d1), floordiv(min(select((d2 >= 0), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2)), select((d2 >= 0), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2))), d1))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2)), select((d2 >= 0), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2)), select((d2 >= 0), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d1: int32, Bound: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d1 >= 0), d1, (0 - d1)) - 1)), (select((d1 >= 0), d1, (0 - d1)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d1, d1], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2)), select((d2 >= 0), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2)), select((d2 >= 0), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2))], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d1: int32, Bound: (select((d1: int32 >= 0), d1, (0 - d1)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d1 >= 0), d1, (0 - d1)) - 1)), (select((d1 >= 0), d1, (0 - d1)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d2: int32, Bound: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d2 >= 0), d2, (0 - d2)) - 1)), (select((d2 >= 0), d2, (0 - d2)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d2, d2], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d2: int32, Bound: (select((d2: int32 >= 0), d2, (0 - d2)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d2 >= 0), d2, (0 - d2)) - 1)), (select((d2 >= 0), d2, (0 - d2)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d3: int32, Bound: (select((d3: int32 >= 0), d3, (0 - d3)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d3 >= 0), d3, (0 - d3)) - 1)), (select((d3 >= 0), d3, (0 - d3)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d3, d3], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:304: CHECK IN COMBINE! For Var d3: int32, Bound: (select((d3: int32 >= 0), d3, (0 - d3)) - 1)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(0 - (select((d3 >= 0), d3, (0 - d3)) - 1)), (select((d3 >= 0), d3, (0 - d3)) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2)), select((d2 >= 0), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2)), select((d2 >= 0), floordiv(select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3)), d2), floordiv(select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)), d2), floordiv(min(select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3))), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3)))], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d2: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d2 >= 0), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2)), select((d2 >= 0), floordiv(max(select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))), d2), floordiv(min(select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3))), d2))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv((blockIdx.x*512), d3), floordiv(((blockIdx.x*512) + 511), d3)), select((d3 >= 0), floordiv(((blockIdx.x*512) + 511), d3), floordiv((blockIdx.x*512), d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), 0, floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3)), select((d3 >= 0), floordiv(((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512), d3), 0)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - d3: int32) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[select((d3 >= 0), floordiv(511, d3), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3)), select((d3 >= 0), floordiv((((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511), d3), floordiv(511, d3))]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[511, (((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (floormod((((((d0: int32*d1: int32)*d2: int32)*d3: int32) - 1) - 511), 512) == 0)
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[blockIdx.x, blockIdx.x], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var threadIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ threadIdx.x: int32]: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(blockIdx.x*512), (blockIdx.x*512)], b after eval: IntervalSet[0, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[(blockIdx.x*512), ((blockIdx.x*512) + 511)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var blockIdx.x: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d0: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d1: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[d0, d0], b after eval: IntervalSet[d1, d1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d2: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(d0*d1), (d0*d1)], b after eval: IntervalSet[d2, d2]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:368: Visiting Var d3: int32
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((d0*d1)*d2), ((d0*d1)*d2)], b after eval: IntervalSet[d3, d3]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[(((d0*d1)*d2)*d3), (((d0*d1)*d2)*d3)], b after eval: IntervalSet[511, 511]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[((((d0*d1)*d2)*d3) + 511), ((((d0*d1)*d2)*d3) + 511)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[floordiv(((((d0*d1)*d2)*d3) + 511), 512), floordiv(((((d0*d1)*d2)*d3) + 511), 512)], b after eval: IntervalSet[1, 1]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:379: After Eval for [ blockIdx.x: int32]: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:476: a after eval: IntervalSet[0, (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)], b after eval: IntervalSet[512, 512]
[14:05:56] /workspace/home/codes/tvm/src/arith/int_set.cc:481: After combine: IntervalSet[0, ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1)*512)]
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (floormod((((d0: int32*d1: int32)*d2: int32)*d3: int32), 512) == 0)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR (0 - min(floordiv((((((d0: int32*d1: int32)*d2: int32)*d3: int32) - 1) - 511), 512), (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1))) with type tir.Sub
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (floordiv((((((d0: int32*d1: int32)*d2: int32)*d3: int32) - 1) - 511), 512) == (floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1))
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove ((((floordiv(((((d0: int32*d1: int32)*d2: int32)*d3: int32) + 511), 512) - 1) - floordiv((((d0*d1)*d2)*d3), 512)) + 1) >= 0)
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove True
[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = false when prove (floordiv((((d0: int32*d1: int32)*d2: int32)*d3: int32), 512) == ((floordiv(((((d0*d1)*d2)*d3) + 511), 512) - 1) + 1))
[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LoopPartition
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
  allocate(T_softmax_maxelem, float32, [d0, d1, d2]) {
    attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
    attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x < floordiv(((d0*d1)*d2), 512)) {
      if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
            if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
              if True {
                T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = -3.40282e+38f32
              }
            }
          }
        }
      }
      for (k: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
            if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
                if True {
                  T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = max((float32*)T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k*stride_7))])
                }
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
            if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
              if (((blockIdx.x*512) + threadIdx.x) < ((d0*d1)*d2)) {
                T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = -3.40282e+38f32
              }
            }
          }
        }
      }
      for (k_1: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
            if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
                if (((blockIdx.x*512) + threadIdx.x) < ((d0*d1)*d2)) {
                  T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = max((float32*)T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k_1*stride_7))])
                }
              }
            }
          }
        }
      }
    }
    attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_exp, float32, [d0, d1, d2, d3]) {
      attr [IterVar(blockIdx.x_1: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
      attr [IterVar(threadIdx.x_1: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
      if (blockIdx.x_1 < floordiv((((d0*d1)*d2)*d3), 512)) {
        if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d0) {
          if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d1) {
            if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < d2) {
              if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3) < d3) {
                if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < (d0*d1)) {
                  if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3) < ((d0*d1)*d2)) {
                    if True {
                      T_softmax_exp[((blockIdx.x_1*512) + threadIdx.x_1)] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                    }
                  }
                }
              }
            }
          }
        }
      } else {
        if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d0) {
          if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d1) {
            if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < d2) {
              if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3) < d3) {
                if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < (d0*d1)) {
                  if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3) < ((d0*d1)*d2)) {
                    if (((blockIdx.x_1*512) + threadIdx.x_1) < (((d0*d1)*d2)*d3)) {
                      T_softmax_exp[((blockIdx.x_1*512) + threadIdx.x_1)] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                    }
                  }
                }
              }
            }
          }
        }
      }
      attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
      allocate(T_softmax_expsum, float32, [d0, d1, d2]) {
        attr [IterVar(blockIdx.x_2: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
        attr [IterVar(threadIdx.x_2: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
        if (blockIdx.x_2 < floordiv(((d0*d1)*d2), 512)) {
          if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
            if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
              if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
                if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                  if True {
                    T_softmax_expsum[((blockIdx.x_2*512) + threadIdx.x_2)] = 0f32
                  }
                }
              }
            }
          }
          for (k_2: int32, 0, d3) {
            if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
              if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
                if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
                  if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                    if True {
                      T_softmax_expsum[((blockIdx.x_2*512) + threadIdx.x_2)] = ((float32*)T_softmax_expsum[((blockIdx.x_2*512) + threadIdx.x_2)] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_2)])
                    }
                  }
                }
              }
            }
          }
        } else {
          if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
            if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
              if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
                if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                  if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0*d1)*d2)) {
                    T_softmax_expsum[((blockIdx.x_2*512) + threadIdx.x_2)] = 0f32
                  }
                }
              }
            }
          }
          for (k_3: int32, 0, d3) {
            if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
              if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
                if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
                  if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                    if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0*d1)*d2)) {
                      T_softmax_expsum[((blockIdx.x_2*512) + threadIdx.x_2)] = ((float32*)T_softmax_expsum[((blockIdx.x_2*512) + threadIdx.x_2)] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_3)])
                    }
                  }
                }
              }
            }
          }
        }
        attr [IterVar(blockIdx.x_3: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
        attr [IterVar(threadIdx.x_3: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
        if (blockIdx.x_3 < floordiv((((d0*d1)*d2)*d3), 512)) {
          if (floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d0) {
            if (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d1) {
              if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < d2) {
                if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3) < d3) {
                  if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < (d0*d1)) {
                    if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3) < ((d0*d1)*d2)) {
                      if True {
                        T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[((blockIdx.x_3*512) + threadIdx.x_3)] / (float32*)T_softmax_expsum[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          if (floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d0) {
            if (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d1) {
              if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < d2) {
                if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3) < d3) {
                  if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < (d0*d1)) {
                    if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3) < ((d0*d1)*d2)) {
                      if (((blockIdx.x_3*512) + threadIdx.x_3) < (((d0*d1)*d2)*d3)) {
                        T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[((blockIdx.x_3*512) + threadIdx.x_3)] / (float32*)T_softmax_expsum[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.VectorizeLoop
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
  allocate(T_softmax_maxelem, float32, [d0, d1, d2]) {
    attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
    attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x < floordiv(((d0*d1)*d2), 512)) {
      if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
            if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
              if True {
                T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = -3.40282e+38f32
              }
            }
          }
        }
      }
      for (k: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
            if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
                if True {
                  T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = max((float32*)T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k*stride_7))])
                }
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
            if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
              if (((blockIdx.x*512) + threadIdx.x) < ((d0*d1)*d2)) {
                T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = -3.40282e+38f32
              }
            }
          }
        }
      }
      for (k_1: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
            if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
                if (((blockIdx.x*512) + threadIdx.x) < ((d0*d1)*d2)) {
                  T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = max((float32*)T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k_1*stride_7))])
                }
              }
            }
          }
        }
      }
    }
    attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_exp, float32, [d0, d1, d2, d3]) {
      attr [IterVar(blockIdx.x_1: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
      attr [IterVar(threadIdx.x_1: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
      if (blockIdx.x_1 < floordiv((((d0*d1)*d2)*d3), 512)) {
        if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d0) {
          if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d1) {
            if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < d2) {
              if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3) < d3) {
                if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < (d0*d1)) {
                  if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3) < ((d0*d1)*d2)) {
                    if True {
                      T_softmax_exp[((blockIdx.x_1*512) + threadIdx.x_1)] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                    }
                  }
                }
              }
            }
          }
        }
      } else {
        if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d0) {
          if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d1) {
            if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < d2) {
              if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3) < d3) {
                if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < (d0*d1)) {
                  if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3) < ((d0*d1)*d2)) {
                    if (((blockIdx.x_1*512) + threadIdx.x_1) < (((d0*d1)*d2)*d3)) {
                      T_softmax_exp[((blockIdx.x_1*512) + threadIdx.x_1)] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                    }
                  }
                }
              }
            }
          }
        }
      }
      attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
      allocate(T_softmax_expsum, float32, [d0, d1, d2]) {
        attr [IterVar(blockIdx.x_2: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
        attr [IterVar(threadIdx.x_2: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
        if (blockIdx.x_2 < floordiv(((d0*d1)*d2), 512)) {
          if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
            if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
              if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
                if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                  if True {
                    T_softmax_expsum[((blockIdx.x_2*512) + threadIdx.x_2)] = 0f32
                  }
                }
              }
            }
          }
          for (k_2: int32, 0, d3) {
            if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
              if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
                if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
                  if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                    if True {
                      T_softmax_expsum[((blockIdx.x_2*512) + threadIdx.x_2)] = ((float32*)T_softmax_expsum[((blockIdx.x_2*512) + threadIdx.x_2)] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_2)])
                    }
                  }
                }
              }
            }
          }
        } else {
          if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
            if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
              if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
                if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                  if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0*d1)*d2)) {
                    T_softmax_expsum[((blockIdx.x_2*512) + threadIdx.x_2)] = 0f32
                  }
                }
              }
            }
          }
          for (k_3: int32, 0, d3) {
            if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
              if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
                if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
                  if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                    if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0*d1)*d2)) {
                      T_softmax_expsum[((blockIdx.x_2*512) + threadIdx.x_2)] = ((float32*)T_softmax_expsum[((blockIdx.x_2*512) + threadIdx.x_2)] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_3)])
                    }
                  }
                }
              }
            }
          }
        }
        attr [IterVar(blockIdx.x_3: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
        attr [IterVar(threadIdx.x_3: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
        if (blockIdx.x_3 < floordiv((((d0*d1)*d2)*d3), 512)) {
          if (floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d0) {
            if (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d1) {
              if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < d2) {
                if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3) < d3) {
                  if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < (d0*d1)) {
                    if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3) < ((d0*d1)*d2)) {
                      if True {
                        T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[((blockIdx.x_3*512) + threadIdx.x_3)] / (float32*)T_softmax_expsum[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          if (floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d0) {
            if (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d1) {
              if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < d2) {
                if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3) < d3) {
                  if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < (d0*d1)) {
                    if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3) < ((d0*d1)*d2)) {
                      if (((blockIdx.x_3*512) + threadIdx.x_3) < (((d0*d1)*d2)*d3)) {
                        T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[((blockIdx.x_3*512) + threadIdx.x_3)] / (float32*)T_softmax_expsum[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectVirtualThread
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
  allocate(T_softmax_maxelem, float32, [d0, d1, d2]) {
    attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
    attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x < floordiv(((d0*d1)*d2), 512)) {
      if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
            if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
              if True {
                T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = -3.40282e+38f32
              }
            }
          }
        }
      }
      for (k: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
            if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
                if True {
                  T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = max((float32*)T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k*stride_7))])
                }
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
            if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
              if (((blockIdx.x*512) + threadIdx.x) < ((d0*d1)*d2)) {
                T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = -3.40282e+38f32
              }
            }
          }
        }
      }
      for (k_1: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
            if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
                if (((blockIdx.x*512) + threadIdx.x) < ((d0*d1)*d2)) {
                  T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = max((float32*)T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k_1*stride_7))])
                }
              }
            }
          }
        }
      }
    }
    attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_exp, float32, [d0, d1, d2, d3]) {
      attr [IterVar(blockIdx.x_1: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
      attr [IterVar(threadIdx.x_1: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
      if (blockIdx.x_1 < floordiv((((d0*d1)*d2)*d3), 512)) {
        if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d0) {
          if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d1) {
            if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < d2) {
              if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3) < d3) {
                if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < (d0*d1)) {
                  if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3) < ((d0*d1)*d2)) {
                    if True {
                      T_softmax_exp[((blockIdx.x_1*512) + threadIdx.x_1)] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                    }
                  }
                }
              }
            }
          }
        }
      } else {
        if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d0) {
          if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d1) {
            if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < d2) {
              if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3) < d3) {
                if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < (d0*d1)) {
                  if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3) < ((d0*d1)*d2)) {
                    if (((blockIdx.x_1*512) + threadIdx.x_1) < (((d0*d1)*d2)*d3)) {
                      T_softmax_exp[((blockIdx.x_1*512) + threadIdx.x_1)] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                    }
                  }
                }
              }
            }
          }
        }
      }
      attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
      allocate(T_softmax_expsum, float32, [d0, d1, d2]) {
        attr [IterVar(blockIdx.x_2: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
        attr [IterVar(threadIdx.x_2: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
        if (blockIdx.x_2 < floordiv(((d0*d1)*d2), 512)) {
          if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
            if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
              if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
                if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                  if True {
                    T_softmax_expsum[((blockIdx.x_2*512) + threadIdx.x_2)] = 0f32
                  }
                }
              }
            }
          }
          for (k_2: int32, 0, d3) {
            if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
              if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
                if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
                  if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                    if True {
                      T_softmax_expsum[((blockIdx.x_2*512) + threadIdx.x_2)] = ((float32*)T_softmax_expsum[((blockIdx.x_2*512) + threadIdx.x_2)] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_2)])
                    }
                  }
                }
              }
            }
          }
        } else {
          if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
            if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
              if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
                if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                  if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0*d1)*d2)) {
                    T_softmax_expsum[((blockIdx.x_2*512) + threadIdx.x_2)] = 0f32
                  }
                }
              }
            }
          }
          for (k_3: int32, 0, d3) {
            if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
              if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
                if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
                  if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                    if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0*d1)*d2)) {
                      T_softmax_expsum[((blockIdx.x_2*512) + threadIdx.x_2)] = ((float32*)T_softmax_expsum[((blockIdx.x_2*512) + threadIdx.x_2)] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_3)])
                    }
                  }
                }
              }
            }
          }
        }
        attr [IterVar(blockIdx.x_3: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
        attr [IterVar(threadIdx.x_3: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
        if (blockIdx.x_3 < floordiv((((d0*d1)*d2)*d3), 512)) {
          if (floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d0) {
            if (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d1) {
              if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < d2) {
                if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3) < d3) {
                  if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < (d0*d1)) {
                    if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3) < ((d0*d1)*d2)) {
                      if True {
                        T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[((blockIdx.x_3*512) + threadIdx.x_3)] / (float32*)T_softmax_expsum[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          if (floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d0) {
            if (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d1) {
              if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < d2) {
                if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3) < d3) {
                  if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < (d0*d1)) {
                    if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3) < ((d0*d1)*d2)) {
                      if (((blockIdx.x_3*512) + threadIdx.x_3) < (((d0*d1)*d2)*d3)) {
                        T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[((blockIdx.x_3*512) + threadIdx.x_3)] / (float32*)T_softmax_expsum[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InjectDoubleBuffer
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
  allocate(T_softmax_maxelem, float32, [d0, d1, d2]) {
    attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
    attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x < floordiv(((d0*d1)*d2), 512)) {
      if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
            if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
              if True {
                T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = -3.40282e+38f32
              }
            }
          }
        }
      }
      for (k: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
            if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
                if True {
                  T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = max((float32*)T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k*stride_7))])
                }
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
            if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
              if (((blockIdx.x*512) + threadIdx.x) < ((d0*d1)*d2)) {
                T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = -3.40282e+38f32
              }
            }
          }
        }
      }
      for (k_1: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
            if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
                if (((blockIdx.x*512) + threadIdx.x) < ((d0*d1)*d2)) {
                  T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = max((float32*)T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k_1*stride_7))])
                }
              }
            }
          }
        }
      }
    }
    attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_exp, float32, [d0, d1, d2, d3]) {
      attr [IterVar(blockIdx.x_1: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
      attr [IterVar(threadIdx.x_1: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
      if (blockIdx.x_1 < floordiv((((d0*d1)*d2)*d3), 512)) {
        if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d0) {
          if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d1) {
            if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < d2) {
              if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3) < d3) {
                if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < (d0*d1)) {
                  if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3) < ((d0*d1)*d2)) {
                    if True {
                      T_softmax_exp[((blockIdx.x_1*512) + threadIdx.x_1)] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                    }
                  }
                }
              }
            }
          }
        }
      } else {
        if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d0) {
          if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d1) {
            if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < d2) {
              if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3) < d3) {
                if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < (d0*d1)) {
                  if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3) < ((d0*d1)*d2)) {
                    if (((blockIdx.x_1*512) + threadIdx.x_1) < (((d0*d1)*d2)*d3)) {
                      T_softmax_exp[((blockIdx.x_1*512) + threadIdx.x_1)] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                    }
                  }
                }
              }
            }
          }
        }
      }
      attr [T_softmax_expsum: Pointer(float32)] "storage_scope" = "global";
      allocate(T_softmax_expsum, float32, [d0, d1, d2]) {
        attr [IterVar(blockIdx.x_2: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
        attr [IterVar(threadIdx.x_2: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
        if (blockIdx.x_2 < floordiv(((d0*d1)*d2), 512)) {
          if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
            if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
              if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
                if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                  if True {
                    T_softmax_expsum[((blockIdx.x_2*512) + threadIdx.x_2)] = 0f32
                  }
                }
              }
            }
          }
          for (k_2: int32, 0, d3) {
            if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
              if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
                if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
                  if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                    if True {
                      T_softmax_expsum[((blockIdx.x_2*512) + threadIdx.x_2)] = ((float32*)T_softmax_expsum[((blockIdx.x_2*512) + threadIdx.x_2)] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_2)])
                    }
                  }
                }
              }
            }
          }
        } else {
          if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
            if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
              if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
                if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                  if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0*d1)*d2)) {
                    T_softmax_expsum[((blockIdx.x_2*512) + threadIdx.x_2)] = 0f32
                  }
                }
              }
            }
          }
          for (k_3: int32, 0, d3) {
            if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
              if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
                if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
                  if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                    if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0*d1)*d2)) {
                      T_softmax_expsum[((blockIdx.x_2*512) + threadIdx.x_2)] = ((float32*)T_softmax_expsum[((blockIdx.x_2*512) + threadIdx.x_2)] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_3)])
                    }
                  }
                }
              }
            }
          }
        }
        attr [IterVar(blockIdx.x_3: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
        attr [IterVar(threadIdx.x_3: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
        if (blockIdx.x_3 < floordiv((((d0*d1)*d2)*d3), 512)) {
          if (floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d0) {
            if (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d1) {
              if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < d2) {
                if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3) < d3) {
                  if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < (d0*d1)) {
                    if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3) < ((d0*d1)*d2)) {
                      if True {
                        T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[((blockIdx.x_3*512) + threadIdx.x_3)] / (float32*)T_softmax_expsum[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          if (floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d0) {
            if (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d1) {
              if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < d2) {
                if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3) < d3) {
                  if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < (d0*d1)) {
                    if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3) < ((d0*d1)*d2)) {
                      if (((blockIdx.x_3*512) + threadIdx.x_3) < (((d0*d1)*d2)*d3)) {
                        T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[((blockIdx.x_3*512) + threadIdx.x_3)] / (float32*)T_softmax_expsum[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}


[14:05:56] /workspace/home/codes/tvm/src/arith/analyzer.cc:140: Res = true when prove (floormod(max((((d0: int32*d1: int32)*d2: int32)*32), (((d0*d1)*d2)*32)), 32) == 0)
[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.StorageRewrite
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
  allocate(T_softmax_maxelem, float32, [((d0*d1)*d2)]);
  attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
  allocate(T_softmax_exp, float32, [(((d0*d1)*d2)*d3)]) {
    attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
    attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x < floordiv(((d0*d1)*d2), 512)) {
      if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
            if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
              if True {
                T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = -3.40282e+38f32
              }
            }
          }
        }
      }
      for (k: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
            if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
                if True {
                  T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = max((float32*)T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k*stride_7))])
                }
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
            if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
              if (((blockIdx.x*512) + threadIdx.x) < ((d0*d1)*d2)) {
                T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = -3.40282e+38f32
              }
            }
          }
        }
      }
      for (k_1: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
            if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
                if (((blockIdx.x*512) + threadIdx.x) < ((d0*d1)*d2)) {
                  T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = max((float32*)T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k_1*stride_7))])
                }
              }
            }
          }
        }
      }
    }
     {
      attr [IterVar(blockIdx.x_1: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
      attr [IterVar(threadIdx.x_1: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
      if (blockIdx.x_1 < floordiv((((d0*d1)*d2)*d3), 512)) {
        if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d0) {
          if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d1) {
            if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < d2) {
              if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3) < d3) {
                if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < (d0*d1)) {
                  if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3) < ((d0*d1)*d2)) {
                    if True {
                      T_softmax_exp[((blockIdx.x_1*512) + threadIdx.x_1)] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                    }
                  }
                }
              }
            }
          }
        }
      } else {
        if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d0) {
          if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d1) {
            if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < d2) {
              if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3) < d3) {
                if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < (d0*d1)) {
                  if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3) < ((d0*d1)*d2)) {
                    if (((blockIdx.x_1*512) + threadIdx.x_1) < (((d0*d1)*d2)*d3)) {
                      T_softmax_exp[((blockIdx.x_1*512) + threadIdx.x_1)] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                    }
                  }
                }
              }
            }
          }
        }
      }
       {
        attr [IterVar(blockIdx.x_2: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
        attr [IterVar(threadIdx.x_2: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
        if (blockIdx.x_2 < floordiv(((d0*d1)*d2), 512)) {
          if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
            if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
              if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
                if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                  if True {
                    T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = 0f32
                  }
                }
              }
            }
          }
          for (k_2: int32, 0, d3) {
            if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
              if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
                if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
                  if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                    if True {
                      T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = ((float32*)T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_2)])
                    }
                  }
                }
              }
            }
          }
        } else {
          if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
            if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
              if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
                if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                  if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0*d1)*d2)) {
                    T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = 0f32
                  }
                }
              }
            }
          }
          for (k_3: int32, 0, d3) {
            if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
              if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
                if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
                  if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                    if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0*d1)*d2)) {
                      T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = ((float32*)T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_3)])
                    }
                  }
                }
              }
            }
          }
        }
        attr [IterVar(blockIdx.x_3: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
        attr [IterVar(threadIdx.x_3: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
        if (blockIdx.x_3 < floordiv((((d0*d1)*d2)*d3), 512)) {
          if (floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d0) {
            if (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d1) {
              if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < d2) {
                if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3) < d3) {
                  if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < (d0*d1)) {
                    if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3) < ((d0*d1)*d2)) {
                      if True {
                        T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[((blockIdx.x_3*512) + threadIdx.x_3)] / (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          if (floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d0) {
            if (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d1) {
              if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < d2) {
                if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3) < d3) {
                  if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < (d0*d1)) {
                    if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3) < ((d0*d1)*d2)) {
                      if (((blockIdx.x_3*512) + threadIdx.x_3) < (((d0*d1)*d2)*d3)) {
                        T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[((blockIdx.x_3*512) + threadIdx.x_3)] / (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.UnrollLoop
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
  allocate(T_softmax_maxelem, float32, [((d0*d1)*d2)]);
  attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
  allocate(T_softmax_exp, float32, [(((d0*d1)*d2)*d3)]) {
    attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
    attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x < floordiv(((d0*d1)*d2), 512)) {
      if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
            if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
              if True {
                T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = -3.40282e+38f32
              }
            }
          }
        }
      }
      for (k: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
            if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
                if True {
                  T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = max((float32*)T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k*stride_7))])
                }
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
            if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
              if (((blockIdx.x*512) + threadIdx.x) < ((d0*d1)*d2)) {
                T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = -3.40282e+38f32
              }
            }
          }
        }
      }
      for (k_1: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
            if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
                if (((blockIdx.x*512) + threadIdx.x) < ((d0*d1)*d2)) {
                  T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = max((float32*)T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k_1*stride_7))])
                }
              }
            }
          }
        }
      }
    }
     {
      attr [IterVar(blockIdx.x_1: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
      attr [IterVar(threadIdx.x_1: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
      if (blockIdx.x_1 < floordiv((((d0*d1)*d2)*d3), 512)) {
        if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d0) {
          if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d1) {
            if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < d2) {
              if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3) < d3) {
                if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < (d0*d1)) {
                  if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3) < ((d0*d1)*d2)) {
                    if True {
                      T_softmax_exp[((blockIdx.x_1*512) + threadIdx.x_1)] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                    }
                  }
                }
              }
            }
          }
        }
      } else {
        if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d0) {
          if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d1) {
            if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < d2) {
              if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3) < d3) {
                if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < (d0*d1)) {
                  if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3) < ((d0*d1)*d2)) {
                    if (((blockIdx.x_1*512) + threadIdx.x_1) < (((d0*d1)*d2)*d3)) {
                      T_softmax_exp[((blockIdx.x_1*512) + threadIdx.x_1)] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                    }
                  }
                }
              }
            }
          }
        }
      }
       {
        attr [IterVar(blockIdx.x_2: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
        attr [IterVar(threadIdx.x_2: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
        if (blockIdx.x_2 < floordiv(((d0*d1)*d2), 512)) {
          if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
            if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
              if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
                if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                  if True {
                    T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = 0f32
                  }
                }
              }
            }
          }
          for (k_2: int32, 0, d3) {
            if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
              if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
                if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
                  if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                    if True {
                      T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = ((float32*)T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_2)])
                    }
                  }
                }
              }
            }
          }
        } else {
          if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
            if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
              if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
                if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                  if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0*d1)*d2)) {
                    T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = 0f32
                  }
                }
              }
            }
          }
          for (k_3: int32, 0, d3) {
            if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
              if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
                if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
                  if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                    if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0*d1)*d2)) {
                      T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = ((float32*)T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_3)])
                    }
                  }
                }
              }
            }
          }
        }
        attr [IterVar(blockIdx.x_3: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
        attr [IterVar(threadIdx.x_3: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
        if (blockIdx.x_3 < floordiv((((d0*d1)*d2)*d3), 512)) {
          if (floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d0) {
            if (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d1) {
              if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < d2) {
                if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3) < d3) {
                  if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < (d0*d1)) {
                    if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3) < ((d0*d1)*d2)) {
                      if True {
                        T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[((blockIdx.x_3*512) + threadIdx.x_3)] / (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          if (floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d0) {
            if (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d1) {
              if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < d2) {
                if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3) < d3) {
                  if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < (d0*d1)) {
                    if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3) < ((d0*d1)*d2)) {
                      if (((blockIdx.x_3*512) + threadIdx.x_3) < (((d0*d1)*d2)*d3)) {
                        T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[((blockIdx.x_3*512) + threadIdx.x_3)] / (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
  allocate(T_softmax_maxelem, float32, [((d0*d1)*d2)]);
  attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
  allocate(T_softmax_exp, float32, [(((d0*d1)*d2)*d3)]) {
    attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
    attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x < floordiv(((d0*d1)*d2), 512)) {
      if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
            if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
              T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = -3.40282e+38f32
            }
          }
        }
      }
      for (k: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
            if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
                T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = max((float32*)T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k*stride_7))])
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
            if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
              if (((blockIdx.x*512) + threadIdx.x) < ((d0*d1)*d2)) {
                T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = -3.40282e+38f32
              }
            }
          }
        }
      }
      for (k_1: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
            if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
                if (((blockIdx.x*512) + threadIdx.x) < ((d0*d1)*d2)) {
                  T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = max((float32*)T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k_1*stride_7))])
                }
              }
            }
          }
        }
      }
    }
     {
      attr [IterVar(blockIdx.x_1: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
      attr [IterVar(threadIdx.x_1: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
      if (blockIdx.x_1 < floordiv((((d0*d1)*d2)*d3), 512)) {
        if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d0) {
          if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d1) {
            if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < d2) {
              if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3) < d3) {
                if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < (d0*d1)) {
                  if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3) < ((d0*d1)*d2)) {
                    T_softmax_exp[((blockIdx.x_1*512) + threadIdx.x_1)] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                  }
                }
              }
            }
          }
        }
      } else {
        if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d0) {
          if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d1) {
            if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < d2) {
              if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3) < d3) {
                if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < (d0*d1)) {
                  if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3) < ((d0*d1)*d2)) {
                    if (((blockIdx.x_1*512) + threadIdx.x_1) < (((d0*d1)*d2)*d3)) {
                      T_softmax_exp[((blockIdx.x_1*512) + threadIdx.x_1)] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                    }
                  }
                }
              }
            }
          }
        }
      }
       {
        attr [IterVar(blockIdx.x_2: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
        attr [IterVar(threadIdx.x_2: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
        if (blockIdx.x_2 < floordiv(((d0*d1)*d2), 512)) {
          if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
            if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
              if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
                if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                  T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = 0f32
                }
              }
            }
          }
          for (k_2: int32, 0, d3) {
            if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
              if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
                if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
                  if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                    T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = ((float32*)T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_2)])
                  }
                }
              }
            }
          }
        } else {
          if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
            if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
              if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
                if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                  if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0*d1)*d2)) {
                    T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = 0f32
                  }
                }
              }
            }
          }
          for (k_3: int32, 0, d3) {
            if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
              if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
                if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
                  if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                    if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0*d1)*d2)) {
                      T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = ((float32*)T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_3)])
                    }
                  }
                }
              }
            }
          }
        }
        attr [IterVar(blockIdx.x_3: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
        attr [IterVar(threadIdx.x_3: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
        if (blockIdx.x_3 < floordiv((((d0*d1)*d2)*d3), 512)) {
          if (floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d0) {
            if (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d1) {
              if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < d2) {
                if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3) < d3) {
                  if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < (d0*d1)) {
                    if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3) < ((d0*d1)*d2)) {
                      T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[((blockIdx.x_3*512) + threadIdx.x_3)] / (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                    }
                  }
                }
              }
            }
          }
        } else {
          if (floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d0) {
            if (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d1) {
              if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < d2) {
                if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3) < d3) {
                  if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < (d0*d1)) {
                    if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3) < ((d0*d1)*d2)) {
                      if (((blockIdx.x_3*512) + threadIdx.x_3) < (((d0*d1)*d2)*d3)) {
                        T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[((blockIdx.x_3*512) + threadIdx.x_3)] / (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.RemoveNoOp
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
  allocate(T_softmax_maxelem, float32, [((d0*d1)*d2)]);
  attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
  allocate(T_softmax_exp, float32, [(((d0*d1)*d2)*d3)]) {
    attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
    attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x < floordiv(((d0*d1)*d2), 512)) {
      if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
            if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
              T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = -3.40282e+38f32
            }
          }
        }
      }
      for (k: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
            if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
                T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = max((float32*)T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k*stride_7))])
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
            if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
              if (((blockIdx.x*512) + threadIdx.x) < ((d0*d1)*d2)) {
                T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = -3.40282e+38f32
              }
            }
          }
        }
      }
      for (k_1: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
            if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
                if (((blockIdx.x*512) + threadIdx.x) < ((d0*d1)*d2)) {
                  T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = max((float32*)T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k_1*stride_7))])
                }
              }
            }
          }
        }
      }
    }
    attr [IterVar(blockIdx.x_1: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
    attr [IterVar(threadIdx.x_1: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x_1 < floordiv((((d0*d1)*d2)*d3), 512)) {
      if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d0) {
        if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d1) {
          if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < d2) {
            if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3) < d3) {
              if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < (d0*d1)) {
                if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3) < ((d0*d1)*d2)) {
                  T_softmax_exp[((blockIdx.x_1*512) + threadIdx.x_1)] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                }
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d0) {
        if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d1) {
          if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < d2) {
            if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3) < d3) {
              if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < (d0*d1)) {
                if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3) < ((d0*d1)*d2)) {
                  if (((blockIdx.x_1*512) + threadIdx.x_1) < (((d0*d1)*d2)*d3)) {
                    T_softmax_exp[((blockIdx.x_1*512) + threadIdx.x_1)] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                  }
                }
              }
            }
          }
        }
      }
    }
    attr [IterVar(blockIdx.x_2: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
    attr [IterVar(threadIdx.x_2: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x_2 < floordiv(((d0*d1)*d2), 512)) {
      if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
          if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
            if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
              T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = 0f32
            }
          }
        }
      }
      for (k_2: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
            if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
              if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = ((float32*)T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_2)])
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
          if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
            if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
              if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0*d1)*d2)) {
                T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = 0f32
              }
            }
          }
        }
      }
      for (k_3: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
            if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
              if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0*d1)*d2)) {
                  T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = ((float32*)T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_3)])
                }
              }
            }
          }
        }
      }
    }
    attr [IterVar(blockIdx.x_3: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
    attr [IterVar(threadIdx.x_3: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x_3 < floordiv((((d0*d1)*d2)*d3), 512)) {
      if (floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d0) {
        if (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d1) {
          if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < d2) {
            if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3) < d3) {
              if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < (d0*d1)) {
                if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3) < ((d0*d1)*d2)) {
                  T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[((blockIdx.x_3*512) + threadIdx.x_3)] / (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                }
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d0) {
        if (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d1) {
          if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < d2) {
            if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3) < d3) {
              if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < (d0*d1)) {
                if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3) < ((d0*d1)*d2)) {
                  if (((blockIdx.x_3*512) + threadIdx.x_3) < (((d0*d1)*d2)*d3)) {
                    T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[((blockIdx.x_3*512) + threadIdx.x_3)] / (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.RewriteUnsafeSelect
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
  allocate(T_softmax_maxelem, float32, [((d0*d1)*d2)]);
  attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
  allocate(T_softmax_exp, float32, [(((d0*d1)*d2)*d3)]) {
    attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
    attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x < floordiv(((d0*d1)*d2), 512)) {
      if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
            if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
              T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = -3.40282e+38f32
            }
          }
        }
      }
      for (k: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
            if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
                T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = max((float32*)T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k*stride_7))])
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
            if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
              if (((blockIdx.x*512) + threadIdx.x) < ((d0*d1)*d2)) {
                T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = -3.40282e+38f32
              }
            }
          }
        }
      }
      for (k_1: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
            if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
                if (((blockIdx.x*512) + threadIdx.x) < ((d0*d1)*d2)) {
                  T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = max((float32*)T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k_1*stride_7))])
                }
              }
            }
          }
        }
      }
    }
    attr [IterVar(blockIdx.x_1: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
    attr [IterVar(threadIdx.x_1: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x_1 < floordiv((((d0*d1)*d2)*d3), 512)) {
      if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d0) {
        if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d1) {
          if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < d2) {
            if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3) < d3) {
              if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < (d0*d1)) {
                if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3) < ((d0*d1)*d2)) {
                  T_softmax_exp[((blockIdx.x_1*512) + threadIdx.x_1)] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                }
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d0) {
        if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d1) {
          if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < d2) {
            if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3) < d3) {
              if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < (d0*d1)) {
                if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3) < ((d0*d1)*d2)) {
                  if (((blockIdx.x_1*512) + threadIdx.x_1) < (((d0*d1)*d2)*d3)) {
                    T_softmax_exp[((blockIdx.x_1*512) + threadIdx.x_1)] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                  }
                }
              }
            }
          }
        }
      }
    }
    attr [IterVar(blockIdx.x_2: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
    attr [IterVar(threadIdx.x_2: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x_2 < floordiv(((d0*d1)*d2), 512)) {
      if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
          if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
            if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
              T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = 0f32
            }
          }
        }
      }
      for (k_2: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
            if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
              if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = ((float32*)T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_2)])
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
          if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
            if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
              if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0*d1)*d2)) {
                T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = 0f32
              }
            }
          }
        }
      }
      for (k_3: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
            if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
              if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0*d1)*d2)) {
                  T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = ((float32*)T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_3)])
                }
              }
            }
          }
        }
      }
    }
    attr [IterVar(blockIdx.x_3: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
    attr [IterVar(threadIdx.x_3: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x_3 < floordiv((((d0*d1)*d2)*d3), 512)) {
      if (floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d0) {
        if (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d1) {
          if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < d2) {
            if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3) < d3) {
              if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < (d0*d1)) {
                if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3) < ((d0*d1)*d2)) {
                  T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[((blockIdx.x_3*512) + threadIdx.x_3)] / (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                }
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d0) {
        if (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d1) {
          if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < d2) {
            if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3) < d3) {
              if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < (d0*d1)) {
                if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3) < ((d0*d1)*d2)) {
                  if (((blockIdx.x_3*512) + threadIdx.x_3) < (((d0*d1)*d2)*d3)) {
                    T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[((blockIdx.x_3*512) + threadIdx.x_3)] / (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.HoistIfThenElse
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
  allocate(T_softmax_maxelem, float32, [((d0*d1)*d2)]);
  attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
  allocate(T_softmax_exp, float32, [(((d0*d1)*d2)*d3)]) {
    attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
    attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x < floordiv(((d0*d1)*d2), 512)) {
      if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
            if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
              T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = -3.40282e+38f32
            }
          }
        }
      }
      for (k: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
            if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
                T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = max((float32*)T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k*stride_7))])
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
            if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
              if (((blockIdx.x*512) + threadIdx.x) < ((d0*d1)*d2)) {
                T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = -3.40282e+38f32
              }
            }
          }
        }
      }
      for (k_1: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
            if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
                if (((blockIdx.x*512) + threadIdx.x) < ((d0*d1)*d2)) {
                  T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = max((float32*)T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k_1*stride_7))])
                }
              }
            }
          }
        }
      }
    }
    attr [IterVar(blockIdx.x_1: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
    attr [IterVar(threadIdx.x_1: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x_1 < floordiv((((d0*d1)*d2)*d3), 512)) {
      if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d0) {
        if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d1) {
          if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < d2) {
            if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3) < d3) {
              if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < (d0*d1)) {
                if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3) < ((d0*d1)*d2)) {
                  T_softmax_exp[((blockIdx.x_1*512) + threadIdx.x_1)] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                }
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d0) {
        if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d1) {
          if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < d2) {
            if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3) < d3) {
              if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < (d0*d1)) {
                if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3) < ((d0*d1)*d2)) {
                  if (((blockIdx.x_1*512) + threadIdx.x_1) < (((d0*d1)*d2)*d3)) {
                    T_softmax_exp[((blockIdx.x_1*512) + threadIdx.x_1)] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                  }
                }
              }
            }
          }
        }
      }
    }
    attr [IterVar(blockIdx.x_2: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
    attr [IterVar(threadIdx.x_2: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x_2 < floordiv(((d0*d1)*d2), 512)) {
      if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
          if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
            if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
              T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = 0f32
            }
          }
        }
      }
      for (k_2: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
            if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
              if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = ((float32*)T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_2)])
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
          if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
            if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
              if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0*d1)*d2)) {
                T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = 0f32
              }
            }
          }
        }
      }
      for (k_3: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
            if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
              if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0*d1)*d2)) {
                  T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = ((float32*)T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_3)])
                }
              }
            }
          }
        }
      }
    }
    attr [IterVar(blockIdx.x_3: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
    attr [IterVar(threadIdx.x_3: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x_3 < floordiv((((d0*d1)*d2)*d3), 512)) {
      if (floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d0) {
        if (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d1) {
          if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < d2) {
            if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3) < d3) {
              if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < (d0*d1)) {
                if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3) < ((d0*d1)*d2)) {
                  T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[((blockIdx.x_3*512) + threadIdx.x_3)] / (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                }
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d0) {
        if (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d1) {
          if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < d2) {
            if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3) < d3) {
              if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < (d0*d1)) {
                if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3) < ((d0*d1)*d2)) {
                  if (((blockIdx.x_3*512) + threadIdx.x_3) < (((d0*d1)*d2)*d3)) {
                    T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[((blockIdx.x_3*512) + threadIdx.x_3)] / (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}


[14:05:56] /workspace/home/codes/tvm/src/relay/backend/compile_engine.cc:778: POS4
[14:05:56] /workspace/home/codes/tvm/src/relay/backend/vm/compiler.cc:551: Lower Function End
[14:05:56] /workspace/home/codes/tvm/src/relay/backend/vm/compiler.cc:982: LOWER END

[14:05:56] /workspace/home/codes/tvm/src/relay/backend/vm/compiler.cc:1157: CODEGEN START

[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass BindTarget
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
  allocate(T_softmax_maxelem, float32, [((d0*d1)*d2)]);
  attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
  allocate(T_softmax_exp, float32, [(((d0*d1)*d2)*d3)]) {
    attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
    attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x < floordiv(((d0*d1)*d2), 512)) {
      if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
            if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
              T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = -3.40282e+38f32
            }
          }
        }
      }
      for (k: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
            if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
                T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = max((float32*)T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k*stride_7))])
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
            if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
              if (((blockIdx.x*512) + threadIdx.x) < ((d0*d1)*d2)) {
                T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = -3.40282e+38f32
              }
            }
          }
        }
      }
      for (k_1: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
            if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
                if (((blockIdx.x*512) + threadIdx.x) < ((d0*d1)*d2)) {
                  T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = max((float32*)T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k_1*stride_7))])
                }
              }
            }
          }
        }
      }
    }
    attr [IterVar(blockIdx.x_1: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
    attr [IterVar(threadIdx.x_1: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x_1 < floordiv((((d0*d1)*d2)*d3), 512)) {
      if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d0) {
        if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d1) {
          if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < d2) {
            if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3) < d3) {
              if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < (d0*d1)) {
                if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3) < ((d0*d1)*d2)) {
                  T_softmax_exp[((blockIdx.x_1*512) + threadIdx.x_1)] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                }
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d0) {
        if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d1) {
          if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < d2) {
            if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3) < d3) {
              if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < (d0*d1)) {
                if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3) < ((d0*d1)*d2)) {
                  if (((blockIdx.x_1*512) + threadIdx.x_1) < (((d0*d1)*d2)*d3)) {
                    T_softmax_exp[((blockIdx.x_1*512) + threadIdx.x_1)] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                  }
                }
              }
            }
          }
        }
      }
    }
    attr [IterVar(blockIdx.x_2: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
    attr [IterVar(threadIdx.x_2: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x_2 < floordiv(((d0*d1)*d2), 512)) {
      if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
          if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
            if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
              T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = 0f32
            }
          }
        }
      }
      for (k_2: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
            if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
              if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = ((float32*)T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_2)])
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
          if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
            if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
              if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0*d1)*d2)) {
                T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = 0f32
              }
            }
          }
        }
      }
      for (k_3: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
            if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
              if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0*d1)*d2)) {
                  T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = ((float32*)T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_3)])
                }
              }
            }
          }
        }
      }
    }
    attr [IterVar(blockIdx.x_3: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
    attr [IterVar(threadIdx.x_3: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x_3 < floordiv((((d0*d1)*d2)*d3), 512)) {
      if (floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d0) {
        if (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d1) {
          if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < d2) {
            if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3) < d3) {
              if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < (d0*d1)) {
                if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3) < ((d0*d1)*d2)) {
                  T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[((blockIdx.x_3*512) + threadIdx.x_3)] / (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                }
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d0) {
        if (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d1) {
          if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < d2) {
            if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3) < d3) {
              if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < (d0*d1)) {
                if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3) < ((d0*d1)*d2)) {
                  if (((blockIdx.x_3*512) + threadIdx.x_3) < (((d0*d1)*d2)*d3)) {
                    T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[((blockIdx.x_3*512) + threadIdx.x_3)] / (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.VerifyMemory
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
  allocate(T_softmax_maxelem, float32, [((d0*d1)*d2)]);
  attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
  allocate(T_softmax_exp, float32, [(((d0*d1)*d2)*d3)]) {
    attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
    attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x < floordiv(((d0*d1)*d2), 512)) {
      if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
            if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
              T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = -3.40282e+38f32
            }
          }
        }
      }
      for (k: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
            if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
                T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = max((float32*)T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k*stride_7))])
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
            if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
              if (((blockIdx.x*512) + threadIdx.x) < ((d0*d1)*d2)) {
                T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = -3.40282e+38f32
              }
            }
          }
        }
      }
      for (k_1: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
            if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
                if (((blockIdx.x*512) + threadIdx.x) < ((d0*d1)*d2)) {
                  T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = max((float32*)T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k_1*stride_7))])
                }
              }
            }
          }
        }
      }
    }
    attr [IterVar(blockIdx.x_1: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
    attr [IterVar(threadIdx.x_1: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x_1 < floordiv((((d0*d1)*d2)*d3), 512)) {
      if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d0) {
        if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d1) {
          if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < d2) {
            if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3) < d3) {
              if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < (d0*d1)) {
                if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3) < ((d0*d1)*d2)) {
                  T_softmax_exp[((blockIdx.x_1*512) + threadIdx.x_1)] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                }
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d0) {
        if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d1) {
          if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < d2) {
            if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3) < d3) {
              if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < (d0*d1)) {
                if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3) < ((d0*d1)*d2)) {
                  if (((blockIdx.x_1*512) + threadIdx.x_1) < (((d0*d1)*d2)*d3)) {
                    T_softmax_exp[((blockIdx.x_1*512) + threadIdx.x_1)] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                  }
                }
              }
            }
          }
        }
      }
    }
    attr [IterVar(blockIdx.x_2: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
    attr [IterVar(threadIdx.x_2: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x_2 < floordiv(((d0*d1)*d2), 512)) {
      if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
          if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
            if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
              T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = 0f32
            }
          }
        }
      }
      for (k_2: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
            if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
              if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = ((float32*)T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_2)])
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
          if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
            if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
              if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0*d1)*d2)) {
                T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = 0f32
              }
            }
          }
        }
      }
      for (k_3: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
            if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
              if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0*d1)*d2)) {
                  T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = ((float32*)T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_3)])
                }
              }
            }
          }
        }
      }
    }
    attr [IterVar(blockIdx.x_3: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
    attr [IterVar(threadIdx.x_3: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x_3 < floordiv((((d0*d1)*d2)*d3), 512)) {
      if (floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d0) {
        if (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d1) {
          if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < d2) {
            if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3) < d3) {
              if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < (d0*d1)) {
                if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3) < ((d0*d1)*d2)) {
                  T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[((blockIdx.x_3*512) + threadIdx.x_3)] / (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                }
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d0) {
        if (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d1) {
          if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < d2) {
            if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3) < d3) {
              if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < (d0*d1)) {
                if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3) < ((d0*d1)*d2)) {
                  if (((blockIdx.x_3*512) + threadIdx.x_3) < (((d0*d1)*d2)*d3)) {
                    T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[((blockIdx.x_3*512) + threadIdx.x_3)] / (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.ThreadSync
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
  allocate(T_softmax_maxelem, float32, [((d0*d1)*d2)]);
  attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
  allocate(T_softmax_exp, float32, [(((d0*d1)*d2)*d3)]) {
    attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
    attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x < floordiv(((d0*d1)*d2), 512)) {
      if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
            if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
              T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = -3.40282e+38f32
            }
          }
        }
      }
      for (k: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
            if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
                T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = max((float32*)T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k*stride_7))])
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
            if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
              if (((blockIdx.x*512) + threadIdx.x) < ((d0*d1)*d2)) {
                T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = -3.40282e+38f32
              }
            }
          }
        }
      }
      for (k_1: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
            if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
                if (((blockIdx.x*512) + threadIdx.x) < ((d0*d1)*d2)) {
                  T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = max((float32*)T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k_1*stride_7))])
                }
              }
            }
          }
        }
      }
    }
    attr [IterVar(blockIdx.x_1: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
    attr [IterVar(threadIdx.x_1: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x_1 < floordiv((((d0*d1)*d2)*d3), 512)) {
      if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d0) {
        if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d1) {
          if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < d2) {
            if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3) < d3) {
              if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < (d0*d1)) {
                if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3) < ((d0*d1)*d2)) {
                  T_softmax_exp[((blockIdx.x_1*512) + threadIdx.x_1)] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                }
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d0) {
        if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d1) {
          if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < d2) {
            if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3) < d3) {
              if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < (d0*d1)) {
                if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3) < ((d0*d1)*d2)) {
                  if (((blockIdx.x_1*512) + threadIdx.x_1) < (((d0*d1)*d2)*d3)) {
                    T_softmax_exp[((blockIdx.x_1*512) + threadIdx.x_1)] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                  }
                }
              }
            }
          }
        }
      }
    }
    attr [IterVar(blockIdx.x_2: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
    attr [IterVar(threadIdx.x_2: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x_2 < floordiv(((d0*d1)*d2), 512)) {
      if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
          if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
            if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
              T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = 0f32
            }
          }
        }
      }
      for (k_2: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
            if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
              if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = ((float32*)T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_2)])
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
          if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
            if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
              if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0*d1)*d2)) {
                T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = 0f32
              }
            }
          }
        }
      }
      for (k_3: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
            if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
              if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0*d1)*d2)) {
                  T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = ((float32*)T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_3)])
                }
              }
            }
          }
        }
      }
    }
    attr [IterVar(blockIdx.x_3: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
    attr [IterVar(threadIdx.x_3: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x_3 < floordiv((((d0*d1)*d2)*d3), 512)) {
      if (floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d0) {
        if (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d1) {
          if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < d2) {
            if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3) < d3) {
              if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < (d0*d1)) {
                if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3) < ((d0*d1)*d2)) {
                  T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[((blockIdx.x_3*512) + threadIdx.x_3)] / (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                }
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d0) {
        if (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d1) {
          if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < d2) {
            if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3) < d3) {
              if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < (d0*d1)) {
                if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3) < ((d0*d1)*d2)) {
                  if (((blockIdx.x_3*512) + threadIdx.x_3) < (((d0*d1)*d2)*d3)) {
                    T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[((blockIdx.x_3*512) + threadIdx.x_3)] / (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.ThreadSync
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
  allocate(T_softmax_maxelem, float32, [((d0*d1)*d2)]);
  attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
  allocate(T_softmax_exp, float32, [(((d0*d1)*d2)*d3)]) {
    attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
    attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x < floordiv(((d0*d1)*d2), 512)) {
      if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
            if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
              T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = -3.40282e+38f32
            }
          }
        }
      }
      for (k: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
            if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
                T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = max((float32*)T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k*stride_7))])
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
            if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
              if (((blockIdx.x*512) + threadIdx.x) < ((d0*d1)*d2)) {
                T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = -3.40282e+38f32
              }
            }
          }
        }
      }
      for (k_1: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
            if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
                if (((blockIdx.x*512) + threadIdx.x) < ((d0*d1)*d2)) {
                  T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = max((float32*)T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k_1*stride_7))])
                }
              }
            }
          }
        }
      }
    }
    attr [IterVar(blockIdx.x_1: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
    attr [IterVar(threadIdx.x_1: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x_1 < floordiv((((d0*d1)*d2)*d3), 512)) {
      if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d0) {
        if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d1) {
          if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < d2) {
            if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3) < d3) {
              if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < (d0*d1)) {
                if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3) < ((d0*d1)*d2)) {
                  T_softmax_exp[((blockIdx.x_1*512) + threadIdx.x_1)] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                }
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d0) {
        if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d1) {
          if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < d2) {
            if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3) < d3) {
              if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < (d0*d1)) {
                if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3) < ((d0*d1)*d2)) {
                  if (((blockIdx.x_1*512) + threadIdx.x_1) < (((d0*d1)*d2)*d3)) {
                    T_softmax_exp[((blockIdx.x_1*512) + threadIdx.x_1)] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                  }
                }
              }
            }
          }
        }
      }
    }
    attr [IterVar(blockIdx.x_2: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
    attr [IterVar(threadIdx.x_2: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x_2 < floordiv(((d0*d1)*d2), 512)) {
      if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
          if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
            if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
              T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = 0f32
            }
          }
        }
      }
      for (k_2: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
            if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
              if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = ((float32*)T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_2)])
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
          if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
            if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
              if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0*d1)*d2)) {
                T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = 0f32
              }
            }
          }
        }
      }
      for (k_3: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
            if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
              if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0*d1)*d2)) {
                  T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = ((float32*)T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_3)])
                }
              }
            }
          }
        }
      }
    }
    attr [IterVar(blockIdx.x_3: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
    attr [IterVar(threadIdx.x_3: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x_3 < floordiv((((d0*d1)*d2)*d3), 512)) {
      if (floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d0) {
        if (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d1) {
          if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < d2) {
            if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3) < d3) {
              if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < (d0*d1)) {
                if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3) < ((d0*d1)*d2)) {
                  T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[((blockIdx.x_3*512) + threadIdx.x_3)] / (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                }
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d0) {
        if (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d1) {
          if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < d2) {
            if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3) < d3) {
              if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < (d0*d1)) {
                if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3) < ((d0*d1)*d2)) {
                  if (((blockIdx.x_3*512) + threadIdx.x_3) < (((d0*d1)*d2)*d3)) {
                    T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[((blockIdx.x_3*512) + threadIdx.x_3)] / (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InferFragment
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
  allocate(T_softmax_maxelem, float32, [((d0*d1)*d2)]);
  attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
  allocate(T_softmax_exp, float32, [(((d0*d1)*d2)*d3)]) {
    attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
    attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x < floordiv(((d0*d1)*d2), 512)) {
      if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
            if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
              T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = -3.40282e+38f32
            }
          }
        }
      }
      for (k: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
            if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
                T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = max((float32*)T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k*stride_7))])
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
            if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
              if (((blockIdx.x*512) + threadIdx.x) < ((d0*d1)*d2)) {
                T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = -3.40282e+38f32
              }
            }
          }
        }
      }
      for (k_1: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
            if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
                if (((blockIdx.x*512) + threadIdx.x) < ((d0*d1)*d2)) {
                  T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = max((float32*)T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k_1*stride_7))])
                }
              }
            }
          }
        }
      }
    }
    attr [IterVar(blockIdx.x_1: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
    attr [IterVar(threadIdx.x_1: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x_1 < floordiv((((d0*d1)*d2)*d3), 512)) {
      if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d0) {
        if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d1) {
          if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < d2) {
            if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3) < d3) {
              if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < (d0*d1)) {
                if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3) < ((d0*d1)*d2)) {
                  T_softmax_exp[((blockIdx.x_1*512) + threadIdx.x_1)] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                }
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d0) {
        if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d1) {
          if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < d2) {
            if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3) < d3) {
              if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < (d0*d1)) {
                if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3) < ((d0*d1)*d2)) {
                  if (((blockIdx.x_1*512) + threadIdx.x_1) < (((d0*d1)*d2)*d3)) {
                    T_softmax_exp[((blockIdx.x_1*512) + threadIdx.x_1)] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                  }
                }
              }
            }
          }
        }
      }
    }
    attr [IterVar(blockIdx.x_2: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
    attr [IterVar(threadIdx.x_2: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x_2 < floordiv(((d0*d1)*d2), 512)) {
      if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
          if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
            if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
              T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = 0f32
            }
          }
        }
      }
      for (k_2: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
            if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
              if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = ((float32*)T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_2)])
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
          if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
            if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
              if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0*d1)*d2)) {
                T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = 0f32
              }
            }
          }
        }
      }
      for (k_3: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
            if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
              if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0*d1)*d2)) {
                  T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = ((float32*)T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_3)])
                }
              }
            }
          }
        }
      }
    }
    attr [IterVar(blockIdx.x_3: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
    attr [IterVar(threadIdx.x_3: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x_3 < floordiv((((d0*d1)*d2)*d3), 512)) {
      if (floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d0) {
        if (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d1) {
          if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < d2) {
            if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3) < d3) {
              if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < (d0*d1)) {
                if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3) < ((d0*d1)*d2)) {
                  T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[((blockIdx.x_3*512) + threadIdx.x_3)] / (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                }
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d0) {
        if (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d1) {
          if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < d2) {
            if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3) < d3) {
              if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < (d0*d1)) {
                if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3) < ((d0*d1)*d2)) {
                  if (((blockIdx.x_3*512) + threadIdx.x_3) < (((d0*d1)*d2)*d3)) {
                    T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[((blockIdx.x_3*512) + threadIdx.x_3)] / (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerThreadAllreduce
primfn(placeholder_1: handle, T_softmax_norm_1: handle) -> ()
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {T_softmax_norm: Buffer(T_softmax_norm_2: Pointer(float32), float32, [d0: int32, d1: int32, d2: int32, d3: int32], [stride: int32, stride_1: int32, stride_2: int32, stride_3: int32], type="auto"),
             placeholder: Buffer(placeholder_2: Pointer(float32), float32, [d0, d1, d2, d3], [stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32], type="auto")}
  buffer_map = {placeholder_1: placeholder, T_softmax_norm_1: T_softmax_norm} {
  attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
  allocate(T_softmax_maxelem, float32, [((d0*d1)*d2)]);
  attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
  allocate(T_softmax_exp, float32, [(((d0*d1)*d2)*d3)]) {
    attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
    attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x < floordiv(((d0*d1)*d2), 512)) {
      if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
            if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
              T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = -3.40282e+38f32
            }
          }
        }
      }
      for (k: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
            if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
                T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = max((float32*)T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k*stride_7))])
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
            if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
              if (((blockIdx.x*512) + threadIdx.x) < ((d0*d1)*d2)) {
                T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = -3.40282e+38f32
              }
            }
          }
        }
      }
      for (k_1: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
            if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
                if (((blockIdx.x*512) + threadIdx.x) < ((d0*d1)*d2)) {
                  T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = max((float32*)T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_4) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_5)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_6)) + (k_1*stride_7))])
                }
              }
            }
          }
        }
      }
    }
    attr [IterVar(blockIdx.x_1: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
    attr [IterVar(threadIdx.x_1: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x_1 < floordiv((((d0*d1)*d2)*d3), 512)) {
      if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d0) {
        if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d1) {
          if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < d2) {
            if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3) < d3) {
              if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < (d0*d1)) {
                if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3) < ((d0*d1)*d2)) {
                  T_softmax_exp[((blockIdx.x_1*512) + threadIdx.x_1)] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                }
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d0) {
        if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d1) {
          if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < d2) {
            if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3) < d3) {
              if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < (d0*d1)) {
                if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3) < ((d0*d1)*d2)) {
                  if (((blockIdx.x_1*512) + threadIdx.x_1) < (((d0*d1)*d2)*d3)) {
                    T_softmax_exp[((blockIdx.x_1*512) + threadIdx.x_1)] = @tir.exp(((float32*)placeholder_2[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride_7))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                  }
                }
              }
            }
          }
        }
      }
    }
    attr [IterVar(blockIdx.x_2: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
    attr [IterVar(threadIdx.x_2: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x_2 < floordiv(((d0*d1)*d2), 512)) {
      if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
          if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
            if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
              T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = 0f32
            }
          }
        }
      }
      for (k_2: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
            if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
              if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = ((float32*)T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_2)])
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
        if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
          if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
            if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
              if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0*d1)*d2)) {
                T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = 0f32
              }
            }
          }
        }
      }
      for (k_3: int32, 0, d3) {
        if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
            if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
              if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0*d1)*d2)) {
                  T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = ((float32*)T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_3)])
                }
              }
            }
          }
        }
      }
    }
    attr [IterVar(blockIdx.x_3: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
    attr [IterVar(threadIdx.x_3: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
    if (blockIdx.x_3 < floordiv((((d0*d1)*d2)*d3), 512)) {
      if (floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d0) {
        if (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d1) {
          if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < d2) {
            if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3) < d3) {
              if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < (d0*d1)) {
                if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3) < ((d0*d1)*d2)) {
                  T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[((blockIdx.x_3*512) + threadIdx.x_3)] / (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                }
              }
            }
          }
        }
      }
    } else {
      if (floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d0) {
        if (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d1) {
          if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < d2) {
            if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3) < d3) {
              if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < (d0*d1)) {
                if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3) < ((d0*d1)*d2)) {
                  if (((blockIdx.x_3*512) + threadIdx.x_3) < (((d0*d1)*d2)*d3)) {
                    T_softmax_norm_2[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_2)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_3))] = ((float32*)T_softmax_exp[((blockIdx.x_3*512) + threadIdx.x_3)] / (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.MakePackedAPI
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"global_symbol": "fused_nn_softmax", "tir.noalias": True, "target": meta[Target][0], "calling_conv": 1} {
  assert((num_args == 2), "fused_nn_softmax: num_args should be 2")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let placeholder: Pointer(float32) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let d0: int32 = cast(int32, (int64*)arg0.shape[0])
  let d1: int32 = cast(int32, (int64*)arg0.shape[1])
  let d2: int32 = cast(int32, (int64*)arg0.shape[2])
  let d3: int32 = cast(int32, (int64*)arg0.shape[3])
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let stride: int32 = @tir.if_then_else((d3 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides, dtype=bool), 1, cast(int32, (int64*)arg0.strides[3]), dtype=int32), dtype=int32)
  let stride_1: int32 = @tir.if_then_else((d2 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides, dtype=bool), d3, cast(int32, (int64*)arg0.strides[2]), dtype=int32), dtype=int32)
  let stride_2: int32 = @tir.if_then_else((d1 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides, dtype=bool), (d3*d2), cast(int32, (int64*)arg0.strides[1]), dtype=int32), dtype=int32)
  let stride_3: int32 = @tir.if_then_else((d0 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides, dtype=bool), ((d3*d2)*d1), cast(int32, (int64*)arg0.strides[0]), dtype=int32), dtype=int32)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let T_softmax_norm: Pointer(float32) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [T_softmax_norm] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let stride_4: int32 = @tir.if_then_else((d3 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides, dtype=bool), 1, cast(int32, (int64*)arg1.strides[3]), dtype=int32), dtype=int32)
  let stride_5: int32 = @tir.if_then_else((d2 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides, dtype=bool), d3, cast(int32, (int64*)arg1.strides[2]), dtype=int32), dtype=int32)
  let stride_6: int32 = @tir.if_then_else((d1 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides, dtype=bool), (d3*d2), cast(int32, (int64*)arg1.strides[1]), dtype=int32), dtype=int32)
  let stride_7: int32 = @tir.if_then_else((d0 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides, dtype=bool), ((d3*d2)*d1), cast(int32, (int64*)arg1.strides[0]), dtype=int32), dtype=int32)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_nn_softmax: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_nn_softmax: Expect arg[1] to be pointer")
  attr ["default"] "device_id" = dev_id;
  attr ["default"] "device_type" = 2;
  assert((4 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 4")
  assert((4 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 4")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 2u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 32u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be float32")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((2 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (2 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((4 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 4")
  assert((4 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 4")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 2u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 32u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be float32")
  assert((d0 == cast(int32, (int64*)arg1.shape[0])), "Argument arg1.shape[0] has an unsatisfied constraint: (d0 == int32(arg1.shape[0]))")
  assert((d1 == cast(int32, (int64*)arg1.shape[1])), "Argument arg1.shape[1] has an unsatisfied constraint: (d1 == int32(arg1.shape[1]))")
  assert((d2 == cast(int32, (int64*)arg1.shape[2])), "Argument arg1.shape[2] has an unsatisfied constraint: (d2 == int32(arg1.shape[2]))")
  assert((d3 == cast(int32, (int64*)arg1.shape[3])), "Argument arg1.shape[3] has an unsatisfied constraint: (d3 == int32(arg1.shape[3]))")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((2 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (2 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
   {
    @tir.tvm_call_packed("__tvm_set_device", 2, dev_id, dtype=int32)
    attr [0] "compute_scope" = "fused_nn_softmax_compute_";
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_maxelem, float32, [((d0*d1)*d2)]);
    attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_exp, float32, [(((d0*d1)*d2)*d3)]) {
      attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
      attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
      if (blockIdx.x < floordiv(((d0*d1)*d2), 512)) {
        if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
            if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
                T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = -3.40282e+38f32
              }
            }
          }
        }
        for (k: int32, 0, d3) {
          if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
            if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
              if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
                if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
                  T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = max((float32*)T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)], (float32*)placeholder[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_3) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_2)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_1)) + (k*stride))])
                }
              }
            }
          }
        }
      } else {
        if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
            if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
                if (((blockIdx.x*512) + threadIdx.x) < ((d0*d1)*d2)) {
                  T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = -3.40282e+38f32
                }
              }
            }
          }
        }
        for (k_1: int32, 0, d3) {
          if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d0) {
            if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1) < d1) {
              if (floormod(((blockIdx.x*512) + threadIdx.x), d2) < d2) {
                if (floordiv(((blockIdx.x*512) + threadIdx.x), d2) < (d0*d1)) {
                  if (((blockIdx.x*512) + threadIdx.x) < ((d0*d1)*d2)) {
                    T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)] = max((float32*)T_softmax_maxelem[((blockIdx.x*512) + threadIdx.x)], (float32*)placeholder[((((floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_3) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d2), d1)*stride_2)) + (floormod(((blockIdx.x*512) + threadIdx.x), d2)*stride_1)) + (k_1*stride))])
                  }
                }
              }
            }
          }
        }
      }
      attr [IterVar(blockIdx.x_1: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
      attr [IterVar(threadIdx.x_1: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
      if (blockIdx.x_1 < floordiv((((d0*d1)*d2)*d3), 512)) {
        if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d0) {
          if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d1) {
            if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < d2) {
              if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3) < d3) {
                if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < (d0*d1)) {
                  if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3) < ((d0*d1)*d2)) {
                    T_softmax_exp[((blockIdx.x_1*512) + threadIdx.x_1)] = @tir.exp(((float32*)placeholder[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_3) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_2)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_1)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                  }
                }
              }
            }
          }
        }
      } else {
        if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d0) {
          if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1) < d1) {
            if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < d2) {
              if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3) < d3) {
                if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2) < (d0*d1)) {
                  if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3) < ((d0*d1)*d2)) {
                    if (((blockIdx.x_1*512) + threadIdx.x_1) < (((d0*d1)*d2)*d3)) {
                      T_softmax_exp[((blockIdx.x_1*512) + threadIdx.x_1)] = @tir.exp(((float32*)placeholder[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_3) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2), d1)*stride_2)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3), d2)*stride_1)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3)*stride))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3)]), dtype=float32)
                    }
                  }
                }
              }
            }
          }
        }
      }
      attr [IterVar(blockIdx.x_2: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0*d1)*d2) + 511), 512);
      attr [IterVar(threadIdx.x_2: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
      if (blockIdx.x_2 < floordiv(((d0*d1)*d2), 512)) {
        if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
            if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
              if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = 0f32
              }
            }
          }
        }
        for (k_2: int32, 0, d3) {
          if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
            if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
              if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
                if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                  T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = ((float32*)T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_2)])
                }
              }
            }
          }
        }
      } else {
        if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
          if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
            if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
              if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0*d1)*d2)) {
                  T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = 0f32
                }
              }
            }
          }
        }
        for (k_3: int32, 0, d3) {
          if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d0) {
            if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2), d1) < d1) {
              if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2) < d2) {
                if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2) < (d0*d1)) {
                  if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0*d1)*d2)) {
                    T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] = ((float32*)T_softmax_maxelem[((blockIdx.x_2*512) + threadIdx.x_2)] + (float32*)T_softmax_exp[((((blockIdx.x_2*512) + threadIdx.x_2)*d3) + k_3)])
                  }
                }
              }
            }
          }
        }
      }
      attr [IterVar(blockIdx.x_3: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
      attr [IterVar(threadIdx.x_3: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
      if (blockIdx.x_3 < floordiv((((d0*d1)*d2)*d3), 512)) {
        if (floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d0) {
          if (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d1) {
            if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < d2) {
              if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3) < d3) {
                if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < (d0*d1)) {
                  if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3) < ((d0*d1)*d2)) {
                    T_softmax_norm[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_7) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_6)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_5)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_4))] = ((float32*)T_softmax_exp[((blockIdx.x_3*512) + threadIdx.x_3)] / (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                  }
                }
              }
            }
          }
        }
      } else {
        if (floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d0) {
          if (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1) < d1) {
            if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < d2) {
              if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3) < d3) {
                if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2) < (d0*d1)) {
                  if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3) < ((d0*d1)*d2)) {
                    if (((blockIdx.x_3*512) + threadIdx.x_3) < (((d0*d1)*d2)*d3)) {
                      T_softmax_norm[((((floordiv(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_7) + (floormod(floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2), d1)*stride_6)) + (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3), d2)*stride_5)) + (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d3)*stride_4))] = ((float32*)T_softmax_exp[((blockIdx.x_3*512) + threadIdx.x_3)] / (float32*)T_softmax_maxelem[floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d3)])
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.SplitHostDevice
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": (nullptr), "tir.noalias": True, "global_symbol": "fused_nn_softmax", "calling_conv": 1} {
  assert((num_args == 2), "fused_nn_softmax: num_args should be 2")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let placeholder: Pointer(float32) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let d0: int32 = cast(int32, (int64*)arg0.shape[0])
  let d1: int32 = cast(int32, (int64*)arg0.shape[1])
  let d2: int32 = cast(int32, (int64*)arg0.shape[2])
  let d3: int32 = cast(int32, (int64*)arg0.shape[3])
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let stride: int32 = @tir.if_then_else((d3 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides, dtype=bool), 1, cast(int32, (int64*)arg0.strides[3]), dtype=int32), dtype=int32)
  let stride_1: int32 = @tir.if_then_else((d2 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides, dtype=bool), d3, cast(int32, (int64*)arg0.strides[2]), dtype=int32), dtype=int32)
  let stride_2: int32 = @tir.if_then_else((d1 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides, dtype=bool), (d3*d2), cast(int32, (int64*)arg0.strides[1]), dtype=int32), dtype=int32)
  let stride_3: int32 = @tir.if_then_else((d0 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides, dtype=bool), ((d3*d2)*d1), cast(int32, (int64*)arg0.strides[0]), dtype=int32), dtype=int32)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let T_softmax_norm: Pointer(float32) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [T_softmax_norm] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let stride_4: int32 = @tir.if_then_else((d3 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides, dtype=bool), 1, cast(int32, (int64*)arg1.strides[3]), dtype=int32), dtype=int32)
  let stride_5: int32 = @tir.if_then_else((d2 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides, dtype=bool), d3, cast(int32, (int64*)arg1.strides[2]), dtype=int32), dtype=int32)
  let stride_6: int32 = @tir.if_then_else((d1 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides, dtype=bool), (d3*d2), cast(int32, (int64*)arg1.strides[1]), dtype=int32), dtype=int32)
  let stride_7: int32 = @tir.if_then_else((d0 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides, dtype=bool), ((d3*d2)*d1), cast(int32, (int64*)arg1.strides[0]), dtype=int32), dtype=int32)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_nn_softmax: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_nn_softmax: Expect arg[1] to be pointer")
  attr ["default"] "device_id" = dev_id;
  attr ["default"] "device_type" = 2;
  assert((4 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 4")
  assert((4 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 4")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 2u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 32u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be float32")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((2 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (2 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((4 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 4")
  assert((4 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 4")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 2u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 32u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be float32")
  assert((d0 == cast(int32, (int64*)arg1.shape[0])), "Argument arg1.shape[0] has an unsatisfied constraint: (d0 == int32(arg1.shape[0]))")
  assert((d1 == cast(int32, (int64*)arg1.shape[1])), "Argument arg1.shape[1] has an unsatisfied constraint: (d1 == int32(arg1.shape[1]))")
  assert((d2 == cast(int32, (int64*)arg1.shape[2])), "Argument arg1.shape[2] has an unsatisfied constraint: (d2 == int32(arg1.shape[2]))")
  assert((d3 == cast(int32, (int64*)arg1.shape[3])), "Argument arg1.shape[3] has an unsatisfied constraint: (d3 == int32(arg1.shape[3]))")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((2 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (2 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
   {
    @tir.tvm_call_packed("__tvm_set_device", 2, dev_id, dtype=int32)
    attr [0] "compute_scope" = "fused_nn_softmax_compute_";
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_maxelem, float32, [((d0*d1)*d2)]);
    attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_exp, float32, [(((d0*d1)*d2)*d3)]) {
      @tir.tvm_call_packed("fused_nn_softmax_kernel0", T_softmax_maxelem, placeholder, d0, d1, d2, d3, stride_3, stride_2, stride_1, stride, floordiv((((d0*d1)*d2) + 511), 512), 512, dtype=int32)
      @tir.tvm_call_packed("fused_nn_softmax_kernel1", T_softmax_exp, placeholder, T_softmax_maxelem, d0, d1, d2, d3, stride_3, stride_2, stride_1, stride, floordiv(((((d0*d1)*d2)*d3) + 511), 512), 512, dtype=int32)
      @tir.tvm_call_packed("fused_nn_softmax_kernel2", T_softmax_maxelem, T_softmax_exp, d0, d1, d2, d3, floordiv((((d0*d1)*d2) + 511), 512), 512, dtype=int32)
      @tir.tvm_call_packed("fused_nn_softmax_kernel3", T_softmax_norm, T_softmax_exp, T_softmax_maxelem, d0, d1, d2, d3, stride_7, stride_6, stride_5, stride_4, floordiv(((((d0*d1)*d2)*d3) + 511), 512), 512, dtype=int32)
    }
  }
}

primfn(T_softmax_exp_1: Pointer(float32), placeholder_1: Pointer(float32), T_softmax_maxelem_1: Pointer(float32), d0_1: int32, d1_1: int32, d2_1: int32, d3_1: int32, stride_8: int32, stride_9: int32, stride_10: int32, stride_11: int32) -> ()
  attr = {"target": meta[Target][0], "tir.noalias": 1, "global_symbol": "fused_nn_softmax_kernel1", "tir.device_thread_axis": [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x"), IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")], "calling_conv": 2} {
  attr [IterVar(blockIdx.x, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0_1*d1_1)*d2_1)*d3_1) + 511), 512);
  attr [IterVar(threadIdx.x, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
  if (blockIdx.x < floordiv((((d0_1*d1_1)*d2_1)*d3_1), 512)) {
    if (floordiv(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3_1), d2_1), d1_1) < d0_1) {
      if (floormod(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3_1), d2_1), d1_1) < d1_1) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d3_1), d2_1) < d2_1) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d3_1) < d3_1) {
            if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3_1), d2_1) < (d0_1*d1_1)) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d3_1) < ((d0_1*d1_1)*d2_1)) {
                T_softmax_exp_1[((blockIdx.x*512) + threadIdx.x)] = @tir.exp(((float32*)placeholder_1[((((floordiv(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3_1), d2_1), d1_1)*stride_8) + (floormod(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3_1), d2_1), d1_1)*stride_9)) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d3_1), d2_1)*stride_10)) + (floormod(((blockIdx.x*512) + threadIdx.x), d3_1)*stride_11))] - (float32*)T_softmax_maxelem_1[floordiv(((blockIdx.x*512) + threadIdx.x), d3_1)]), dtype=float32)
              }
            }
          }
        }
      }
    }
  } else {
    if (floordiv(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3_1), d2_1), d1_1) < d0_1) {
      if (floormod(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3_1), d2_1), d1_1) < d1_1) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d3_1), d2_1) < d2_1) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d3_1) < d3_1) {
            if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3_1), d2_1) < (d0_1*d1_1)) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d3_1) < ((d0_1*d1_1)*d2_1)) {
                if (((blockIdx.x*512) + threadIdx.x) < (((d0_1*d1_1)*d2_1)*d3_1)) {
                  T_softmax_exp_1[((blockIdx.x*512) + threadIdx.x)] = @tir.exp(((float32*)placeholder_1[((((floordiv(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3_1), d2_1), d1_1)*stride_8) + (floormod(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3_1), d2_1), d1_1)*stride_9)) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d3_1), d2_1)*stride_10)) + (floormod(((blockIdx.x*512) + threadIdx.x), d3_1)*stride_11))] - (float32*)T_softmax_maxelem_1[floordiv(((blockIdx.x*512) + threadIdx.x), d3_1)]), dtype=float32)
                }
              }
            }
          }
        }
      }
    }
  }
}

primfn(T_softmax_norm_1: Pointer(float32), T_softmax_exp_2: Pointer(float32), T_softmax_maxelem_2: Pointer(float32), d0_2: int32, d1_2: int32, d2_2: int32, d3_2: int32, stride_12: int32, stride_13: int32, stride_14: int32, stride_15: int32) -> ()
  attr = {"target": meta[Target][0], "tir.noalias": 1, "global_symbol": "fused_nn_softmax_kernel3", "tir.device_thread_axis": [IterVar(blockIdx.x_1: int32, (nullptr), "ThreadIndex", "blockIdx.x"), IterVar(threadIdx.x_1: int32, (nullptr), "ThreadIndex", "threadIdx.x")], "calling_conv": 2} {
  attr [IterVar(blockIdx.x_1, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0_2*d1_2)*d2_2)*d3_2) + 511), 512);
  attr [IterVar(threadIdx.x_1, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
  if (blockIdx.x_1 < floordiv((((d0_2*d1_2)*d2_2)*d3_2), 512)) {
    if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_2), d2_2), d1_2) < d0_2) {
      if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_2), d2_2), d1_2) < d1_2) {
        if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_2), d2_2) < d2_2) {
          if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3_2) < d3_2) {
            if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_2), d2_2) < (d0_2*d1_2)) {
              if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_2) < ((d0_2*d1_2)*d2_2)) {
                T_softmax_norm_1[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_2), d2_2), d1_2)*stride_12) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_2), d2_2), d1_2)*stride_13)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_2), d2_2)*stride_14)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3_2)*stride_15))] = ((float32*)T_softmax_exp_2[((blockIdx.x_1*512) + threadIdx.x_1)] / (float32*)T_softmax_maxelem_2[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_2)])
              }
            }
          }
        }
      }
    }
  } else {
    if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_2), d2_2), d1_2) < d0_2) {
      if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_2), d2_2), d1_2) < d1_2) {
        if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_2), d2_2) < d2_2) {
          if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3_2) < d3_2) {
            if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_2), d2_2) < (d0_2*d1_2)) {
              if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_2) < ((d0_2*d1_2)*d2_2)) {
                if (((blockIdx.x_1*512) + threadIdx.x_1) < (((d0_2*d1_2)*d2_2)*d3_2)) {
                  T_softmax_norm_1[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_2), d2_2), d1_2)*stride_12) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_2), d2_2), d1_2)*stride_13)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_2), d2_2)*stride_14)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3_2)*stride_15))] = ((float32*)T_softmax_exp_2[((blockIdx.x_1*512) + threadIdx.x_1)] / (float32*)T_softmax_maxelem_2[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_2)])
                }
              }
            }
          }
        }
      }
    }
  }
}

primfn(T_softmax_maxelem_3: Pointer(float32), placeholder_2: Pointer(float32), d0_3: int32, d1_3: int32, d2_3: int32, d3_3: int32, stride_16: int32, stride_17: int32, stride_18: int32, stride_19: int32) -> ()
  attr = {"target": meta[Target][0], "tir.noalias": 1, "global_symbol": "fused_nn_softmax_kernel0", "tir.device_thread_axis": [IterVar(blockIdx.x_2: int32, (nullptr), "ThreadIndex", "blockIdx.x"), IterVar(threadIdx.x_2: int32, (nullptr), "ThreadIndex", "threadIdx.x")], "calling_conv": 2} {
  attr [IterVar(blockIdx.x_2, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0_3*d1_3)*d2_3) + 511), 512);
  attr [IterVar(threadIdx.x_2, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
  if (blockIdx.x_2 < floordiv(((d0_3*d1_3)*d2_3), 512)) {
    if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_3), d1_3) < d0_3) {
      if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_3), d1_3) < d1_3) {
        if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2_3) < d2_3) {
          if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_3) < (d0_3*d1_3)) {
            T_softmax_maxelem_3[((blockIdx.x_2*512) + threadIdx.x_2)] = -3.40282e+38f32
          }
        }
      }
    }
    for (k: int32, 0, d3_3) {
      if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_3), d1_3) < d0_3) {
        if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_3), d1_3) < d1_3) {
          if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2_3) < d2_3) {
            if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_3) < (d0_3*d1_3)) {
              T_softmax_maxelem_3[((blockIdx.x_2*512) + threadIdx.x_2)] = max((float32*)T_softmax_maxelem_3[((blockIdx.x_2*512) + threadIdx.x_2)], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_3), d1_3)*stride_16) + (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_3), d1_3)*stride_17)) + (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2_3)*stride_18)) + (k*stride_19))])
            }
          }
        }
      }
    }
  } else {
    if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_3), d1_3) < d0_3) {
      if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_3), d1_3) < d1_3) {
        if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2_3) < d2_3) {
          if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_3) < (d0_3*d1_3)) {
            if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0_3*d1_3)*d2_3)) {
              T_softmax_maxelem_3[((blockIdx.x_2*512) + threadIdx.x_2)] = -3.40282e+38f32
            }
          }
        }
      }
    }
    for (k_1: int32, 0, d3_3) {
      if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_3), d1_3) < d0_3) {
        if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_3), d1_3) < d1_3) {
          if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2_3) < d2_3) {
            if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_3) < (d0_3*d1_3)) {
              if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0_3*d1_3)*d2_3)) {
                T_softmax_maxelem_3[((blockIdx.x_2*512) + threadIdx.x_2)] = max((float32*)T_softmax_maxelem_3[((blockIdx.x_2*512) + threadIdx.x_2)], (float32*)placeholder_2[((((floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_3), d1_3)*stride_16) + (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_3), d1_3)*stride_17)) + (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2_3)*stride_18)) + (k_1*stride_19))])
              }
            }
          }
        }
      }
    }
  }
}

primfn(T_softmax_maxelem_4: Pointer(float32), T_softmax_exp_3: Pointer(float32), d0_4: int32, d1_4: int32, d2_4: int32, d3_4: int32) -> ()
  attr = {"target": meta[Target][0], "tir.noalias": 1, "global_symbol": "fused_nn_softmax_kernel2", "tir.device_thread_axis": [IterVar(blockIdx.x_3: int32, (nullptr), "ThreadIndex", "blockIdx.x"), IterVar(threadIdx.x_3: int32, (nullptr), "ThreadIndex", "threadIdx.x")], "calling_conv": 2} {
  attr [IterVar(blockIdx.x_3, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0_4*d1_4)*d2_4) + 511), 512);
  attr [IterVar(threadIdx.x_3, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
  if (blockIdx.x_3 < floordiv(((d0_4*d1_4)*d2_4), 512)) {
    if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_4), d1_4) < d0_4) {
      if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_4), d1_4) < d1_4) {
        if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d2_4) < d2_4) {
          if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_4) < (d0_4*d1_4)) {
            T_softmax_maxelem_4[((blockIdx.x_3*512) + threadIdx.x_3)] = 0f32
          }
        }
      }
    }
    for (k_2: int32, 0, d3_4) {
      if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_4), d1_4) < d0_4) {
        if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_4), d1_4) < d1_4) {
          if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d2_4) < d2_4) {
            if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_4) < (d0_4*d1_4)) {
              T_softmax_maxelem_4[((blockIdx.x_3*512) + threadIdx.x_3)] = ((float32*)T_softmax_maxelem_4[((blockIdx.x_3*512) + threadIdx.x_3)] + (float32*)T_softmax_exp_3[((((blockIdx.x_3*512) + threadIdx.x_3)*d3_4) + k_2)])
            }
          }
        }
      }
    }
  } else {
    if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_4), d1_4) < d0_4) {
      if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_4), d1_4) < d1_4) {
        if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d2_4) < d2_4) {
          if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_4) < (d0_4*d1_4)) {
            if (((blockIdx.x_3*512) + threadIdx.x_3) < ((d0_4*d1_4)*d2_4)) {
              T_softmax_maxelem_4[((blockIdx.x_3*512) + threadIdx.x_3)] = 0f32
            }
          }
        }
      }
    }
    for (k_3: int32, 0, d3_4) {
      if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_4), d1_4) < d0_4) {
        if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_4), d1_4) < d1_4) {
          if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d2_4) < d2_4) {
            if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_4) < (d0_4*d1_4)) {
              if (((blockIdx.x_3*512) + threadIdx.x_3) < ((d0_4*d1_4)*d2_4)) {
                T_softmax_maxelem_4[((blockIdx.x_3*512) + threadIdx.x_3)] = ((float32*)T_softmax_maxelem_4[((blockIdx.x_3*512) + threadIdx.x_3)] + (float32*)T_softmax_exp_3[((((blockIdx.x_3*512) + threadIdx.x_3)*d3_4) + k_3)])
              }
            }
          }
        }
      }
    }
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass Filter
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": (nullptr), "tir.noalias": True, "global_symbol": "fused_nn_softmax", "calling_conv": 1} {
  assert((num_args == 2), "fused_nn_softmax: num_args should be 2")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let placeholder: Pointer(float32) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let d0: int32 = cast(int32, (int64*)arg0.shape[0])
  let d1: int32 = cast(int32, (int64*)arg0.shape[1])
  let d2: int32 = cast(int32, (int64*)arg0.shape[2])
  let d3: int32 = cast(int32, (int64*)arg0.shape[3])
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let stride: int32 = @tir.if_then_else((d3 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides, dtype=bool), 1, cast(int32, (int64*)arg0.strides[3]), dtype=int32), dtype=int32)
  let stride_1: int32 = @tir.if_then_else((d2 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides, dtype=bool), d3, cast(int32, (int64*)arg0.strides[2]), dtype=int32), dtype=int32)
  let stride_2: int32 = @tir.if_then_else((d1 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides, dtype=bool), (d3*d2), cast(int32, (int64*)arg0.strides[1]), dtype=int32), dtype=int32)
  let stride_3: int32 = @tir.if_then_else((d0 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides, dtype=bool), ((d3*d2)*d1), cast(int32, (int64*)arg0.strides[0]), dtype=int32), dtype=int32)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let T_softmax_norm: Pointer(float32) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [T_softmax_norm] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let stride_4: int32 = @tir.if_then_else((d3 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides, dtype=bool), 1, cast(int32, (int64*)arg1.strides[3]), dtype=int32), dtype=int32)
  let stride_5: int32 = @tir.if_then_else((d2 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides, dtype=bool), d3, cast(int32, (int64*)arg1.strides[2]), dtype=int32), dtype=int32)
  let stride_6: int32 = @tir.if_then_else((d1 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides, dtype=bool), (d3*d2), cast(int32, (int64*)arg1.strides[1]), dtype=int32), dtype=int32)
  let stride_7: int32 = @tir.if_then_else((d0 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides, dtype=bool), ((d3*d2)*d1), cast(int32, (int64*)arg1.strides[0]), dtype=int32), dtype=int32)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_nn_softmax: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_nn_softmax: Expect arg[1] to be pointer")
  attr ["default"] "device_id" = dev_id;
  attr ["default"] "device_type" = 2;
  assert((4 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 4")
  assert((4 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 4")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 2u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 32u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be float32")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((2 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (2 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((4 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 4")
  assert((4 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 4")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 2u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 32u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be float32")
  assert((d0 == cast(int32, (int64*)arg1.shape[0])), "Argument arg1.shape[0] has an unsatisfied constraint: (d0 == int32(arg1.shape[0]))")
  assert((d1 == cast(int32, (int64*)arg1.shape[1])), "Argument arg1.shape[1] has an unsatisfied constraint: (d1 == int32(arg1.shape[1]))")
  assert((d2 == cast(int32, (int64*)arg1.shape[2])), "Argument arg1.shape[2] has an unsatisfied constraint: (d2 == int32(arg1.shape[2]))")
  assert((d3 == cast(int32, (int64*)arg1.shape[3])), "Argument arg1.shape[3] has an unsatisfied constraint: (d3 == int32(arg1.shape[3]))")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((2 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (2 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
   {
    @tir.tvm_call_packed("__tvm_set_device", 2, dev_id, dtype=int32)
    attr [0] "compute_scope" = "fused_nn_softmax_compute_";
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_maxelem, float32, [((d0*d1)*d2)]);
    attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_exp, float32, [(((d0*d1)*d2)*d3)]) {
      @tir.tvm_call_packed("fused_nn_softmax_kernel0", T_softmax_maxelem, placeholder, d0, d1, d2, d3, stride_3, stride_2, stride_1, stride, floordiv((((d0*d1)*d2) + 511), 512), 512, dtype=int32)
      @tir.tvm_call_packed("fused_nn_softmax_kernel1", T_softmax_exp, placeholder, T_softmax_maxelem, d0, d1, d2, d3, stride_3, stride_2, stride_1, stride, floordiv(((((d0*d1)*d2)*d3) + 511), 512), 512, dtype=int32)
      @tir.tvm_call_packed("fused_nn_softmax_kernel2", T_softmax_maxelem, T_softmax_exp, d0, d1, d2, d3, floordiv((((d0*d1)*d2) + 511), 512), 512, dtype=int32)
      @tir.tvm_call_packed("fused_nn_softmax_kernel3", T_softmax_norm, T_softmax_exp, T_softmax_maxelem, d0, d1, d2, d3, stride_7, stride_6, stride_5, stride_4, floordiv(((((d0*d1)*d2)*d3) + 511), 512), 512, dtype=int32)
    }
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass BindTarget
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_nn_softmax", "calling_conv": 1} {
  assert((num_args == 2), "fused_nn_softmax: num_args should be 2")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let placeholder: Pointer(float32) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let d0: int32 = cast(int32, (int64*)arg0.shape[0])
  let d1: int32 = cast(int32, (int64*)arg0.shape[1])
  let d2: int32 = cast(int32, (int64*)arg0.shape[2])
  let d3: int32 = cast(int32, (int64*)arg0.shape[3])
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let stride: int32 = @tir.if_then_else((d3 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides, dtype=bool), 1, cast(int32, (int64*)arg0.strides[3]), dtype=int32), dtype=int32)
  let stride_1: int32 = @tir.if_then_else((d2 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides, dtype=bool), d3, cast(int32, (int64*)arg0.strides[2]), dtype=int32), dtype=int32)
  let stride_2: int32 = @tir.if_then_else((d1 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides, dtype=bool), (d3*d2), cast(int32, (int64*)arg0.strides[1]), dtype=int32), dtype=int32)
  let stride_3: int32 = @tir.if_then_else((d0 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides, dtype=bool), ((d3*d2)*d1), cast(int32, (int64*)arg0.strides[0]), dtype=int32), dtype=int32)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let T_softmax_norm: Pointer(float32) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [T_softmax_norm] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let stride_4: int32 = @tir.if_then_else((d3 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides, dtype=bool), 1, cast(int32, (int64*)arg1.strides[3]), dtype=int32), dtype=int32)
  let stride_5: int32 = @tir.if_then_else((d2 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides, dtype=bool), d3, cast(int32, (int64*)arg1.strides[2]), dtype=int32), dtype=int32)
  let stride_6: int32 = @tir.if_then_else((d1 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides, dtype=bool), (d3*d2), cast(int32, (int64*)arg1.strides[1]), dtype=int32), dtype=int32)
  let stride_7: int32 = @tir.if_then_else((d0 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides, dtype=bool), ((d3*d2)*d1), cast(int32, (int64*)arg1.strides[0]), dtype=int32), dtype=int32)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_nn_softmax: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_nn_softmax: Expect arg[1] to be pointer")
  attr ["default"] "device_id" = dev_id;
  attr ["default"] "device_type" = 2;
  assert((4 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 4")
  assert((4 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 4")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 2u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 32u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be float32")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((2 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (2 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((4 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 4")
  assert((4 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 4")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 2u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 32u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be float32")
  assert((d0 == cast(int32, (int64*)arg1.shape[0])), "Argument arg1.shape[0] has an unsatisfied constraint: (d0 == int32(arg1.shape[0]))")
  assert((d1 == cast(int32, (int64*)arg1.shape[1])), "Argument arg1.shape[1] has an unsatisfied constraint: (d1 == int32(arg1.shape[1]))")
  assert((d2 == cast(int32, (int64*)arg1.shape[2])), "Argument arg1.shape[2] has an unsatisfied constraint: (d2 == int32(arg1.shape[2]))")
  assert((d3 == cast(int32, (int64*)arg1.shape[3])), "Argument arg1.shape[3] has an unsatisfied constraint: (d3 == int32(arg1.shape[3]))")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((2 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (2 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
   {
    @tir.tvm_call_packed("__tvm_set_device", 2, dev_id, dtype=int32)
    attr [0] "compute_scope" = "fused_nn_softmax_compute_";
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_maxelem, float32, [((d0*d1)*d2)]);
    attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
    allocate(T_softmax_exp, float32, [(((d0*d1)*d2)*d3)]) {
      @tir.tvm_call_packed("fused_nn_softmax_kernel0", T_softmax_maxelem, placeholder, d0, d1, d2, d3, stride_3, stride_2, stride_1, stride, floordiv((((d0*d1)*d2) + 511), 512), 512, dtype=int32)
      @tir.tvm_call_packed("fused_nn_softmax_kernel1", T_softmax_exp, placeholder, T_softmax_maxelem, d0, d1, d2, d3, stride_3, stride_2, stride_1, stride, floordiv(((((d0*d1)*d2)*d3) + 511), 512), 512, dtype=int32)
      @tir.tvm_call_packed("fused_nn_softmax_kernel2", T_softmax_maxelem, T_softmax_exp, d0, d1, d2, d3, floordiv((((d0*d1)*d2) + 511), 512), 512, dtype=int32)
      @tir.tvm_call_packed("fused_nn_softmax_kernel3", T_softmax_norm, T_softmax_exp, T_softmax_maxelem, d0, d1, d2, d3, stride_7, stride_6, stride_5, stride_4, floordiv(((((d0*d1)*d2)*d3) + 511), 512), 512, dtype=int32)
    }
  }
}


[14:05:56] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerTVMBuiltin
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_nn_softmax", "calling_conv": 1} {
  let stack_tcode: handle = @tir.tvm_stack_alloca("arg_tcode", 14, dtype=handle)
  let stack_value: handle = @tir.tvm_stack_alloca("arg_value", 14, dtype=handle)
  assert((num_args == 2), "fused_nn_softmax: num_args should be 2")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let placeholder: Pointer(float32) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let d0: int32 = cast(int32, (int64*)arg0.shape[0])
  let d1: int32 = cast(int32, (int64*)arg0.shape[1])
  let d2: int32 = cast(int32, (int64*)arg0.shape[2])
  let d3: int32 = cast(int32, (int64*)arg0.shape[3])
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let stride: int32 = @tir.if_then_else((d3 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides, dtype=bool), 1, cast(int32, (int64*)arg0.strides[3]), dtype=int32), dtype=int32)
  let stride_1: int32 = @tir.if_then_else((d2 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides, dtype=bool), d3, cast(int32, (int64*)arg0.strides[2]), dtype=int32), dtype=int32)
  let stride_2: int32 = @tir.if_then_else((d1 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides, dtype=bool), (d3*d2), cast(int32, (int64*)arg0.strides[1]), dtype=int32), dtype=int32)
  let stride_3: int32 = @tir.if_then_else((d0 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides, dtype=bool), ((d3*d2)*d1), cast(int32, (int64*)arg0.strides[0]), dtype=int32), dtype=int32)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let T_softmax_norm: Pointer(float32) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [T_softmax_norm] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let stride_4: int32 = @tir.if_then_else((d3 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides, dtype=bool), 1, cast(int32, (int64*)arg1.strides[3]), dtype=int32), dtype=int32)
  let stride_5: int32 = @tir.if_then_else((d2 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides, dtype=bool), d3, cast(int32, (int64*)arg1.strides[2]), dtype=int32), dtype=int32)
  let stride_6: int32 = @tir.if_then_else((d1 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides, dtype=bool), (d3*d2), cast(int32, (int64*)arg1.strides[1]), dtype=int32), dtype=int32)
  let stride_7: int32 = @tir.if_then_else((d0 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides, dtype=bool), ((d3*d2)*d1), cast(int32, (int64*)arg1.strides[0]), dtype=int32), dtype=int32)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_nn_softmax: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_nn_softmax: Expect arg[1] to be pointer")
  assert((4 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 4")
  assert((4 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 4")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 2u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 32u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be float32")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((2 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (2 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((4 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 4")
  assert((4 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 4")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 2u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 32u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be float32")
  assert((d0 == cast(int32, (int64*)arg1.shape[0])), "Argument arg1.shape[0] has an unsatisfied constraint: (d0 == int32(arg1.shape[0]))")
  assert((d1 == cast(int32, (int64*)arg1.shape[1])), "Argument arg1.shape[1] has an unsatisfied constraint: (d1 == int32(arg1.shape[1]))")
  assert((d2 == cast(int32, (int64*)arg1.shape[2])), "Argument arg1.shape[2] has an unsatisfied constraint: (d2 == int32(arg1.shape[2]))")
  assert((d3 == cast(int32, (int64*)arg1.shape[3])), "Argument arg1.shape[3] has an unsatisfied constraint: (d3 == int32(arg1.shape[3]))")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((2 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (2 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
   {
     {
      @tir.tvm_struct_set(stack_value, 0, 12, cast(int64, 2), dtype=int32)
      stack_tcode[0] = 0
      @tir.tvm_struct_set(stack_value, 1, 12, cast(int64, dev_id), dtype=int32)
      stack_tcode[1] = 0
      @tir.tvm_call_packed_lowered("__tvm_set_device", stack_value, stack_tcode, 0, 2, dtype=int32)
    }
    attr [0] "compute_scope" = "fused_nn_softmax_compute_";
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    attr [T_softmax_maxelem] "storage_alignment" = 128 {
      let T_softmax_maxelem = @tir.TVMBackendAllocWorkspace(2, dev_id, cast(uint64, (4*((d0*d1)*d2))), 2, 32, dtype=handle)
       {
        if @tir.isnullptr(T_softmax_maxelem, dtype=bool) {
          @tir.tvm_throw_last_error(, dtype=int32)
        }
        attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
        attr [T_softmax_exp] "storage_alignment" = 128 {
          let T_softmax_exp = @tir.TVMBackendAllocWorkspace(2, dev_id, cast(uint64, (4*(((d0*d1)*d2)*d3))), 2, 32, dtype=handle)
           {
            if @tir.isnullptr(T_softmax_exp, dtype=bool) {
              @tir.tvm_throw_last_error(, dtype=int32)
            }
             {
               {
                @tir.tvm_struct_set(stack_value, 0, 12, T_softmax_maxelem, dtype=int32)
                stack_tcode[0] = 3
                @tir.tvm_struct_set(stack_value, 1, 12, placeholder, dtype=int32)
                stack_tcode[1] = 3
                @tir.tvm_struct_set(stack_value, 2, 12, cast(int64, d0), dtype=int32)
                stack_tcode[2] = 0
                @tir.tvm_struct_set(stack_value, 3, 12, cast(int64, d1), dtype=int32)
                stack_tcode[3] = 0
                @tir.tvm_struct_set(stack_value, 4, 12, cast(int64, d2), dtype=int32)
                stack_tcode[4] = 0
                @tir.tvm_struct_set(stack_value, 5, 12, cast(int64, d3), dtype=int32)
                stack_tcode[5] = 0
                @tir.tvm_struct_set(stack_value, 6, 12, cast(int64, stride_3), dtype=int32)
                stack_tcode[6] = 0
                @tir.tvm_struct_set(stack_value, 7, 12, cast(int64, stride_2), dtype=int32)
                stack_tcode[7] = 0
                @tir.tvm_struct_set(stack_value, 8, 12, cast(int64, stride_1), dtype=int32)
                stack_tcode[8] = 0
                @tir.tvm_struct_set(stack_value, 9, 12, cast(int64, stride), dtype=int32)
                stack_tcode[9] = 0
                @tir.tvm_struct_set(stack_value, 10, 12, cast(int64, floordiv((((d0*d1)*d2) + 511), 512)), dtype=int32)
                stack_tcode[10] = 0
                @tir.tvm_struct_set(stack_value, 11, 12, cast(int64, 512), dtype=int32)
                stack_tcode[11] = 0
                @tir.tvm_call_packed_lowered("fused_nn_softmax_kernel0", stack_value, stack_tcode, 0, 12, dtype=int32)
              }
               {
                @tir.tvm_struct_set(stack_value, 0, 12, T_softmax_exp, dtype=int32)
                stack_tcode[0] = 3
                @tir.tvm_struct_set(stack_value, 1, 12, placeholder, dtype=int32)
                stack_tcode[1] = 3
                @tir.tvm_struct_set(stack_value, 2, 12, T_softmax_maxelem, dtype=int32)
                stack_tcode[2] = 3
                @tir.tvm_struct_set(stack_value, 3, 12, cast(int64, d0), dtype=int32)
                stack_tcode[3] = 0
                @tir.tvm_struct_set(stack_value, 4, 12, cast(int64, d1), dtype=int32)
                stack_tcode[4] = 0
                @tir.tvm_struct_set(stack_value, 5, 12, cast(int64, d2), dtype=int32)
                stack_tcode[5] = 0
                @tir.tvm_struct_set(stack_value, 6, 12, cast(int64, d3), dtype=int32)
                stack_tcode[6] = 0
                @tir.tvm_struct_set(stack_value, 7, 12, cast(int64, stride_3), dtype=int32)
                stack_tcode[7] = 0
                @tir.tvm_struct_set(stack_value, 8, 12, cast(int64, stride_2), dtype=int32)
                stack_tcode[8] = 0
                @tir.tvm_struct_set(stack_value, 9, 12, cast(int64, stride_1), dtype=int32)
                stack_tcode[9] = 0
                @tir.tvm_struct_set(stack_value, 10, 12, cast(int64, stride), dtype=int32)
                stack_tcode[10] = 0
                @tir.tvm_struct_set(stack_value, 11, 12, cast(int64, floordiv(((((d0*d1)*d2)*d3) + 511), 512)), dtype=int32)
                stack_tcode[11] = 0
                @tir.tvm_struct_set(stack_value, 12, 12, cast(int64, 512), dtype=int32)
                stack_tcode[12] = 0
                @tir.tvm_call_packed_lowered("fused_nn_softmax_kernel1", stack_value, stack_tcode, 0, 13, dtype=int32)
              }
               {
                @tir.tvm_struct_set(stack_value, 0, 12, T_softmax_maxelem, dtype=int32)
                stack_tcode[0] = 3
                @tir.tvm_struct_set(stack_value, 1, 12, T_softmax_exp, dtype=int32)
                stack_tcode[1] = 3
                @tir.tvm_struct_set(stack_value, 2, 12, cast(int64, d0), dtype=int32)
                stack_tcode[2] = 0
                @tir.tvm_struct_set(stack_value, 3, 12, cast(int64, d1), dtype=int32)
                stack_tcode[3] = 0
                @tir.tvm_struct_set(stack_value, 4, 12, cast(int64, d2), dtype=int32)
                stack_tcode[4] = 0
                @tir.tvm_struct_set(stack_value, 5, 12, cast(int64, d3), dtype=int32)
                stack_tcode[5] = 0
                @tir.tvm_struct_set(stack_value, 6, 12, cast(int64, floordiv((((d0*d1)*d2) + 511), 512)), dtype=int32)
                stack_tcode[6] = 0
                @tir.tvm_struct_set(stack_value, 7, 12, cast(int64, 512), dtype=int32)
                stack_tcode[7] = 0
                @tir.tvm_call_packed_lowered("fused_nn_softmax_kernel2", stack_value, stack_tcode, 0, 8, dtype=int32)
              }
               {
                @tir.tvm_struct_set(stack_value, 0, 12, T_softmax_norm, dtype=int32)
                stack_tcode[0] = 3
                @tir.tvm_struct_set(stack_value, 1, 12, T_softmax_exp, dtype=int32)
                stack_tcode[1] = 3
                @tir.tvm_struct_set(stack_value, 2, 12, T_softmax_maxelem, dtype=int32)
                stack_tcode[2] = 3
                @tir.tvm_struct_set(stack_value, 3, 12, cast(int64, d0), dtype=int32)
                stack_tcode[3] = 0
                @tir.tvm_struct_set(stack_value, 4, 12, cast(int64, d1), dtype=int32)
                stack_tcode[4] = 0
                @tir.tvm_struct_set(stack_value, 5, 12, cast(int64, d2), dtype=int32)
                stack_tcode[5] = 0
                @tir.tvm_struct_set(stack_value, 6, 12, cast(int64, d3), dtype=int32)
                stack_tcode[6] = 0
                @tir.tvm_struct_set(stack_value, 7, 12, cast(int64, stride_7), dtype=int32)
                stack_tcode[7] = 0
                @tir.tvm_struct_set(stack_value, 8, 12, cast(int64, stride_6), dtype=int32)
                stack_tcode[8] = 0
                @tir.tvm_struct_set(stack_value, 9, 12, cast(int64, stride_5), dtype=int32)
                stack_tcode[9] = 0
                @tir.tvm_struct_set(stack_value, 10, 12, cast(int64, stride_4), dtype=int32)
                stack_tcode[10] = 0
                @tir.tvm_struct_set(stack_value, 11, 12, cast(int64, floordiv(((((d0*d1)*d2)*d3) + 511), 512)), dtype=int32)
                stack_tcode[11] = 0
                @tir.tvm_struct_set(stack_value, 12, 12, cast(int64, 512), dtype=int32)
                stack_tcode[12] = 0
                @tir.tvm_call_packed_lowered("fused_nn_softmax_kernel3", stack_value, stack_tcode, 0, 13, dtype=int32)
              }
            }
          }
          if (@tir.TVMBackendFreeWorkspace(2, dev_id, T_softmax_exp, dtype=int32) != 0) {
            @tir.tvm_throw_last_error(, dtype=int32)
          }
        }
      }
      if (@tir.TVMBackendFreeWorkspace(2, dev_id, T_softmax_maxelem, dtype=int32) != 0) {
        @tir.tvm_throw_last_error(, dtype=int32)
      }
    }
  }
}


[14:05:57] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerCustomDatatypes
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_nn_softmax", "calling_conv": 1} {
  let stack_tcode: handle = @tir.tvm_stack_alloca("arg_tcode", 14, dtype=handle)
  let stack_value: handle = @tir.tvm_stack_alloca("arg_value", 14, dtype=handle)
  assert((num_args == 2), "fused_nn_softmax: num_args should be 2")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let placeholder: Pointer(float32) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let d0: int32 = cast(int32, (int64*)arg0.shape[0])
  let d1: int32 = cast(int32, (int64*)arg0.shape[1])
  let d2: int32 = cast(int32, (int64*)arg0.shape[2])
  let d3: int32 = cast(int32, (int64*)arg0.shape[3])
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let stride: int32 = @tir.if_then_else((d3 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides, dtype=bool), 1, cast(int32, (int64*)arg0.strides[3]), dtype=int32), dtype=int32)
  let stride_1: int32 = @tir.if_then_else((d2 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides, dtype=bool), d3, cast(int32, (int64*)arg0.strides[2]), dtype=int32), dtype=int32)
  let stride_2: int32 = @tir.if_then_else((d1 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides, dtype=bool), (d3*d2), cast(int32, (int64*)arg0.strides[1]), dtype=int32), dtype=int32)
  let stride_3: int32 = @tir.if_then_else((d0 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides, dtype=bool), ((d3*d2)*d1), cast(int32, (int64*)arg0.strides[0]), dtype=int32), dtype=int32)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let T_softmax_norm: Pointer(float32) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [T_softmax_norm] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let stride_4: int32 = @tir.if_then_else((d3 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides, dtype=bool), 1, cast(int32, (int64*)arg1.strides[3]), dtype=int32), dtype=int32)
  let stride_5: int32 = @tir.if_then_else((d2 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides, dtype=bool), d3, cast(int32, (int64*)arg1.strides[2]), dtype=int32), dtype=int32)
  let stride_6: int32 = @tir.if_then_else((d1 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides, dtype=bool), (d3*d2), cast(int32, (int64*)arg1.strides[1]), dtype=int32), dtype=int32)
  let stride_7: int32 = @tir.if_then_else((d0 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides, dtype=bool), ((d3*d2)*d1), cast(int32, (int64*)arg1.strides[0]), dtype=int32), dtype=int32)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_nn_softmax: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_nn_softmax: Expect arg[1] to be pointer")
  assert((4 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 4")
  assert((4 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 4")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 2u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 32u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be float32")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((2 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (2 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((4 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 4")
  assert((4 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 4")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 2u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 32u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be float32")
  assert((d0 == cast(int32, (int64*)arg1.shape[0])), "Argument arg1.shape[0] has an unsatisfied constraint: (d0 == int32(arg1.shape[0]))")
  assert((d1 == cast(int32, (int64*)arg1.shape[1])), "Argument arg1.shape[1] has an unsatisfied constraint: (d1 == int32(arg1.shape[1]))")
  assert((d2 == cast(int32, (int64*)arg1.shape[2])), "Argument arg1.shape[2] has an unsatisfied constraint: (d2 == int32(arg1.shape[2]))")
  assert((d3 == cast(int32, (int64*)arg1.shape[3])), "Argument arg1.shape[3] has an unsatisfied constraint: (d3 == int32(arg1.shape[3]))")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((2 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (2 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
   {
     {
      @tir.tvm_struct_set(stack_value, 0, 12, cast(int64, 2), dtype=int32)
      stack_tcode[0] = 0
      @tir.tvm_struct_set(stack_value, 1, 12, cast(int64, dev_id), dtype=int32)
      stack_tcode[1] = 0
      @tir.tvm_call_packed_lowered("__tvm_set_device", stack_value, stack_tcode, 0, 2, dtype=int32)
    }
    attr [0] "compute_scope" = "fused_nn_softmax_compute_";
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    attr [T_softmax_maxelem] "storage_alignment" = 128 {
      let T_softmax_maxelem = @tir.TVMBackendAllocWorkspace(2, dev_id, cast(uint64, (4*((d0*d1)*d2))), 2, 32, dtype=handle)
       {
        if @tir.isnullptr(T_softmax_maxelem, dtype=bool) {
          @tir.tvm_throw_last_error(, dtype=int32)
        }
        attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
        attr [T_softmax_exp] "storage_alignment" = 128 {
          let T_softmax_exp = @tir.TVMBackendAllocWorkspace(2, dev_id, cast(uint64, (4*(((d0*d1)*d2)*d3))), 2, 32, dtype=handle)
           {
            if @tir.isnullptr(T_softmax_exp, dtype=bool) {
              @tir.tvm_throw_last_error(, dtype=int32)
            }
             {
               {
                @tir.tvm_struct_set(stack_value, 0, 12, T_softmax_maxelem, dtype=int32)
                stack_tcode[0] = 3
                @tir.tvm_struct_set(stack_value, 1, 12, placeholder, dtype=int32)
                stack_tcode[1] = 3
                @tir.tvm_struct_set(stack_value, 2, 12, cast(int64, d0), dtype=int32)
                stack_tcode[2] = 0
                @tir.tvm_struct_set(stack_value, 3, 12, cast(int64, d1), dtype=int32)
                stack_tcode[3] = 0
                @tir.tvm_struct_set(stack_value, 4, 12, cast(int64, d2), dtype=int32)
                stack_tcode[4] = 0
                @tir.tvm_struct_set(stack_value, 5, 12, cast(int64, d3), dtype=int32)
                stack_tcode[5] = 0
                @tir.tvm_struct_set(stack_value, 6, 12, cast(int64, stride_3), dtype=int32)
                stack_tcode[6] = 0
                @tir.tvm_struct_set(stack_value, 7, 12, cast(int64, stride_2), dtype=int32)
                stack_tcode[7] = 0
                @tir.tvm_struct_set(stack_value, 8, 12, cast(int64, stride_1), dtype=int32)
                stack_tcode[8] = 0
                @tir.tvm_struct_set(stack_value, 9, 12, cast(int64, stride), dtype=int32)
                stack_tcode[9] = 0
                @tir.tvm_struct_set(stack_value, 10, 12, cast(int64, floordiv((((d0*d1)*d2) + 511), 512)), dtype=int32)
                stack_tcode[10] = 0
                @tir.tvm_struct_set(stack_value, 11, 12, cast(int64, 512), dtype=int32)
                stack_tcode[11] = 0
                @tir.tvm_call_packed_lowered("fused_nn_softmax_kernel0", stack_value, stack_tcode, 0, 12, dtype=int32)
              }
               {
                @tir.tvm_struct_set(stack_value, 0, 12, T_softmax_exp, dtype=int32)
                stack_tcode[0] = 3
                @tir.tvm_struct_set(stack_value, 1, 12, placeholder, dtype=int32)
                stack_tcode[1] = 3
                @tir.tvm_struct_set(stack_value, 2, 12, T_softmax_maxelem, dtype=int32)
                stack_tcode[2] = 3
                @tir.tvm_struct_set(stack_value, 3, 12, cast(int64, d0), dtype=int32)
                stack_tcode[3] = 0
                @tir.tvm_struct_set(stack_value, 4, 12, cast(int64, d1), dtype=int32)
                stack_tcode[4] = 0
                @tir.tvm_struct_set(stack_value, 5, 12, cast(int64, d2), dtype=int32)
                stack_tcode[5] = 0
                @tir.tvm_struct_set(stack_value, 6, 12, cast(int64, d3), dtype=int32)
                stack_tcode[6] = 0
                @tir.tvm_struct_set(stack_value, 7, 12, cast(int64, stride_3), dtype=int32)
                stack_tcode[7] = 0
                @tir.tvm_struct_set(stack_value, 8, 12, cast(int64, stride_2), dtype=int32)
                stack_tcode[8] = 0
                @tir.tvm_struct_set(stack_value, 9, 12, cast(int64, stride_1), dtype=int32)
                stack_tcode[9] = 0
                @tir.tvm_struct_set(stack_value, 10, 12, cast(int64, stride), dtype=int32)
                stack_tcode[10] = 0
                @tir.tvm_struct_set(stack_value, 11, 12, cast(int64, floordiv(((((d0*d1)*d2)*d3) + 511), 512)), dtype=int32)
                stack_tcode[11] = 0
                @tir.tvm_struct_set(stack_value, 12, 12, cast(int64, 512), dtype=int32)
                stack_tcode[12] = 0
                @tir.tvm_call_packed_lowered("fused_nn_softmax_kernel1", stack_value, stack_tcode, 0, 13, dtype=int32)
              }
               {
                @tir.tvm_struct_set(stack_value, 0, 12, T_softmax_maxelem, dtype=int32)
                stack_tcode[0] = 3
                @tir.tvm_struct_set(stack_value, 1, 12, T_softmax_exp, dtype=int32)
                stack_tcode[1] = 3
                @tir.tvm_struct_set(stack_value, 2, 12, cast(int64, d0), dtype=int32)
                stack_tcode[2] = 0
                @tir.tvm_struct_set(stack_value, 3, 12, cast(int64, d1), dtype=int32)
                stack_tcode[3] = 0
                @tir.tvm_struct_set(stack_value, 4, 12, cast(int64, d2), dtype=int32)
                stack_tcode[4] = 0
                @tir.tvm_struct_set(stack_value, 5, 12, cast(int64, d3), dtype=int32)
                stack_tcode[5] = 0
                @tir.tvm_struct_set(stack_value, 6, 12, cast(int64, floordiv((((d0*d1)*d2) + 511), 512)), dtype=int32)
                stack_tcode[6] = 0
                @tir.tvm_struct_set(stack_value, 7, 12, cast(int64, 512), dtype=int32)
                stack_tcode[7] = 0
                @tir.tvm_call_packed_lowered("fused_nn_softmax_kernel2", stack_value, stack_tcode, 0, 8, dtype=int32)
              }
               {
                @tir.tvm_struct_set(stack_value, 0, 12, T_softmax_norm, dtype=int32)
                stack_tcode[0] = 3
                @tir.tvm_struct_set(stack_value, 1, 12, T_softmax_exp, dtype=int32)
                stack_tcode[1] = 3
                @tir.tvm_struct_set(stack_value, 2, 12, T_softmax_maxelem, dtype=int32)
                stack_tcode[2] = 3
                @tir.tvm_struct_set(stack_value, 3, 12, cast(int64, d0), dtype=int32)
                stack_tcode[3] = 0
                @tir.tvm_struct_set(stack_value, 4, 12, cast(int64, d1), dtype=int32)
                stack_tcode[4] = 0
                @tir.tvm_struct_set(stack_value, 5, 12, cast(int64, d2), dtype=int32)
                stack_tcode[5] = 0
                @tir.tvm_struct_set(stack_value, 6, 12, cast(int64, d3), dtype=int32)
                stack_tcode[6] = 0
                @tir.tvm_struct_set(stack_value, 7, 12, cast(int64, stride_7), dtype=int32)
                stack_tcode[7] = 0
                @tir.tvm_struct_set(stack_value, 8, 12, cast(int64, stride_6), dtype=int32)
                stack_tcode[8] = 0
                @tir.tvm_struct_set(stack_value, 9, 12, cast(int64, stride_5), dtype=int32)
                stack_tcode[9] = 0
                @tir.tvm_struct_set(stack_value, 10, 12, cast(int64, stride_4), dtype=int32)
                stack_tcode[10] = 0
                @tir.tvm_struct_set(stack_value, 11, 12, cast(int64, floordiv(((((d0*d1)*d2)*d3) + 511), 512)), dtype=int32)
                stack_tcode[11] = 0
                @tir.tvm_struct_set(stack_value, 12, 12, cast(int64, 512), dtype=int32)
                stack_tcode[12] = 0
                @tir.tvm_call_packed_lowered("fused_nn_softmax_kernel3", stack_value, stack_tcode, 0, 13, dtype=int32)
              }
            }
          }
          if (@tir.TVMBackendFreeWorkspace(2, dev_id, T_softmax_exp, dtype=int32) != 0) {
            @tir.tvm_throw_last_error(, dtype=int32)
          }
        }
      }
      if (@tir.TVMBackendFreeWorkspace(2, dev_id, T_softmax_maxelem, dtype=int32) != 0) {
        @tir.tvm_throw_last_error(, dtype=int32)
      }
    }
  }
}


[14:05:57] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerIntrin
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_nn_softmax", "calling_conv": 1} {
  let stack_tcode: handle = @tir.tvm_stack_alloca("arg_tcode", 14, dtype=handle)
  let stack_value: handle = @tir.tvm_stack_alloca("arg_value", 14, dtype=handle)
  assert((num_args == 2), "fused_nn_softmax: num_args should be 2")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let placeholder: Pointer(float32) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let d0: int32 = cast(int32, (int64*)arg0.shape[0])
  let d1: int32 = cast(int32, (int64*)arg0.shape[1])
  let d2: int32 = cast(int32, (int64*)arg0.shape[2])
  let d3: int32 = cast(int32, (int64*)arg0.shape[3])
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let stride: int32 = @tir.if_then_else((d3 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides, dtype=bool), 1, cast(int32, (int64*)arg0.strides[3]), dtype=int32), dtype=int32)
  let stride_1: int32 = @tir.if_then_else((d2 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides, dtype=bool), d3, cast(int32, (int64*)arg0.strides[2]), dtype=int32), dtype=int32)
  let stride_2: int32 = @tir.if_then_else((d1 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides, dtype=bool), (d3*d2), cast(int32, (int64*)arg0.strides[1]), dtype=int32), dtype=int32)
  let stride_3: int32 = @tir.if_then_else((d0 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides, dtype=bool), ((d3*d2)*d1), cast(int32, (int64*)arg0.strides[0]), dtype=int32), dtype=int32)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let T_softmax_norm: Pointer(float32) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [T_softmax_norm] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let stride_4: int32 = @tir.if_then_else((d3 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides, dtype=bool), 1, cast(int32, (int64*)arg1.strides[3]), dtype=int32), dtype=int32)
  let stride_5: int32 = @tir.if_then_else((d2 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides, dtype=bool), d3, cast(int32, (int64*)arg1.strides[2]), dtype=int32), dtype=int32)
  let stride_6: int32 = @tir.if_then_else((d1 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides, dtype=bool), (d3*d2), cast(int32, (int64*)arg1.strides[1]), dtype=int32), dtype=int32)
  let stride_7: int32 = @tir.if_then_else((d0 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides, dtype=bool), ((d3*d2)*d1), cast(int32, (int64*)arg1.strides[0]), dtype=int32), dtype=int32)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_nn_softmax: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_nn_softmax: Expect arg[1] to be pointer")
  assert((4 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 4")
  assert((4 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 4")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 2u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 32u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be float32")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((2 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (2 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((4 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 4")
  assert((4 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 4")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 2u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 32u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be float32")
  assert((d0 == cast(int32, (int64*)arg1.shape[0])), "Argument arg1.shape[0] has an unsatisfied constraint: (d0 == int32(arg1.shape[0]))")
  assert((d1 == cast(int32, (int64*)arg1.shape[1])), "Argument arg1.shape[1] has an unsatisfied constraint: (d1 == int32(arg1.shape[1]))")
  assert((d2 == cast(int32, (int64*)arg1.shape[2])), "Argument arg1.shape[2] has an unsatisfied constraint: (d2 == int32(arg1.shape[2]))")
  assert((d3 == cast(int32, (int64*)arg1.shape[3])), "Argument arg1.shape[3] has an unsatisfied constraint: (d3 == int32(arg1.shape[3]))")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((2 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (2 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
   {
     {
      @tir.tvm_struct_set(stack_value, 0, 12, cast(int64, 2), dtype=int32)
      stack_tcode[0] = 0
      @tir.tvm_struct_set(stack_value, 1, 12, cast(int64, dev_id), dtype=int32)
      stack_tcode[1] = 0
      @tir.tvm_call_packed_lowered("__tvm_set_device", stack_value, stack_tcode, 0, 2, dtype=int32)
    }
    attr [0] "compute_scope" = "fused_nn_softmax_compute_";
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    attr [T_softmax_maxelem] "storage_alignment" = 128 {
      let T_softmax_maxelem = @tir.TVMBackendAllocWorkspace(2, dev_id, cast(uint64, (4*((d0*d1)*d2))), 2, 32, dtype=handle)
       {
        if @tir.isnullptr(T_softmax_maxelem, dtype=bool) {
          @tir.tvm_throw_last_error(, dtype=int32)
        }
        attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
        attr [T_softmax_exp] "storage_alignment" = 128 {
          let T_softmax_exp = @tir.TVMBackendAllocWorkspace(2, dev_id, cast(uint64, (4*(((d0*d1)*d2)*d3))), 2, 32, dtype=handle)
           {
            if @tir.isnullptr(T_softmax_exp, dtype=bool) {
              @tir.tvm_throw_last_error(, dtype=int32)
            }
             {
               {
                @tir.tvm_struct_set(stack_value, 0, 12, T_softmax_maxelem, dtype=int32)
                stack_tcode[0] = 3
                @tir.tvm_struct_set(stack_value, 1, 12, placeholder, dtype=int32)
                stack_tcode[1] = 3
                @tir.tvm_struct_set(stack_value, 2, 12, cast(int64, d0), dtype=int32)
                stack_tcode[2] = 0
                @tir.tvm_struct_set(stack_value, 3, 12, cast(int64, d1), dtype=int32)
                stack_tcode[3] = 0
                @tir.tvm_struct_set(stack_value, 4, 12, cast(int64, d2), dtype=int32)
                stack_tcode[4] = 0
                @tir.tvm_struct_set(stack_value, 5, 12, cast(int64, d3), dtype=int32)
                stack_tcode[5] = 0
                @tir.tvm_struct_set(stack_value, 6, 12, cast(int64, stride_3), dtype=int32)
                stack_tcode[6] = 0
                @tir.tvm_struct_set(stack_value, 7, 12, cast(int64, stride_2), dtype=int32)
                stack_tcode[7] = 0
                @tir.tvm_struct_set(stack_value, 8, 12, cast(int64, stride_1), dtype=int32)
                stack_tcode[8] = 0
                @tir.tvm_struct_set(stack_value, 9, 12, cast(int64, stride), dtype=int32)
                stack_tcode[9] = 0
                @tir.tvm_struct_set(stack_value, 10, 12, cast(int64, @tir.shift_right((((d0*d1)*d2) + 511), 9, dtype=int32)), dtype=int32)
                stack_tcode[10] = 0
                @tir.tvm_struct_set(stack_value, 11, 12, cast(int64, 512), dtype=int32)
                stack_tcode[11] = 0
                @tir.tvm_call_packed_lowered("fused_nn_softmax_kernel0", stack_value, stack_tcode, 0, 12, dtype=int32)
              }
               {
                @tir.tvm_struct_set(stack_value, 0, 12, T_softmax_exp, dtype=int32)
                stack_tcode[0] = 3
                @tir.tvm_struct_set(stack_value, 1, 12, placeholder, dtype=int32)
                stack_tcode[1] = 3
                @tir.tvm_struct_set(stack_value, 2, 12, T_softmax_maxelem, dtype=int32)
                stack_tcode[2] = 3
                @tir.tvm_struct_set(stack_value, 3, 12, cast(int64, d0), dtype=int32)
                stack_tcode[3] = 0
                @tir.tvm_struct_set(stack_value, 4, 12, cast(int64, d1), dtype=int32)
                stack_tcode[4] = 0
                @tir.tvm_struct_set(stack_value, 5, 12, cast(int64, d2), dtype=int32)
                stack_tcode[5] = 0
                @tir.tvm_struct_set(stack_value, 6, 12, cast(int64, d3), dtype=int32)
                stack_tcode[6] = 0
                @tir.tvm_struct_set(stack_value, 7, 12, cast(int64, stride_3), dtype=int32)
                stack_tcode[7] = 0
                @tir.tvm_struct_set(stack_value, 8, 12, cast(int64, stride_2), dtype=int32)
                stack_tcode[8] = 0
                @tir.tvm_struct_set(stack_value, 9, 12, cast(int64, stride_1), dtype=int32)
                stack_tcode[9] = 0
                @tir.tvm_struct_set(stack_value, 10, 12, cast(int64, stride), dtype=int32)
                stack_tcode[10] = 0
                @tir.tvm_struct_set(stack_value, 11, 12, cast(int64, @tir.shift_right(((((d0*d1)*d2)*d3) + 511), 9, dtype=int32)), dtype=int32)
                stack_tcode[11] = 0
                @tir.tvm_struct_set(stack_value, 12, 12, cast(int64, 512), dtype=int32)
                stack_tcode[12] = 0
                @tir.tvm_call_packed_lowered("fused_nn_softmax_kernel1", stack_value, stack_tcode, 0, 13, dtype=int32)
              }
               {
                @tir.tvm_struct_set(stack_value, 0, 12, T_softmax_maxelem, dtype=int32)
                stack_tcode[0] = 3
                @tir.tvm_struct_set(stack_value, 1, 12, T_softmax_exp, dtype=int32)
                stack_tcode[1] = 3
                @tir.tvm_struct_set(stack_value, 2, 12, cast(int64, d0), dtype=int32)
                stack_tcode[2] = 0
                @tir.tvm_struct_set(stack_value, 3, 12, cast(int64, d1), dtype=int32)
                stack_tcode[3] = 0
                @tir.tvm_struct_set(stack_value, 4, 12, cast(int64, d2), dtype=int32)
                stack_tcode[4] = 0
                @tir.tvm_struct_set(stack_value, 5, 12, cast(int64, d3), dtype=int32)
                stack_tcode[5] = 0
                @tir.tvm_struct_set(stack_value, 6, 12, cast(int64, @tir.shift_right((((d0*d1)*d2) + 511), 9, dtype=int32)), dtype=int32)
                stack_tcode[6] = 0
                @tir.tvm_struct_set(stack_value, 7, 12, cast(int64, 512), dtype=int32)
                stack_tcode[7] = 0
                @tir.tvm_call_packed_lowered("fused_nn_softmax_kernel2", stack_value, stack_tcode, 0, 8, dtype=int32)
              }
               {
                @tir.tvm_struct_set(stack_value, 0, 12, T_softmax_norm, dtype=int32)
                stack_tcode[0] = 3
                @tir.tvm_struct_set(stack_value, 1, 12, T_softmax_exp, dtype=int32)
                stack_tcode[1] = 3
                @tir.tvm_struct_set(stack_value, 2, 12, T_softmax_maxelem, dtype=int32)
                stack_tcode[2] = 3
                @tir.tvm_struct_set(stack_value, 3, 12, cast(int64, d0), dtype=int32)
                stack_tcode[3] = 0
                @tir.tvm_struct_set(stack_value, 4, 12, cast(int64, d1), dtype=int32)
                stack_tcode[4] = 0
                @tir.tvm_struct_set(stack_value, 5, 12, cast(int64, d2), dtype=int32)
                stack_tcode[5] = 0
                @tir.tvm_struct_set(stack_value, 6, 12, cast(int64, d3), dtype=int32)
                stack_tcode[6] = 0
                @tir.tvm_struct_set(stack_value, 7, 12, cast(int64, stride_7), dtype=int32)
                stack_tcode[7] = 0
                @tir.tvm_struct_set(stack_value, 8, 12, cast(int64, stride_6), dtype=int32)
                stack_tcode[8] = 0
                @tir.tvm_struct_set(stack_value, 9, 12, cast(int64, stride_5), dtype=int32)
                stack_tcode[9] = 0
                @tir.tvm_struct_set(stack_value, 10, 12, cast(int64, stride_4), dtype=int32)
                stack_tcode[10] = 0
                @tir.tvm_struct_set(stack_value, 11, 12, cast(int64, @tir.shift_right(((((d0*d1)*d2)*d3) + 511), 9, dtype=int32)), dtype=int32)
                stack_tcode[11] = 0
                @tir.tvm_struct_set(stack_value, 12, 12, cast(int64, 512), dtype=int32)
                stack_tcode[12] = 0
                @tir.tvm_call_packed_lowered("fused_nn_softmax_kernel3", stack_value, stack_tcode, 0, 13, dtype=int32)
              }
            }
          }
          if (@tir.TVMBackendFreeWorkspace(2, dev_id, T_softmax_exp, dtype=int32) != 0) {
            @tir.tvm_throw_last_error(, dtype=int32)
          }
        }
      }
      if (@tir.TVMBackendFreeWorkspace(2, dev_id, T_softmax_maxelem, dtype=int32) != 0) {
        @tir.tvm_throw_last_error(, dtype=int32)
      }
    }
  }
}


[14:05:57] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerDeviceStorageAccessInfo
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_nn_softmax", "calling_conv": 1} {
  let stack_tcode: handle = @tir.tvm_stack_alloca("arg_tcode", 14, dtype=handle)
  let stack_value: handle = @tir.tvm_stack_alloca("arg_value", 14, dtype=handle)
  assert((num_args == 2), "fused_nn_softmax: num_args should be 2")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let placeholder: Pointer(float32) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let d0: int32 = cast(int32, (int64*)arg0.shape[0])
  let d1: int32 = cast(int32, (int64*)arg0.shape[1])
  let d2: int32 = cast(int32, (int64*)arg0.shape[2])
  let d3: int32 = cast(int32, (int64*)arg0.shape[3])
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let stride: int32 = @tir.if_then_else((d3 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides, dtype=bool), 1, cast(int32, (int64*)arg0.strides[3]), dtype=int32), dtype=int32)
  let stride_1: int32 = @tir.if_then_else((d2 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides, dtype=bool), d3, cast(int32, (int64*)arg0.strides[2]), dtype=int32), dtype=int32)
  let stride_2: int32 = @tir.if_then_else((d1 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides, dtype=bool), (d3*d2), cast(int32, (int64*)arg0.strides[1]), dtype=int32), dtype=int32)
  let stride_3: int32 = @tir.if_then_else((d0 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides, dtype=bool), ((d3*d2)*d1), cast(int32, (int64*)arg0.strides[0]), dtype=int32), dtype=int32)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let T_softmax_norm: Pointer(float32) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [T_softmax_norm] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let stride_4: int32 = @tir.if_then_else((d3 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides, dtype=bool), 1, cast(int32, (int64*)arg1.strides[3]), dtype=int32), dtype=int32)
  let stride_5: int32 = @tir.if_then_else((d2 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides, dtype=bool), d3, cast(int32, (int64*)arg1.strides[2]), dtype=int32), dtype=int32)
  let stride_6: int32 = @tir.if_then_else((d1 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides, dtype=bool), (d3*d2), cast(int32, (int64*)arg1.strides[1]), dtype=int32), dtype=int32)
  let stride_7: int32 = @tir.if_then_else((d0 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides, dtype=bool), ((d3*d2)*d1), cast(int32, (int64*)arg1.strides[0]), dtype=int32), dtype=int32)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_nn_softmax: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_nn_softmax: Expect arg[1] to be pointer")
  assert((4 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 4")
  assert((4 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 4")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 2u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 32u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be float32")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((2 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (2 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((4 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 4")
  assert((4 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 4")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 2u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 32u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be float32")
  assert((d0 == cast(int32, (int64*)arg1.shape[0])), "Argument arg1.shape[0] has an unsatisfied constraint: (d0 == int32(arg1.shape[0]))")
  assert((d1 == cast(int32, (int64*)arg1.shape[1])), "Argument arg1.shape[1] has an unsatisfied constraint: (d1 == int32(arg1.shape[1]))")
  assert((d2 == cast(int32, (int64*)arg1.shape[2])), "Argument arg1.shape[2] has an unsatisfied constraint: (d2 == int32(arg1.shape[2]))")
  assert((d3 == cast(int32, (int64*)arg1.shape[3])), "Argument arg1.shape[3] has an unsatisfied constraint: (d3 == int32(arg1.shape[3]))")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((2 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (2 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
   {
     {
      @tir.tvm_struct_set(stack_value, 0, 12, cast(int64, 2), dtype=int32)
      stack_tcode[0] = 0
      @tir.tvm_struct_set(stack_value, 1, 12, cast(int64, dev_id), dtype=int32)
      stack_tcode[1] = 0
      @tir.tvm_call_packed_lowered("__tvm_set_device", stack_value, stack_tcode, 0, 2, dtype=int32)
    }
    attr [0] "compute_scope" = "fused_nn_softmax_compute_";
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    attr [T_softmax_maxelem] "storage_alignment" = 128 {
      let T_softmax_maxelem = @tir.TVMBackendAllocWorkspace(2, dev_id, cast(uint64, (4*((d0*d1)*d2))), 2, 32, dtype=handle)
       {
        if @tir.isnullptr(T_softmax_maxelem, dtype=bool) {
          @tir.tvm_throw_last_error(, dtype=int32)
        }
        attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
        attr [T_softmax_exp] "storage_alignment" = 128 {
          let T_softmax_exp = @tir.TVMBackendAllocWorkspace(2, dev_id, cast(uint64, (4*(((d0*d1)*d2)*d3))), 2, 32, dtype=handle)
           {
            if @tir.isnullptr(T_softmax_exp, dtype=bool) {
              @tir.tvm_throw_last_error(, dtype=int32)
            }
             {
               {
                @tir.tvm_struct_set(stack_value, 0, 12, T_softmax_maxelem, dtype=int32)
                stack_tcode[0] = 3
                @tir.tvm_struct_set(stack_value, 1, 12, placeholder, dtype=int32)
                stack_tcode[1] = 3
                @tir.tvm_struct_set(stack_value, 2, 12, cast(int64, d0), dtype=int32)
                stack_tcode[2] = 0
                @tir.tvm_struct_set(stack_value, 3, 12, cast(int64, d1), dtype=int32)
                stack_tcode[3] = 0
                @tir.tvm_struct_set(stack_value, 4, 12, cast(int64, d2), dtype=int32)
                stack_tcode[4] = 0
                @tir.tvm_struct_set(stack_value, 5, 12, cast(int64, d3), dtype=int32)
                stack_tcode[5] = 0
                @tir.tvm_struct_set(stack_value, 6, 12, cast(int64, stride_3), dtype=int32)
                stack_tcode[6] = 0
                @tir.tvm_struct_set(stack_value, 7, 12, cast(int64, stride_2), dtype=int32)
                stack_tcode[7] = 0
                @tir.tvm_struct_set(stack_value, 8, 12, cast(int64, stride_1), dtype=int32)
                stack_tcode[8] = 0
                @tir.tvm_struct_set(stack_value, 9, 12, cast(int64, stride), dtype=int32)
                stack_tcode[9] = 0
                @tir.tvm_struct_set(stack_value, 10, 12, cast(int64, @tir.shift_right((((d0*d1)*d2) + 511), 9, dtype=int32)), dtype=int32)
                stack_tcode[10] = 0
                @tir.tvm_struct_set(stack_value, 11, 12, cast(int64, 512), dtype=int32)
                stack_tcode[11] = 0
                @tir.tvm_call_packed_lowered("fused_nn_softmax_kernel0", stack_value, stack_tcode, 0, 12, dtype=int32)
              }
               {
                @tir.tvm_struct_set(stack_value, 0, 12, T_softmax_exp, dtype=int32)
                stack_tcode[0] = 3
                @tir.tvm_struct_set(stack_value, 1, 12, placeholder, dtype=int32)
                stack_tcode[1] = 3
                @tir.tvm_struct_set(stack_value, 2, 12, T_softmax_maxelem, dtype=int32)
                stack_tcode[2] = 3
                @tir.tvm_struct_set(stack_value, 3, 12, cast(int64, d0), dtype=int32)
                stack_tcode[3] = 0
                @tir.tvm_struct_set(stack_value, 4, 12, cast(int64, d1), dtype=int32)
                stack_tcode[4] = 0
                @tir.tvm_struct_set(stack_value, 5, 12, cast(int64, d2), dtype=int32)
                stack_tcode[5] = 0
                @tir.tvm_struct_set(stack_value, 6, 12, cast(int64, d3), dtype=int32)
                stack_tcode[6] = 0
                @tir.tvm_struct_set(stack_value, 7, 12, cast(int64, stride_3), dtype=int32)
                stack_tcode[7] = 0
                @tir.tvm_struct_set(stack_value, 8, 12, cast(int64, stride_2), dtype=int32)
                stack_tcode[8] = 0
                @tir.tvm_struct_set(stack_value, 9, 12, cast(int64, stride_1), dtype=int32)
                stack_tcode[9] = 0
                @tir.tvm_struct_set(stack_value, 10, 12, cast(int64, stride), dtype=int32)
                stack_tcode[10] = 0
                @tir.tvm_struct_set(stack_value, 11, 12, cast(int64, @tir.shift_right(((((d0*d1)*d2)*d3) + 511), 9, dtype=int32)), dtype=int32)
                stack_tcode[11] = 0
                @tir.tvm_struct_set(stack_value, 12, 12, cast(int64, 512), dtype=int32)
                stack_tcode[12] = 0
                @tir.tvm_call_packed_lowered("fused_nn_softmax_kernel1", stack_value, stack_tcode, 0, 13, dtype=int32)
              }
               {
                @tir.tvm_struct_set(stack_value, 0, 12, T_softmax_maxelem, dtype=int32)
                stack_tcode[0] = 3
                @tir.tvm_struct_set(stack_value, 1, 12, T_softmax_exp, dtype=int32)
                stack_tcode[1] = 3
                @tir.tvm_struct_set(stack_value, 2, 12, cast(int64, d0), dtype=int32)
                stack_tcode[2] = 0
                @tir.tvm_struct_set(stack_value, 3, 12, cast(int64, d1), dtype=int32)
                stack_tcode[3] = 0
                @tir.tvm_struct_set(stack_value, 4, 12, cast(int64, d2), dtype=int32)
                stack_tcode[4] = 0
                @tir.tvm_struct_set(stack_value, 5, 12, cast(int64, d3), dtype=int32)
                stack_tcode[5] = 0
                @tir.tvm_struct_set(stack_value, 6, 12, cast(int64, @tir.shift_right((((d0*d1)*d2) + 511), 9, dtype=int32)), dtype=int32)
                stack_tcode[6] = 0
                @tir.tvm_struct_set(stack_value, 7, 12, cast(int64, 512), dtype=int32)
                stack_tcode[7] = 0
                @tir.tvm_call_packed_lowered("fused_nn_softmax_kernel2", stack_value, stack_tcode, 0, 8, dtype=int32)
              }
               {
                @tir.tvm_struct_set(stack_value, 0, 12, T_softmax_norm, dtype=int32)
                stack_tcode[0] = 3
                @tir.tvm_struct_set(stack_value, 1, 12, T_softmax_exp, dtype=int32)
                stack_tcode[1] = 3
                @tir.tvm_struct_set(stack_value, 2, 12, T_softmax_maxelem, dtype=int32)
                stack_tcode[2] = 3
                @tir.tvm_struct_set(stack_value, 3, 12, cast(int64, d0), dtype=int32)
                stack_tcode[3] = 0
                @tir.tvm_struct_set(stack_value, 4, 12, cast(int64, d1), dtype=int32)
                stack_tcode[4] = 0
                @tir.tvm_struct_set(stack_value, 5, 12, cast(int64, d2), dtype=int32)
                stack_tcode[5] = 0
                @tir.tvm_struct_set(stack_value, 6, 12, cast(int64, d3), dtype=int32)
                stack_tcode[6] = 0
                @tir.tvm_struct_set(stack_value, 7, 12, cast(int64, stride_7), dtype=int32)
                stack_tcode[7] = 0
                @tir.tvm_struct_set(stack_value, 8, 12, cast(int64, stride_6), dtype=int32)
                stack_tcode[8] = 0
                @tir.tvm_struct_set(stack_value, 9, 12, cast(int64, stride_5), dtype=int32)
                stack_tcode[9] = 0
                @tir.tvm_struct_set(stack_value, 10, 12, cast(int64, stride_4), dtype=int32)
                stack_tcode[10] = 0
                @tir.tvm_struct_set(stack_value, 11, 12, cast(int64, @tir.shift_right(((((d0*d1)*d2)*d3) + 511), 9, dtype=int32)), dtype=int32)
                stack_tcode[11] = 0
                @tir.tvm_struct_set(stack_value, 12, 12, cast(int64, 512), dtype=int32)
                stack_tcode[12] = 0
                @tir.tvm_call_packed_lowered("fused_nn_softmax_kernel3", stack_value, stack_tcode, 0, 13, dtype=int32)
              }
            }
          }
          if (@tir.TVMBackendFreeWorkspace(2, dev_id, T_softmax_exp, dtype=int32) != 0) {
            @tir.tvm_throw_last_error(, dtype=int32)
          }
        }
      }
      if (@tir.TVMBackendFreeWorkspace(2, dev_id, T_softmax_maxelem, dtype=int32) != 0) {
        @tir.tvm_throw_last_error(, dtype=int32)
      }
    }
  }
}


[14:05:57] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.CombineContextCall
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_nn_softmax", "calling_conv": 1} {
  let stack_tcode: handle = @tir.tvm_stack_alloca("arg_tcode", 14, dtype=handle)
  let stack_value: handle = @tir.tvm_stack_alloca("arg_value", 14, dtype=handle)
  assert((num_args == 2), "fused_nn_softmax: num_args should be 2")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let placeholder: Pointer(float32) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let d0: int32 = cast(int32, (int64*)arg0.shape[0])
  let d1: int32 = cast(int32, (int64*)arg0.shape[1])
  let d2: int32 = cast(int32, (int64*)arg0.shape[2])
  let d3: int32 = cast(int32, (int64*)arg0.shape[3])
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let stride: int32 = @tir.if_then_else((d3 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides, dtype=bool), 1, cast(int32, (int64*)arg0.strides[3]), dtype=int32), dtype=int32)
  let stride_1: int32 = @tir.if_then_else((d2 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides, dtype=bool), d3, cast(int32, (int64*)arg0.strides[2]), dtype=int32), dtype=int32)
  let stride_2: int32 = @tir.if_then_else((d1 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides, dtype=bool), (d3*d2), cast(int32, (int64*)arg0.strides[1]), dtype=int32), dtype=int32)
  let stride_3: int32 = @tir.if_then_else((d0 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg0.strides, dtype=bool), ((d3*d2)*d1), cast(int32, (int64*)arg0.strides[0]), dtype=int32), dtype=int32)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let T_softmax_norm: Pointer(float32) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [T_softmax_norm] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  let stride_4: int32 = @tir.if_then_else((d3 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides, dtype=bool), 1, cast(int32, (int64*)arg1.strides[3]), dtype=int32), dtype=int32)
  let stride_5: int32 = @tir.if_then_else((d2 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides, dtype=bool), d3, cast(int32, (int64*)arg1.strides[2]), dtype=int32), dtype=int32)
  let stride_6: int32 = @tir.if_then_else((d1 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides, dtype=bool), (d3*d2), cast(int32, (int64*)arg1.strides[1]), dtype=int32), dtype=int32)
  let stride_7: int32 = @tir.if_then_else((d0 == 1), 0, @tir.if_then_else(@tir.isnullptr(arg1.strides, dtype=bool), ((d3*d2)*d1), cast(int32, (int64*)arg1.strides[0]), dtype=int32), dtype=int32)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "fused_nn_softmax: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "fused_nn_softmax: Expect arg[1] to be pointer")
  assert((4 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 4")
  assert((4 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 4")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 2u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 32u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be float32")
  assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((2 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (2 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((4 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 4")
  assert((4 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 4")
  assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 2u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 32u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be float32")
  assert((d0 == cast(int32, (int64*)arg1.shape[0])), "Argument arg1.shape[0] has an unsatisfied constraint: (d0 == int32(arg1.shape[0]))")
  assert((d1 == cast(int32, (int64*)arg1.shape[1])), "Argument arg1.shape[1] has an unsatisfied constraint: (d1 == int32(arg1.shape[1]))")
  assert((d2 == cast(int32, (int64*)arg1.shape[2])), "Argument arg1.shape[2] has an unsatisfied constraint: (d2 == int32(arg1.shape[2]))")
  assert((d3 == cast(int32, (int64*)arg1.shape[3])), "Argument arg1.shape[3] has an unsatisfied constraint: (d3 == int32(arg1.shape[3]))")
  assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((2 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (2 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
   {
     {
      @tir.tvm_struct_set(stack_value, 0, 12, cast(int64, 2), dtype=int32)
      stack_tcode[0] = 0
      @tir.tvm_struct_set(stack_value, 1, 12, cast(int64, dev_id), dtype=int32)
      stack_tcode[1] = 0
      @tir.tvm_call_packed_lowered("__tvm_set_device", stack_value, stack_tcode, 0, 2, dtype=int32)
    }
    attr [0] "compute_scope" = "fused_nn_softmax_compute_";
    attr [T_softmax_maxelem: Pointer(float32)] "storage_scope" = "global";
    attr [T_softmax_maxelem] "storage_alignment" = 128 {
      let T_softmax_maxelem = @tir.TVMBackendAllocWorkspace(2, dev_id, cast(uint64, (4*((d0*d1)*d2))), 2, 32, dtype=handle)
       {
        if @tir.isnullptr(T_softmax_maxelem, dtype=bool) {
          @tir.tvm_throw_last_error(, dtype=int32)
        }
        attr [T_softmax_exp: Pointer(float32)] "storage_scope" = "global";
        attr [T_softmax_exp] "storage_alignment" = 128 {
          let T_softmax_exp = @tir.TVMBackendAllocWorkspace(2, dev_id, cast(uint64, (4*(((d0*d1)*d2)*d3))), 2, 32, dtype=handle)
           {
            if @tir.isnullptr(T_softmax_exp, dtype=bool) {
              @tir.tvm_throw_last_error(, dtype=int32)
            }
             {
               {
                @tir.tvm_struct_set(stack_value, 0, 12, T_softmax_maxelem, dtype=int32)
                stack_tcode[0] = 3
                @tir.tvm_struct_set(stack_value, 1, 12, placeholder, dtype=int32)
                stack_tcode[1] = 3
                @tir.tvm_struct_set(stack_value, 2, 12, cast(int64, d0), dtype=int32)
                stack_tcode[2] = 0
                @tir.tvm_struct_set(stack_value, 3, 12, cast(int64, d1), dtype=int32)
                stack_tcode[3] = 0
                @tir.tvm_struct_set(stack_value, 4, 12, cast(int64, d2), dtype=int32)
                stack_tcode[4] = 0
                @tir.tvm_struct_set(stack_value, 5, 12, cast(int64, d3), dtype=int32)
                stack_tcode[5] = 0
                @tir.tvm_struct_set(stack_value, 6, 12, cast(int64, stride_3), dtype=int32)
                stack_tcode[6] = 0
                @tir.tvm_struct_set(stack_value, 7, 12, cast(int64, stride_2), dtype=int32)
                stack_tcode[7] = 0
                @tir.tvm_struct_set(stack_value, 8, 12, cast(int64, stride_1), dtype=int32)
                stack_tcode[8] = 0
                @tir.tvm_struct_set(stack_value, 9, 12, cast(int64, stride), dtype=int32)
                stack_tcode[9] = 0
                @tir.tvm_struct_set(stack_value, 10, 12, cast(int64, @tir.shift_right((((d0*d1)*d2) + 511), 9, dtype=int32)), dtype=int32)
                stack_tcode[10] = 0
                @tir.tvm_struct_set(stack_value, 11, 12, cast(int64, 512), dtype=int32)
                stack_tcode[11] = 0
                @tir.tvm_call_packed_lowered("fused_nn_softmax_kernel0", stack_value, stack_tcode, 0, 12, dtype=int32)
              }
               {
                @tir.tvm_struct_set(stack_value, 0, 12, T_softmax_exp, dtype=int32)
                stack_tcode[0] = 3
                @tir.tvm_struct_set(stack_value, 1, 12, placeholder, dtype=int32)
                stack_tcode[1] = 3
                @tir.tvm_struct_set(stack_value, 2, 12, T_softmax_maxelem, dtype=int32)
                stack_tcode[2] = 3
                @tir.tvm_struct_set(stack_value, 3, 12, cast(int64, d0), dtype=int32)
                stack_tcode[3] = 0
                @tir.tvm_struct_set(stack_value, 4, 12, cast(int64, d1), dtype=int32)
                stack_tcode[4] = 0
                @tir.tvm_struct_set(stack_value, 5, 12, cast(int64, d2), dtype=int32)
                stack_tcode[5] = 0
                @tir.tvm_struct_set(stack_value, 6, 12, cast(int64, d3), dtype=int32)
                stack_tcode[6] = 0
                @tir.tvm_struct_set(stack_value, 7, 12, cast(int64, stride_3), dtype=int32)
                stack_tcode[7] = 0
                @tir.tvm_struct_set(stack_value, 8, 12, cast(int64, stride_2), dtype=int32)
                stack_tcode[8] = 0
                @tir.tvm_struct_set(stack_value, 9, 12, cast(int64, stride_1), dtype=int32)
                stack_tcode[9] = 0
                @tir.tvm_struct_set(stack_value, 10, 12, cast(int64, stride), dtype=int32)
                stack_tcode[10] = 0
                @tir.tvm_struct_set(stack_value, 11, 12, cast(int64, @tir.shift_right(((((d0*d1)*d2)*d3) + 511), 9, dtype=int32)), dtype=int32)
                stack_tcode[11] = 0
                @tir.tvm_struct_set(stack_value, 12, 12, cast(int64, 512), dtype=int32)
                stack_tcode[12] = 0
                @tir.tvm_call_packed_lowered("fused_nn_softmax_kernel1", stack_value, stack_tcode, 0, 13, dtype=int32)
              }
               {
                @tir.tvm_struct_set(stack_value, 0, 12, T_softmax_maxelem, dtype=int32)
                stack_tcode[0] = 3
                @tir.tvm_struct_set(stack_value, 1, 12, T_softmax_exp, dtype=int32)
                stack_tcode[1] = 3
                @tir.tvm_struct_set(stack_value, 2, 12, cast(int64, d0), dtype=int32)
                stack_tcode[2] = 0
                @tir.tvm_struct_set(stack_value, 3, 12, cast(int64, d1), dtype=int32)
                stack_tcode[3] = 0
                @tir.tvm_struct_set(stack_value, 4, 12, cast(int64, d2), dtype=int32)
                stack_tcode[4] = 0
                @tir.tvm_struct_set(stack_value, 5, 12, cast(int64, d3), dtype=int32)
                stack_tcode[5] = 0
                @tir.tvm_struct_set(stack_value, 6, 12, cast(int64, @tir.shift_right((((d0*d1)*d2) + 511), 9, dtype=int32)), dtype=int32)
                stack_tcode[6] = 0
                @tir.tvm_struct_set(stack_value, 7, 12, cast(int64, 512), dtype=int32)
                stack_tcode[7] = 0
                @tir.tvm_call_packed_lowered("fused_nn_softmax_kernel2", stack_value, stack_tcode, 0, 8, dtype=int32)
              }
               {
                @tir.tvm_struct_set(stack_value, 0, 12, T_softmax_norm, dtype=int32)
                stack_tcode[0] = 3
                @tir.tvm_struct_set(stack_value, 1, 12, T_softmax_exp, dtype=int32)
                stack_tcode[1] = 3
                @tir.tvm_struct_set(stack_value, 2, 12, T_softmax_maxelem, dtype=int32)
                stack_tcode[2] = 3
                @tir.tvm_struct_set(stack_value, 3, 12, cast(int64, d0), dtype=int32)
                stack_tcode[3] = 0
                @tir.tvm_struct_set(stack_value, 4, 12, cast(int64, d1), dtype=int32)
                stack_tcode[4] = 0
                @tir.tvm_struct_set(stack_value, 5, 12, cast(int64, d2), dtype=int32)
                stack_tcode[5] = 0
                @tir.tvm_struct_set(stack_value, 6, 12, cast(int64, d3), dtype=int32)
                stack_tcode[6] = 0
                @tir.tvm_struct_set(stack_value, 7, 12, cast(int64, stride_7), dtype=int32)
                stack_tcode[7] = 0
                @tir.tvm_struct_set(stack_value, 8, 12, cast(int64, stride_6), dtype=int32)
                stack_tcode[8] = 0
                @tir.tvm_struct_set(stack_value, 9, 12, cast(int64, stride_5), dtype=int32)
                stack_tcode[9] = 0
                @tir.tvm_struct_set(stack_value, 10, 12, cast(int64, stride_4), dtype=int32)
                stack_tcode[10] = 0
                @tir.tvm_struct_set(stack_value, 11, 12, cast(int64, @tir.shift_right(((((d0*d1)*d2)*d3) + 511), 9, dtype=int32)), dtype=int32)
                stack_tcode[11] = 0
                @tir.tvm_struct_set(stack_value, 12, 12, cast(int64, 512), dtype=int32)
                stack_tcode[12] = 0
                @tir.tvm_call_packed_lowered("fused_nn_softmax_kernel3", stack_value, stack_tcode, 0, 13, dtype=int32)
              }
            }
          }
          if (@tir.TVMBackendFreeWorkspace(2, dev_id, T_softmax_exp, dtype=int32) != 0) {
            @tir.tvm_throw_last_error(, dtype=int32)
          }
        }
      }
      if (@tir.TVMBackendFreeWorkspace(2, dev_id, T_softmax_maxelem, dtype=int32) != 0) {
        @tir.tvm_throw_last_error(, dtype=int32)
      }
    }
  }
}


[14:05:57] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass Filter
primfn(T_softmax_exp: Pointer(float32), placeholder: Pointer(float32), T_softmax_maxelem: Pointer(float32), d0: int32, d1: int32, d2: int32, d3: int32, stride: int32, stride_1: int32, stride_2: int32, stride_3: int32) -> ()
  attr = {"target": meta[Target][0], "tir.noalias": 1, "global_symbol": "fused_nn_softmax_kernel1", "tir.device_thread_axis": [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x"), IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")], "calling_conv": 2} {
  attr [IterVar(blockIdx.x, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
  attr [IterVar(threadIdx.x, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
  if (blockIdx.x < floordiv((((d0*d1)*d2)*d3), 512)) {
    if (floordiv(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1) < d0) {
      if (floormod(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1) < d1) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2) < d2) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d3) < d3) {
            if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2) < (d0*d1)) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d3) < ((d0*d1)*d2)) {
                T_softmax_exp[((blockIdx.x*512) + threadIdx.x)] = @tir.exp(((float32*)placeholder[((((floordiv(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2)*stride_2)) + (floormod(((blockIdx.x*512) + threadIdx.x), d3)*stride_3))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x*512) + threadIdx.x), d3)]), dtype=float32)
              }
            }
          }
        }
      }
    }
  } else {
    if (floordiv(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1) < d0) {
      if (floormod(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1) < d1) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2) < d2) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d3) < d3) {
            if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2) < (d0*d1)) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d3) < ((d0*d1)*d2)) {
                if (((blockIdx.x*512) + threadIdx.x) < (((d0*d1)*d2)*d3)) {
                  T_softmax_exp[((blockIdx.x*512) + threadIdx.x)] = @tir.exp(((float32*)placeholder[((((floordiv(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2)*stride_2)) + (floormod(((blockIdx.x*512) + threadIdx.x), d3)*stride_3))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x*512) + threadIdx.x), d3)]), dtype=float32)
                }
              }
            }
          }
        }
      }
    }
  }
}

primfn(T_softmax_norm: Pointer(float32), T_softmax_exp_1: Pointer(float32), T_softmax_maxelem_1: Pointer(float32), d0_1: int32, d1_1: int32, d2_1: int32, d3_1: int32, stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32) -> ()
  attr = {"target": meta[Target][0], "tir.noalias": 1, "global_symbol": "fused_nn_softmax_kernel3", "tir.device_thread_axis": [IterVar(blockIdx.x_1: int32, (nullptr), "ThreadIndex", "blockIdx.x"), IterVar(threadIdx.x_1: int32, (nullptr), "ThreadIndex", "threadIdx.x")], "calling_conv": 2} {
  attr [IterVar(blockIdx.x_1, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0_1*d1_1)*d2_1)*d3_1) + 511), 512);
  attr [IterVar(threadIdx.x_1, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
  if (blockIdx.x_1 < floordiv((((d0_1*d1_1)*d2_1)*d3_1), 512)) {
    if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1) < d0_1) {
      if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1) < d1_1) {
        if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1) < d2_1) {
          if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3_1) < d3_1) {
            if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1) < (d0_1*d1_1)) {
              if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1) < ((d0_1*d1_1)*d2_1)) {
                T_softmax_norm[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3_1)*stride_7))] = ((float32*)T_softmax_exp_1[((blockIdx.x_1*512) + threadIdx.x_1)] / (float32*)T_softmax_maxelem_1[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1)])
              }
            }
          }
        }
      }
    }
  } else {
    if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1) < d0_1) {
      if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1) < d1_1) {
        if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1) < d2_1) {
          if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3_1) < d3_1) {
            if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1) < (d0_1*d1_1)) {
              if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1) < ((d0_1*d1_1)*d2_1)) {
                if (((blockIdx.x_1*512) + threadIdx.x_1) < (((d0_1*d1_1)*d2_1)*d3_1)) {
                  T_softmax_norm[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3_1)*stride_7))] = ((float32*)T_softmax_exp_1[((blockIdx.x_1*512) + threadIdx.x_1)] / (float32*)T_softmax_maxelem_1[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1)])
                }
              }
            }
          }
        }
      }
    }
  }
}

primfn(T_softmax_maxelem_2: Pointer(float32), placeholder_1: Pointer(float32), d0_2: int32, d1_2: int32, d2_2: int32, d3_2: int32, stride_8: int32, stride_9: int32, stride_10: int32, stride_11: int32) -> ()
  attr = {"target": meta[Target][0], "tir.noalias": 1, "global_symbol": "fused_nn_softmax_kernel0", "tir.device_thread_axis": [IterVar(blockIdx.x_2: int32, (nullptr), "ThreadIndex", "blockIdx.x"), IterVar(threadIdx.x_2: int32, (nullptr), "ThreadIndex", "threadIdx.x")], "calling_conv": 2} {
  attr [IterVar(blockIdx.x_2, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0_2*d1_2)*d2_2) + 511), 512);
  attr [IterVar(threadIdx.x_2, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
  if (blockIdx.x_2 < floordiv(((d0_2*d1_2)*d2_2), 512)) {
    if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d0_2) {
      if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d1_2) {
        if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < d2_2) {
          if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < (d0_2*d1_2)) {
            T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)] = -3.40282e+38f32
          }
        }
      }
    }
    for (k: int32, 0, d3_2) {
      if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d0_2) {
        if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d1_2) {
          if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < d2_2) {
            if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < (d0_2*d1_2)) {
              T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)] = max((float32*)T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)], (float32*)placeholder_1[((((floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2)*stride_8) + (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2)*stride_9)) + (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2_2)*stride_10)) + (k*stride_11))])
            }
          }
        }
      }
    }
  } else {
    if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d0_2) {
      if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d1_2) {
        if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < d2_2) {
          if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < (d0_2*d1_2)) {
            if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0_2*d1_2)*d2_2)) {
              T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)] = -3.40282e+38f32
            }
          }
        }
      }
    }
    for (k_1: int32, 0, d3_2) {
      if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d0_2) {
        if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d1_2) {
          if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < d2_2) {
            if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < (d0_2*d1_2)) {
              if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0_2*d1_2)*d2_2)) {
                T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)] = max((float32*)T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)], (float32*)placeholder_1[((((floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2)*stride_8) + (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2)*stride_9)) + (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2_2)*stride_10)) + (k_1*stride_11))])
              }
            }
          }
        }
      }
    }
  }
}

primfn(T_softmax_maxelem_3: Pointer(float32), T_softmax_exp_2: Pointer(float32), d0_3: int32, d1_3: int32, d2_3: int32, d3_3: int32) -> ()
  attr = {"target": meta[Target][0], "tir.noalias": 1, "global_symbol": "fused_nn_softmax_kernel2", "tir.device_thread_axis": [IterVar(blockIdx.x_3: int32, (nullptr), "ThreadIndex", "blockIdx.x"), IterVar(threadIdx.x_3: int32, (nullptr), "ThreadIndex", "threadIdx.x")], "calling_conv": 2} {
  attr [IterVar(blockIdx.x_3, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0_3*d1_3)*d2_3) + 511), 512);
  attr [IterVar(threadIdx.x_3, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
  if (blockIdx.x_3 < floordiv(((d0_3*d1_3)*d2_3), 512)) {
    if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d0_3) {
      if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d1_3) {
        if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < d2_3) {
          if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < (d0_3*d1_3)) {
            T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] = 0f32
          }
        }
      }
    }
    for (k_2: int32, 0, d3_3) {
      if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d0_3) {
        if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d1_3) {
          if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < d2_3) {
            if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < (d0_3*d1_3)) {
              T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] = ((float32*)T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] + (float32*)T_softmax_exp_2[((((blockIdx.x_3*512) + threadIdx.x_3)*d3_3) + k_2)])
            }
          }
        }
      }
    }
  } else {
    if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d0_3) {
      if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d1_3) {
        if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < d2_3) {
          if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < (d0_3*d1_3)) {
            if (((blockIdx.x_3*512) + threadIdx.x_3) < ((d0_3*d1_3)*d2_3)) {
              T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] = 0f32
            }
          }
        }
      }
    }
    for (k_3: int32, 0, d3_3) {
      if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d0_3) {
        if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d1_3) {
          if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < d2_3) {
            if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < (d0_3*d1_3)) {
              if (((blockIdx.x_3*512) + threadIdx.x_3) < ((d0_3*d1_3)*d2_3)) {
                T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] = ((float32*)T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] + (float32*)T_softmax_exp_2[((((blockIdx.x_3*512) + threadIdx.x_3)*d3_3) + k_3)])
              }
            }
          }
        }
      }
    }
  }
}


[14:05:57] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass BindTarget
primfn(T_softmax_exp: Pointer(float32), placeholder: Pointer(float32), T_softmax_maxelem: Pointer(float32), d0: int32, d1: int32, d2: int32, d3: int32, stride: int32, stride_1: int32, stride_2: int32, stride_3: int32) -> ()
  attr = {"target": meta[Target][0], "tir.noalias": 1, "global_symbol": "fused_nn_softmax_kernel1", "tir.device_thread_axis": [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x"), IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")], "calling_conv": 2} {
  attr [IterVar(blockIdx.x, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
  attr [IterVar(threadIdx.x, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
  if (blockIdx.x < floordiv((((d0*d1)*d2)*d3), 512)) {
    if (floordiv(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1) < d0) {
      if (floormod(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1) < d1) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2) < d2) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d3) < d3) {
            if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2) < (d0*d1)) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d3) < ((d0*d1)*d2)) {
                T_softmax_exp[((blockIdx.x*512) + threadIdx.x)] = @tir.exp(((float32*)placeholder[((((floordiv(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2)*stride_2)) + (floormod(((blockIdx.x*512) + threadIdx.x), d3)*stride_3))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x*512) + threadIdx.x), d3)]), dtype=float32)
              }
            }
          }
        }
      }
    }
  } else {
    if (floordiv(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1) < d0) {
      if (floormod(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1) < d1) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2) < d2) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d3) < d3) {
            if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2) < (d0*d1)) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d3) < ((d0*d1)*d2)) {
                if (((blockIdx.x*512) + threadIdx.x) < (((d0*d1)*d2)*d3)) {
                  T_softmax_exp[((blockIdx.x*512) + threadIdx.x)] = @tir.exp(((float32*)placeholder[((((floordiv(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2)*stride_2)) + (floormod(((blockIdx.x*512) + threadIdx.x), d3)*stride_3))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x*512) + threadIdx.x), d3)]), dtype=float32)
                }
              }
            }
          }
        }
      }
    }
  }
}

primfn(T_softmax_norm: Pointer(float32), T_softmax_exp_1: Pointer(float32), T_softmax_maxelem_1: Pointer(float32), d0_1: int32, d1_1: int32, d2_1: int32, d3_1: int32, stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32) -> ()
  attr = {"target": meta[Target][0], "tir.noalias": 1, "global_symbol": "fused_nn_softmax_kernel3", "tir.device_thread_axis": [IterVar(blockIdx.x_1: int32, (nullptr), "ThreadIndex", "blockIdx.x"), IterVar(threadIdx.x_1: int32, (nullptr), "ThreadIndex", "threadIdx.x")], "calling_conv": 2} {
  attr [IterVar(blockIdx.x_1, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0_1*d1_1)*d2_1)*d3_1) + 511), 512);
  attr [IterVar(threadIdx.x_1, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
  if (blockIdx.x_1 < floordiv((((d0_1*d1_1)*d2_1)*d3_1), 512)) {
    if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1) < d0_1) {
      if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1) < d1_1) {
        if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1) < d2_1) {
          if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3_1) < d3_1) {
            if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1) < (d0_1*d1_1)) {
              if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1) < ((d0_1*d1_1)*d2_1)) {
                T_softmax_norm[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3_1)*stride_7))] = ((float32*)T_softmax_exp_1[((blockIdx.x_1*512) + threadIdx.x_1)] / (float32*)T_softmax_maxelem_1[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1)])
              }
            }
          }
        }
      }
    }
  } else {
    if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1) < d0_1) {
      if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1) < d1_1) {
        if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1) < d2_1) {
          if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3_1) < d3_1) {
            if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1) < (d0_1*d1_1)) {
              if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1) < ((d0_1*d1_1)*d2_1)) {
                if (((blockIdx.x_1*512) + threadIdx.x_1) < (((d0_1*d1_1)*d2_1)*d3_1)) {
                  T_softmax_norm[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3_1)*stride_7))] = ((float32*)T_softmax_exp_1[((blockIdx.x_1*512) + threadIdx.x_1)] / (float32*)T_softmax_maxelem_1[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1)])
                }
              }
            }
          }
        }
      }
    }
  }
}

primfn(T_softmax_maxelem_2: Pointer(float32), placeholder_1: Pointer(float32), d0_2: int32, d1_2: int32, d2_2: int32, d3_2: int32, stride_8: int32, stride_9: int32, stride_10: int32, stride_11: int32) -> ()
  attr = {"target": meta[Target][0], "tir.noalias": 1, "global_symbol": "fused_nn_softmax_kernel0", "tir.device_thread_axis": [IterVar(blockIdx.x_2: int32, (nullptr), "ThreadIndex", "blockIdx.x"), IterVar(threadIdx.x_2: int32, (nullptr), "ThreadIndex", "threadIdx.x")], "calling_conv": 2} {
  attr [IterVar(blockIdx.x_2, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0_2*d1_2)*d2_2) + 511), 512);
  attr [IterVar(threadIdx.x_2, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
  if (blockIdx.x_2 < floordiv(((d0_2*d1_2)*d2_2), 512)) {
    if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d0_2) {
      if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d1_2) {
        if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < d2_2) {
          if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < (d0_2*d1_2)) {
            T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)] = -3.40282e+38f32
          }
        }
      }
    }
    for (k: int32, 0, d3_2) {
      if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d0_2) {
        if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d1_2) {
          if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < d2_2) {
            if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < (d0_2*d1_2)) {
              T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)] = max((float32*)T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)], (float32*)placeholder_1[((((floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2)*stride_8) + (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2)*stride_9)) + (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2_2)*stride_10)) + (k*stride_11))])
            }
          }
        }
      }
    }
  } else {
    if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d0_2) {
      if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d1_2) {
        if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < d2_2) {
          if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < (d0_2*d1_2)) {
            if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0_2*d1_2)*d2_2)) {
              T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)] = -3.40282e+38f32
            }
          }
        }
      }
    }
    for (k_1: int32, 0, d3_2) {
      if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d0_2) {
        if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d1_2) {
          if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < d2_2) {
            if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < (d0_2*d1_2)) {
              if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0_2*d1_2)*d2_2)) {
                T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)] = max((float32*)T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)], (float32*)placeholder_1[((((floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2)*stride_8) + (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2)*stride_9)) + (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2_2)*stride_10)) + (k_1*stride_11))])
              }
            }
          }
        }
      }
    }
  }
}

primfn(T_softmax_maxelem_3: Pointer(float32), T_softmax_exp_2: Pointer(float32), d0_3: int32, d1_3: int32, d2_3: int32, d3_3: int32) -> ()
  attr = {"target": meta[Target][0], "tir.noalias": 1, "global_symbol": "fused_nn_softmax_kernel2", "tir.device_thread_axis": [IterVar(blockIdx.x_3: int32, (nullptr), "ThreadIndex", "blockIdx.x"), IterVar(threadIdx.x_3: int32, (nullptr), "ThreadIndex", "threadIdx.x")], "calling_conv": 2} {
  attr [IterVar(blockIdx.x_3, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0_3*d1_3)*d2_3) + 511), 512);
  attr [IterVar(threadIdx.x_3, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
  if (blockIdx.x_3 < floordiv(((d0_3*d1_3)*d2_3), 512)) {
    if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d0_3) {
      if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d1_3) {
        if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < d2_3) {
          if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < (d0_3*d1_3)) {
            T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] = 0f32
          }
        }
      }
    }
    for (k_2: int32, 0, d3_3) {
      if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d0_3) {
        if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d1_3) {
          if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < d2_3) {
            if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < (d0_3*d1_3)) {
              T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] = ((float32*)T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] + (float32*)T_softmax_exp_2[((((blockIdx.x_3*512) + threadIdx.x_3)*d3_3) + k_2)])
            }
          }
        }
      }
    }
  } else {
    if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d0_3) {
      if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d1_3) {
        if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < d2_3) {
          if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < (d0_3*d1_3)) {
            if (((blockIdx.x_3*512) + threadIdx.x_3) < ((d0_3*d1_3)*d2_3)) {
              T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] = 0f32
            }
          }
        }
      }
    }
    for (k_3: int32, 0, d3_3) {
      if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d0_3) {
        if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d1_3) {
          if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < d2_3) {
            if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < (d0_3*d1_3)) {
              if (((blockIdx.x_3*512) + threadIdx.x_3) < ((d0_3*d1_3)*d2_3)) {
                T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] = ((float32*)T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] + (float32*)T_softmax_exp_2[((((blockIdx.x_3*512) + threadIdx.x_3)*d3_3) + k_3)])
              }
            }
          }
        }
      }
    }
  }
}


[14:05:57] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerWarpMemory
primfn(T_softmax_exp: Pointer(float32), placeholder: Pointer(float32), T_softmax_maxelem: Pointer(float32), d0: int32, d1: int32, d2: int32, d3: int32, stride: int32, stride_1: int32, stride_2: int32, stride_3: int32) -> ()
  attr = {"target": meta[Target][0], "tir.noalias": 1, "global_symbol": "fused_nn_softmax_kernel1", "tir.device_thread_axis": [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x"), IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")], "calling_conv": 2} {
  attr [IterVar(blockIdx.x, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
  attr [IterVar(threadIdx.x, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
  if (blockIdx.x < floordiv((((d0*d1)*d2)*d3), 512)) {
    if (floordiv(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1) < d0) {
      if (floormod(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1) < d1) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2) < d2) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d3) < d3) {
            if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2) < (d0*d1)) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d3) < ((d0*d1)*d2)) {
                T_softmax_exp[((blockIdx.x*512) + threadIdx.x)] = @tir.exp(((float32*)placeholder[((((floordiv(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2)*stride_2)) + (floormod(((blockIdx.x*512) + threadIdx.x), d3)*stride_3))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x*512) + threadIdx.x), d3)]), dtype=float32)
              }
            }
          }
        }
      }
    }
  } else {
    if (floordiv(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1) < d0) {
      if (floormod(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1) < d1) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2) < d2) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d3) < d3) {
            if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2) < (d0*d1)) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d3) < ((d0*d1)*d2)) {
                if (((blockIdx.x*512) + threadIdx.x) < (((d0*d1)*d2)*d3)) {
                  T_softmax_exp[((blockIdx.x*512) + threadIdx.x)] = @tir.exp(((float32*)placeholder[((((floordiv(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2)*stride_2)) + (floormod(((blockIdx.x*512) + threadIdx.x), d3)*stride_3))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x*512) + threadIdx.x), d3)]), dtype=float32)
                }
              }
            }
          }
        }
      }
    }
  }
}

primfn(T_softmax_norm: Pointer(float32), T_softmax_exp_1: Pointer(float32), T_softmax_maxelem_1: Pointer(float32), d0_1: int32, d1_1: int32, d2_1: int32, d3_1: int32, stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32) -> ()
  attr = {"target": meta[Target][0], "tir.noalias": 1, "global_symbol": "fused_nn_softmax_kernel3", "tir.device_thread_axis": [IterVar(blockIdx.x_1: int32, (nullptr), "ThreadIndex", "blockIdx.x"), IterVar(threadIdx.x_1: int32, (nullptr), "ThreadIndex", "threadIdx.x")], "calling_conv": 2} {
  attr [IterVar(blockIdx.x_1, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0_1*d1_1)*d2_1)*d3_1) + 511), 512);
  attr [IterVar(threadIdx.x_1, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
  if (blockIdx.x_1 < floordiv((((d0_1*d1_1)*d2_1)*d3_1), 512)) {
    if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1) < d0_1) {
      if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1) < d1_1) {
        if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1) < d2_1) {
          if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3_1) < d3_1) {
            if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1) < (d0_1*d1_1)) {
              if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1) < ((d0_1*d1_1)*d2_1)) {
                T_softmax_norm[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3_1)*stride_7))] = ((float32*)T_softmax_exp_1[((blockIdx.x_1*512) + threadIdx.x_1)] / (float32*)T_softmax_maxelem_1[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1)])
              }
            }
          }
        }
      }
    }
  } else {
    if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1) < d0_1) {
      if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1) < d1_1) {
        if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1) < d2_1) {
          if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3_1) < d3_1) {
            if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1) < (d0_1*d1_1)) {
              if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1) < ((d0_1*d1_1)*d2_1)) {
                if (((blockIdx.x_1*512) + threadIdx.x_1) < (((d0_1*d1_1)*d2_1)*d3_1)) {
                  T_softmax_norm[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3_1)*stride_7))] = ((float32*)T_softmax_exp_1[((blockIdx.x_1*512) + threadIdx.x_1)] / (float32*)T_softmax_maxelem_1[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1)])
                }
              }
            }
          }
        }
      }
    }
  }
}

primfn(T_softmax_maxelem_2: Pointer(float32), placeholder_1: Pointer(float32), d0_2: int32, d1_2: int32, d2_2: int32, d3_2: int32, stride_8: int32, stride_9: int32, stride_10: int32, stride_11: int32) -> ()
  attr = {"target": meta[Target][0], "tir.noalias": 1, "global_symbol": "fused_nn_softmax_kernel0", "tir.device_thread_axis": [IterVar(blockIdx.x_2: int32, (nullptr), "ThreadIndex", "blockIdx.x"), IterVar(threadIdx.x_2: int32, (nullptr), "ThreadIndex", "threadIdx.x")], "calling_conv": 2} {
  attr [IterVar(blockIdx.x_2, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0_2*d1_2)*d2_2) + 511), 512);
  attr [IterVar(threadIdx.x_2, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
  if (blockIdx.x_2 < floordiv(((d0_2*d1_2)*d2_2), 512)) {
    if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d0_2) {
      if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d1_2) {
        if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < d2_2) {
          if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < (d0_2*d1_2)) {
            T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)] = -3.40282e+38f32
          }
        }
      }
    }
    for (k: int32, 0, d3_2) {
      if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d0_2) {
        if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d1_2) {
          if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < d2_2) {
            if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < (d0_2*d1_2)) {
              T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)] = max((float32*)T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)], (float32*)placeholder_1[((((floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2)*stride_8) + (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2)*stride_9)) + (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2_2)*stride_10)) + (k*stride_11))])
            }
          }
        }
      }
    }
  } else {
    if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d0_2) {
      if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d1_2) {
        if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < d2_2) {
          if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < (d0_2*d1_2)) {
            if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0_2*d1_2)*d2_2)) {
              T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)] = -3.40282e+38f32
            }
          }
        }
      }
    }
    for (k_1: int32, 0, d3_2) {
      if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d0_2) {
        if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d1_2) {
          if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < d2_2) {
            if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < (d0_2*d1_2)) {
              if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0_2*d1_2)*d2_2)) {
                T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)] = max((float32*)T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)], (float32*)placeholder_1[((((floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2)*stride_8) + (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2)*stride_9)) + (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2_2)*stride_10)) + (k_1*stride_11))])
              }
            }
          }
        }
      }
    }
  }
}

primfn(T_softmax_maxelem_3: Pointer(float32), T_softmax_exp_2: Pointer(float32), d0_3: int32, d1_3: int32, d2_3: int32, d3_3: int32) -> ()
  attr = {"target": meta[Target][0], "tir.noalias": 1, "global_symbol": "fused_nn_softmax_kernel2", "tir.device_thread_axis": [IterVar(blockIdx.x_3: int32, (nullptr), "ThreadIndex", "blockIdx.x"), IterVar(threadIdx.x_3: int32, (nullptr), "ThreadIndex", "threadIdx.x")], "calling_conv": 2} {
  attr [IterVar(blockIdx.x_3, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0_3*d1_3)*d2_3) + 511), 512);
  attr [IterVar(threadIdx.x_3, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
  if (blockIdx.x_3 < floordiv(((d0_3*d1_3)*d2_3), 512)) {
    if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d0_3) {
      if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d1_3) {
        if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < d2_3) {
          if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < (d0_3*d1_3)) {
            T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] = 0f32
          }
        }
      }
    }
    for (k_2: int32, 0, d3_3) {
      if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d0_3) {
        if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d1_3) {
          if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < d2_3) {
            if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < (d0_3*d1_3)) {
              T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] = ((float32*)T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] + (float32*)T_softmax_exp_2[((((blockIdx.x_3*512) + threadIdx.x_3)*d3_3) + k_2)])
            }
          }
        }
      }
    }
  } else {
    if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d0_3) {
      if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d1_3) {
        if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < d2_3) {
          if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < (d0_3*d1_3)) {
            if (((blockIdx.x_3*512) + threadIdx.x_3) < ((d0_3*d1_3)*d2_3)) {
              T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] = 0f32
            }
          }
        }
      }
    }
    for (k_3: int32, 0, d3_3) {
      if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d0_3) {
        if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d1_3) {
          if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < d2_3) {
            if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < (d0_3*d1_3)) {
              if (((blockIdx.x_3*512) + threadIdx.x_3) < ((d0_3*d1_3)*d2_3)) {
                T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] = ((float32*)T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] + (float32*)T_softmax_exp_2[((((blockIdx.x_3*512) + threadIdx.x_3)*d3_3) + k_3)])
              }
            }
          }
        }
      }
    }
  }
}


[14:05:57] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify
primfn(T_softmax_exp: Pointer(float32), placeholder: Pointer(float32), T_softmax_maxelem: Pointer(float32), d0: int32, d1: int32, d2: int32, d3: int32, stride: int32, stride_1: int32, stride_2: int32, stride_3: int32) -> ()
  attr = {"target": meta[Target][0], "tir.noalias": 1, "global_symbol": "fused_nn_softmax_kernel1", "tir.device_thread_axis": [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x"), IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")], "calling_conv": 2} {
  attr [IterVar(blockIdx.x, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
  attr [IterVar(threadIdx.x, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
  if (blockIdx.x < floordiv((((d0*d1)*d2)*d3), 512)) {
    if (floordiv(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1) < d0) {
      if (floormod(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1) < d1) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2) < d2) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d3) < d3) {
            if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2) < (d0*d1)) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d3) < ((d0*d1)*d2)) {
                T_softmax_exp[((blockIdx.x*512) + threadIdx.x)] = @tir.exp(((float32*)placeholder[((((floordiv(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2)*stride_2)) + (floormod(((blockIdx.x*512) + threadIdx.x), d3)*stride_3))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x*512) + threadIdx.x), d3)]), dtype=float32)
              }
            }
          }
        }
      }
    }
  } else {
    if (floordiv(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1) < d0) {
      if (floormod(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1) < d1) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2) < d2) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d3) < d3) {
            if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2) < (d0*d1)) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d3) < ((d0*d1)*d2)) {
                if (((blockIdx.x*512) + threadIdx.x) < (((d0*d1)*d2)*d3)) {
                  T_softmax_exp[((blockIdx.x*512) + threadIdx.x)] = @tir.exp(((float32*)placeholder[((((floordiv(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2)*stride_2)) + (floormod(((blockIdx.x*512) + threadIdx.x), d3)*stride_3))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x*512) + threadIdx.x), d3)]), dtype=float32)
                }
              }
            }
          }
        }
      }
    }
  }
}

primfn(T_softmax_norm: Pointer(float32), T_softmax_exp_1: Pointer(float32), T_softmax_maxelem_1: Pointer(float32), d0_1: int32, d1_1: int32, d2_1: int32, d3_1: int32, stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32) -> ()
  attr = {"target": meta[Target][0], "tir.noalias": 1, "global_symbol": "fused_nn_softmax_kernel3", "tir.device_thread_axis": [IterVar(blockIdx.x_1: int32, (nullptr), "ThreadIndex", "blockIdx.x"), IterVar(threadIdx.x_1: int32, (nullptr), "ThreadIndex", "threadIdx.x")], "calling_conv": 2} {
  attr [IterVar(blockIdx.x_1, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0_1*d1_1)*d2_1)*d3_1) + 511), 512);
  attr [IterVar(threadIdx.x_1, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
  if (blockIdx.x_1 < floordiv((((d0_1*d1_1)*d2_1)*d3_1), 512)) {
    if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1) < d0_1) {
      if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1) < d1_1) {
        if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1) < d2_1) {
          if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3_1) < d3_1) {
            if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1) < (d0_1*d1_1)) {
              if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1) < ((d0_1*d1_1)*d2_1)) {
                T_softmax_norm[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3_1)*stride_7))] = ((float32*)T_softmax_exp_1[((blockIdx.x_1*512) + threadIdx.x_1)] / (float32*)T_softmax_maxelem_1[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1)])
              }
            }
          }
        }
      }
    }
  } else {
    if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1) < d0_1) {
      if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1) < d1_1) {
        if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1) < d2_1) {
          if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3_1) < d3_1) {
            if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1) < (d0_1*d1_1)) {
              if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1) < ((d0_1*d1_1)*d2_1)) {
                if (((blockIdx.x_1*512) + threadIdx.x_1) < (((d0_1*d1_1)*d2_1)*d3_1)) {
                  T_softmax_norm[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3_1)*stride_7))] = ((float32*)T_softmax_exp_1[((blockIdx.x_1*512) + threadIdx.x_1)] / (float32*)T_softmax_maxelem_1[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1)])
                }
              }
            }
          }
        }
      }
    }
  }
}

primfn(T_softmax_maxelem_2: Pointer(float32), placeholder_1: Pointer(float32), d0_2: int32, d1_2: int32, d2_2: int32, d3_2: int32, stride_8: int32, stride_9: int32, stride_10: int32, stride_11: int32) -> ()
  attr = {"target": meta[Target][0], "tir.noalias": 1, "global_symbol": "fused_nn_softmax_kernel0", "tir.device_thread_axis": [IterVar(blockIdx.x_2: int32, (nullptr), "ThreadIndex", "blockIdx.x"), IterVar(threadIdx.x_2: int32, (nullptr), "ThreadIndex", "threadIdx.x")], "calling_conv": 2} {
  attr [IterVar(blockIdx.x_2, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0_2*d1_2)*d2_2) + 511), 512);
  attr [IterVar(threadIdx.x_2, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
  if (blockIdx.x_2 < floordiv(((d0_2*d1_2)*d2_2), 512)) {
    if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d0_2) {
      if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d1_2) {
        if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < d2_2) {
          if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < (d0_2*d1_2)) {
            T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)] = -3.40282e+38f32
          }
        }
      }
    }
    for (k: int32, 0, d3_2) {
      if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d0_2) {
        if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d1_2) {
          if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < d2_2) {
            if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < (d0_2*d1_2)) {
              T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)] = max((float32*)T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)], (float32*)placeholder_1[((((floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2)*stride_8) + (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2)*stride_9)) + (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2_2)*stride_10)) + (k*stride_11))])
            }
          }
        }
      }
    }
  } else {
    if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d0_2) {
      if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d1_2) {
        if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < d2_2) {
          if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < (d0_2*d1_2)) {
            if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0_2*d1_2)*d2_2)) {
              T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)] = -3.40282e+38f32
            }
          }
        }
      }
    }
    for (k_1: int32, 0, d3_2) {
      if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d0_2) {
        if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d1_2) {
          if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < d2_2) {
            if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < (d0_2*d1_2)) {
              if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0_2*d1_2)*d2_2)) {
                T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)] = max((float32*)T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)], (float32*)placeholder_1[((((floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2)*stride_8) + (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2)*stride_9)) + (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2_2)*stride_10)) + (k_1*stride_11))])
              }
            }
          }
        }
      }
    }
  }
}

primfn(T_softmax_maxelem_3: Pointer(float32), T_softmax_exp_2: Pointer(float32), d0_3: int32, d1_3: int32, d2_3: int32, d3_3: int32) -> ()
  attr = {"target": meta[Target][0], "tir.noalias": 1, "global_symbol": "fused_nn_softmax_kernel2", "tir.device_thread_axis": [IterVar(blockIdx.x_3: int32, (nullptr), "ThreadIndex", "blockIdx.x"), IterVar(threadIdx.x_3: int32, (nullptr), "ThreadIndex", "threadIdx.x")], "calling_conv": 2} {
  attr [IterVar(blockIdx.x_3, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0_3*d1_3)*d2_3) + 511), 512);
  attr [IterVar(threadIdx.x_3, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
  if (blockIdx.x_3 < floordiv(((d0_3*d1_3)*d2_3), 512)) {
    if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d0_3) {
      if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d1_3) {
        if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < d2_3) {
          if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < (d0_3*d1_3)) {
            T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] = 0f32
          }
        }
      }
    }
    for (k_2: int32, 0, d3_3) {
      if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d0_3) {
        if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d1_3) {
          if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < d2_3) {
            if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < (d0_3*d1_3)) {
              T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] = ((float32*)T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] + (float32*)T_softmax_exp_2[((((blockIdx.x_3*512) + threadIdx.x_3)*d3_3) + k_2)])
            }
          }
        }
      }
    }
  } else {
    if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d0_3) {
      if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d1_3) {
        if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < d2_3) {
          if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < (d0_3*d1_3)) {
            if (((blockIdx.x_3*512) + threadIdx.x_3) < ((d0_3*d1_3)*d2_3)) {
              T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] = 0f32
            }
          }
        }
      }
    }
    for (k_3: int32, 0, d3_3) {
      if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d0_3) {
        if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d1_3) {
          if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < d2_3) {
            if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < (d0_3*d1_3)) {
              if (((blockIdx.x_3*512) + threadIdx.x_3) < ((d0_3*d1_3)*d2_3)) {
                T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] = ((float32*)T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] + (float32*)T_softmax_exp_2[((((blockIdx.x_3*512) + threadIdx.x_3)*d3_3) + k_3)])
              }
            }
          }
        }
      }
    }
  }
}


[14:05:57] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerCustomDatatypes
primfn(T_softmax_exp: Pointer(float32), placeholder: Pointer(float32), T_softmax_maxelem: Pointer(float32), d0: int32, d1: int32, d2: int32, d3: int32, stride: int32, stride_1: int32, stride_2: int32, stride_3: int32) -> ()
  attr = {"target": meta[Target][0], "tir.noalias": 1, "global_symbol": "fused_nn_softmax_kernel1", "tir.device_thread_axis": [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x"), IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")], "calling_conv": 2} {
  attr [IterVar(blockIdx.x, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0*d1)*d2)*d3) + 511), 512);
  attr [IterVar(threadIdx.x, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
  if (blockIdx.x < floordiv((((d0*d1)*d2)*d3), 512)) {
    if (floordiv(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1) < d0) {
      if (floormod(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1) < d1) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2) < d2) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d3) < d3) {
            if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2) < (d0*d1)) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d3) < ((d0*d1)*d2)) {
                T_softmax_exp[((blockIdx.x*512) + threadIdx.x)] = @tir.exp(((float32*)placeholder[((((floordiv(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2)*stride_2)) + (floormod(((blockIdx.x*512) + threadIdx.x), d3)*stride_3))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x*512) + threadIdx.x), d3)]), dtype=float32)
              }
            }
          }
        }
      }
    }
  } else {
    if (floordiv(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1) < d0) {
      if (floormod(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1) < d1) {
        if (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2) < d2) {
          if (floormod(((blockIdx.x*512) + threadIdx.x), d3) < d3) {
            if (floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2) < (d0*d1)) {
              if (floordiv(((blockIdx.x*512) + threadIdx.x), d3) < ((d0*d1)*d2)) {
                if (((blockIdx.x*512) + threadIdx.x) < (((d0*d1)*d2)*d3)) {
                  T_softmax_exp[((blockIdx.x*512) + threadIdx.x)] = @tir.exp(((float32*)placeholder[((((floordiv(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1)*stride) + (floormod(floordiv(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2), d1)*stride_1)) + (floormod(floordiv(((blockIdx.x*512) + threadIdx.x), d3), d2)*stride_2)) + (floormod(((blockIdx.x*512) + threadIdx.x), d3)*stride_3))] - (float32*)T_softmax_maxelem[floordiv(((blockIdx.x*512) + threadIdx.x), d3)]), dtype=float32)
                }
              }
            }
          }
        }
      }
    }
  }
}

primfn(T_softmax_norm: Pointer(float32), T_softmax_exp_1: Pointer(float32), T_softmax_maxelem_1: Pointer(float32), d0_1: int32, d1_1: int32, d2_1: int32, d3_1: int32, stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32) -> ()
  attr = {"target": meta[Target][0], "tir.noalias": 1, "global_symbol": "fused_nn_softmax_kernel3", "tir.device_thread_axis": [IterVar(blockIdx.x_1: int32, (nullptr), "ThreadIndex", "blockIdx.x"), IterVar(threadIdx.x_1: int32, (nullptr), "ThreadIndex", "threadIdx.x")], "calling_conv": 2} {
  attr [IterVar(blockIdx.x_1, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv(((((d0_1*d1_1)*d2_1)*d3_1) + 511), 512);
  attr [IterVar(threadIdx.x_1, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
  if (blockIdx.x_1 < floordiv((((d0_1*d1_1)*d2_1)*d3_1), 512)) {
    if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1) < d0_1) {
      if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1) < d1_1) {
        if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1) < d2_1) {
          if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3_1) < d3_1) {
            if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1) < (d0_1*d1_1)) {
              if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1) < ((d0_1*d1_1)*d2_1)) {
                T_softmax_norm[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3_1)*stride_7))] = ((float32*)T_softmax_exp_1[((blockIdx.x_1*512) + threadIdx.x_1)] / (float32*)T_softmax_maxelem_1[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1)])
              }
            }
          }
        }
      }
    }
  } else {
    if (floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1) < d0_1) {
      if (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1) < d1_1) {
        if (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1) < d2_1) {
          if (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3_1) < d3_1) {
            if (floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1) < (d0_1*d1_1)) {
              if (floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1) < ((d0_1*d1_1)*d2_1)) {
                if (((blockIdx.x_1*512) + threadIdx.x_1) < (((d0_1*d1_1)*d2_1)*d3_1)) {
                  T_softmax_norm[((((floordiv(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1)*stride_4) + (floormod(floordiv(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1), d1_1)*stride_5)) + (floormod(floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1), d2_1)*stride_6)) + (floormod(((blockIdx.x_1*512) + threadIdx.x_1), d3_1)*stride_7))] = ((float32*)T_softmax_exp_1[((blockIdx.x_1*512) + threadIdx.x_1)] / (float32*)T_softmax_maxelem_1[floordiv(((blockIdx.x_1*512) + threadIdx.x_1), d3_1)])
                }
              }
            }
          }
        }
      }
    }
  }
}

primfn(T_softmax_maxelem_2: Pointer(float32), placeholder_1: Pointer(float32), d0_2: int32, d1_2: int32, d2_2: int32, d3_2: int32, stride_8: int32, stride_9: int32, stride_10: int32, stride_11: int32) -> ()
  attr = {"target": meta[Target][0], "tir.noalias": 1, "global_symbol": "fused_nn_softmax_kernel0", "tir.device_thread_axis": [IterVar(blockIdx.x_2: int32, (nullptr), "ThreadIndex", "blockIdx.x"), IterVar(threadIdx.x_2: int32, (nullptr), "ThreadIndex", "threadIdx.x")], "calling_conv": 2} {
  attr [IterVar(blockIdx.x_2, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0_2*d1_2)*d2_2) + 511), 512);
  attr [IterVar(threadIdx.x_2, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
  if (blockIdx.x_2 < floordiv(((d0_2*d1_2)*d2_2), 512)) {
    if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d0_2) {
      if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d1_2) {
        if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < d2_2) {
          if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < (d0_2*d1_2)) {
            T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)] = -3.40282e+38f32
          }
        }
      }
    }
    for (k: int32, 0, d3_2) {
      if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d0_2) {
        if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d1_2) {
          if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < d2_2) {
            if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < (d0_2*d1_2)) {
              T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)] = max((float32*)T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)], (float32*)placeholder_1[((((floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2)*stride_8) + (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2)*stride_9)) + (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2_2)*stride_10)) + (k*stride_11))])
            }
          }
        }
      }
    }
  } else {
    if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d0_2) {
      if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d1_2) {
        if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < d2_2) {
          if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < (d0_2*d1_2)) {
            if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0_2*d1_2)*d2_2)) {
              T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)] = -3.40282e+38f32
            }
          }
        }
      }
    }
    for (k_1: int32, 0, d3_2) {
      if (floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d0_2) {
        if (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2) < d1_2) {
          if (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < d2_2) {
            if (floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2) < (d0_2*d1_2)) {
              if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0_2*d1_2)*d2_2)) {
                T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)] = max((float32*)T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)], (float32*)placeholder_1[((((floordiv(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2)*stride_8) + (floormod(floordiv(((blockIdx.x_2*512) + threadIdx.x_2), d2_2), d1_2)*stride_9)) + (floormod(((blockIdx.x_2*512) + threadIdx.x_2), d2_2)*stride_10)) + (k_1*stride_11))])
              }
            }
          }
        }
      }
    }
  }
}

primfn(T_softmax_maxelem_3: Pointer(float32), T_softmax_exp_2: Pointer(float32), d0_3: int32, d1_3: int32, d2_3: int32, d3_3: int32) -> ()
  attr = {"target": meta[Target][0], "tir.noalias": 1, "global_symbol": "fused_nn_softmax_kernel2", "tir.device_thread_axis": [IterVar(blockIdx.x_3: int32, (nullptr), "ThreadIndex", "blockIdx.x"), IterVar(threadIdx.x_3: int32, (nullptr), "ThreadIndex", "threadIdx.x")], "calling_conv": 2} {
  attr [IterVar(blockIdx.x_3, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = floordiv((((d0_3*d1_3)*d2_3) + 511), 512);
  attr [IterVar(threadIdx.x_3, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
  if (blockIdx.x_3 < floordiv(((d0_3*d1_3)*d2_3), 512)) {
    if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d0_3) {
      if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d1_3) {
        if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < d2_3) {
          if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < (d0_3*d1_3)) {
            T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] = 0f32
          }
        }
      }
    }
    for (k_2: int32, 0, d3_3) {
      if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d0_3) {
        if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d1_3) {
          if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < d2_3) {
            if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < (d0_3*d1_3)) {
              T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] = ((float32*)T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] + (float32*)T_softmax_exp_2[((((blockIdx.x_3*512) + threadIdx.x_3)*d3_3) + k_2)])
            }
          }
        }
      }
    }
  } else {
    if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d0_3) {
      if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d1_3) {
        if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < d2_3) {
          if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < (d0_3*d1_3)) {
            if (((blockIdx.x_3*512) + threadIdx.x_3) < ((d0_3*d1_3)*d2_3)) {
              T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] = 0f32
            }
          }
        }
      }
    }
    for (k_3: int32, 0, d3_3) {
      if (floordiv(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d0_3) {
        if (floormod(floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3), d1_3) < d1_3) {
          if (floormod(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < d2_3) {
            if (floordiv(((blockIdx.x_3*512) + threadIdx.x_3), d2_3) < (d0_3*d1_3)) {
              if (((blockIdx.x_3*512) + threadIdx.x_3) < ((d0_3*d1_3)*d2_3)) {
                T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] = ((float32*)T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] + (float32*)T_softmax_exp_2[((((blockIdx.x_3*512) + threadIdx.x_3)*d3_3) + k_3)])
              }
            }
          }
        }
      }
    }
  }
}


[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d3: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d1: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/arith/analyzer.cc:89: CHECK GE VAR TYPE FOR VAR d2: int32 with type tir.Var
[14:05:57] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerIntrin
primfn(T_softmax_exp: Pointer(float32), placeholder: Pointer(float32), T_softmax_maxelem: Pointer(float32), d0: int32, d1: int32, d2: int32, d3: int32, stride: int32, stride_1: int32, stride_2: int32, stride_3: int32) -> ()
  attr = {"target": meta[Target][0], "tir.noalias": 1, "global_symbol": "fused_nn_softmax_kernel1", "tir.device_thread_axis": [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x"), IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")], "calling_conv": 2} {
  attr [IterVar(blockIdx.x, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = @tir.shift_right(((((d0*d1)*d2)*d3) + 511), 9, dtype=int32);
  attr [IterVar(threadIdx.x, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
  if (blockIdx.x < @tir.shift_right((((d0*d1)*d2)*d3), 9, dtype=int32)) {
    if (let rmod: int32 = (let rmod_1: int32 = (let rmod_2: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv: int32 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_2 >= 0)) || ((d3 < 0) && (rmod_2 <= 0))), rdiv, (rdiv - 1)) % d2) in let rdiv_1: int32 = (let rmod_2 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_2 >= 0)) || ((d3 < 0) && (rmod_2 <= 0))), rdiv, (rdiv - 1)) / d2) in select((((d2 >= 0) && (rmod_1 >= 0)) || ((d2 < 0) && (rmod_1 <= 0))), rdiv_1, (rdiv_1 - 1)) % d1) in let rdiv_2: int32 = (let rmod_1 = (let rmod_2 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_2 >= 0)) || ((d3 < 0) && (rmod_2 <= 0))), rdiv, (rdiv - 1)) % d2) in let rdiv_1 = (let rmod_2 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_2 >= 0)) || ((d3 < 0) && (rmod_2 <= 0))), rdiv, (rdiv - 1)) / d2) in select((((d2 >= 0) && (rmod_1 >= 0)) || ((d2 < 0) && (rmod_1 <= 0))), rdiv_1, (rdiv_1 - 1)) / d1) in select((((d1 >= 0) && (rmod >= 0)) || ((d1 < 0) && (rmod <= 0))), rdiv_2, (rdiv_2 - 1)) < d0) {
      if (let rmod_3: int32 = (let rmod_4: int32 = (let rmod_5: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_3: int32 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_5 >= 0)) || ((d3 < 0) && (rmod_5 <= 0))), rdiv_3, (rdiv_3 - 1)) % d2) in let rdiv_4: int32 = (let rmod_5 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_3 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_5 >= 0)) || ((d3 < 0) && (rmod_5 <= 0))), rdiv_3, (rdiv_3 - 1)) / d2) in select((((d2 >= 0) && (rmod_4 >= 0)) || ((d2 < 0) && (rmod_4 <= 0))), rdiv_4, (rdiv_4 - 1)) % d1) in select((((d1 >= 0) && (rmod_3 >= 0)) || ((d1 < 0) && (rmod_3 <= 0))), rmod_3, (rmod_3 + d1)) < d1) {
        if (let rmod_6: int32 = (let rmod_7: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_5: int32 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_7 >= 0)) || ((d3 < 0) && (rmod_7 <= 0))), rdiv_5, (rdiv_5 - 1)) % d2) in select((((d2 >= 0) && (rmod_6 >= 0)) || ((d2 < 0) && (rmod_6 <= 0))), rmod_6, (rmod_6 + d2)) < d2) {
          if (let rmod_8: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in select((((d3 >= 0) && (rmod_8 >= 0)) || ((d3 < 0) && (rmod_8 <= 0))), rmod_8, (rmod_8 + d3)) < d3) {
            if (let rmod_9: int32 = (let rmod_10: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_6: int32 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_10 >= 0)) || ((d3 < 0) && (rmod_10 <= 0))), rdiv_6, (rdiv_6 - 1)) % d2) in let rdiv_7: int32 = (let rmod_10 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_6 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_10 >= 0)) || ((d3 < 0) && (rmod_10 <= 0))), rdiv_6, (rdiv_6 - 1)) / d2) in select((((d2 >= 0) && (rmod_9 >= 0)) || ((d2 < 0) && (rmod_9 <= 0))), rdiv_7, (rdiv_7 - 1)) < (d0*d1)) {
              if (let rmod_11: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_8: int32 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_11 >= 0)) || ((d3 < 0) && (rmod_11 <= 0))), rdiv_8, (rdiv_8 - 1)) < ((d0*d1)*d2)) {
                T_softmax_exp[((blockIdx.x*512) + threadIdx.x)] = @tir.call_pure_extern("__expf", ((float32*)placeholder[((((let rmod_12: int32 = (let rmod_13: int32 = (let rmod_14: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_9: int32 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_14 >= 0)) || ((d3 < 0) && (rmod_14 <= 0))), rdiv_9, (rdiv_9 - 1)) % d2) in let rdiv_10: int32 = (let rmod_14 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_9 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_14 >= 0)) || ((d3 < 0) && (rmod_14 <= 0))), rdiv_9, (rdiv_9 - 1)) / d2) in select((((d2 >= 0) && (rmod_13 >= 0)) || ((d2 < 0) && (rmod_13 <= 0))), rdiv_10, (rdiv_10 - 1)) % d1) in let rdiv_11: int32 = (let rmod_13 = (let rmod_14 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_9 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_14 >= 0)) || ((d3 < 0) && (rmod_14 <= 0))), rdiv_9, (rdiv_9 - 1)) % d2) in let rdiv_10 = (let rmod_14 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_9 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_14 >= 0)) || ((d3 < 0) && (rmod_14 <= 0))), rdiv_9, (rdiv_9 - 1)) / d2) in select((((d2 >= 0) && (rmod_13 >= 0)) || ((d2 < 0) && (rmod_13 <= 0))), rdiv_10, (rdiv_10 - 1)) / d1) in select((((d1 >= 0) && (rmod_12 >= 0)) || ((d1 < 0) && (rmod_12 <= 0))), rdiv_11, (rdiv_11 - 1))*stride) + (let rmod_15: int32 = (let rmod_16: int32 = (let rmod_17: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_12: int32 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_17 >= 0)) || ((d3 < 0) && (rmod_17 <= 0))), rdiv_12, (rdiv_12 - 1)) % d2) in let rdiv_13: int32 = (let rmod_17 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_12 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_17 >= 0)) || ((d3 < 0) && (rmod_17 <= 0))), rdiv_12, (rdiv_12 - 1)) / d2) in select((((d2 >= 0) && (rmod_16 >= 0)) || ((d2 < 0) && (rmod_16 <= 0))), rdiv_13, (rdiv_13 - 1)) % d1) in select((((d1 >= 0) && (rmod_15 >= 0)) || ((d1 < 0) && (rmod_15 <= 0))), rmod_15, (rmod_15 + d1))*stride_1)) + (let rmod_18: int32 = (let rmod_19: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_14: int32 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_19 >= 0)) || ((d3 < 0) && (rmod_19 <= 0))), rdiv_14, (rdiv_14 - 1)) % d2) in select((((d2 >= 0) && (rmod_18 >= 0)) || ((d2 < 0) && (rmod_18 <= 0))), rmod_18, (rmod_18 + d2))*stride_2)) + (let rmod_20: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in select((((d3 >= 0) && (rmod_20 >= 0)) || ((d3 < 0) && (rmod_20 <= 0))), rmod_20, (rmod_20 + d3))*stride_3))] - (float32*)T_softmax_maxelem[let rmod_21: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_15: int32 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_21 >= 0)) || ((d3 < 0) && (rmod_21 <= 0))), rdiv_15, (rdiv_15 - 1))]), dtype=float32)
              }
            }
          }
        }
      }
    }
  } else {
    if (let rmod_22: int32 = (let rmod_23: int32 = (let rmod_24: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_16: int32 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_24 >= 0)) || ((d3 < 0) && (rmod_24 <= 0))), rdiv_16, (rdiv_16 - 1)) % d2) in let rdiv_17: int32 = (let rmod_24 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_16 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_24 >= 0)) || ((d3 < 0) && (rmod_24 <= 0))), rdiv_16, (rdiv_16 - 1)) / d2) in select((((d2 >= 0) && (rmod_23 >= 0)) || ((d2 < 0) && (rmod_23 <= 0))), rdiv_17, (rdiv_17 - 1)) % d1) in let rdiv_18: int32 = (let rmod_23 = (let rmod_24 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_16 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_24 >= 0)) || ((d3 < 0) && (rmod_24 <= 0))), rdiv_16, (rdiv_16 - 1)) % d2) in let rdiv_17 = (let rmod_24 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_16 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_24 >= 0)) || ((d3 < 0) && (rmod_24 <= 0))), rdiv_16, (rdiv_16 - 1)) / d2) in select((((d2 >= 0) && (rmod_23 >= 0)) || ((d2 < 0) && (rmod_23 <= 0))), rdiv_17, (rdiv_17 - 1)) / d1) in select((((d1 >= 0) && (rmod_22 >= 0)) || ((d1 < 0) && (rmod_22 <= 0))), rdiv_18, (rdiv_18 - 1)) < d0) {
      if (let rmod_25: int32 = (let rmod_26: int32 = (let rmod_27: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_19: int32 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_27 >= 0)) || ((d3 < 0) && (rmod_27 <= 0))), rdiv_19, (rdiv_19 - 1)) % d2) in let rdiv_20: int32 = (let rmod_27 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_19 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_27 >= 0)) || ((d3 < 0) && (rmod_27 <= 0))), rdiv_19, (rdiv_19 - 1)) / d2) in select((((d2 >= 0) && (rmod_26 >= 0)) || ((d2 < 0) && (rmod_26 <= 0))), rdiv_20, (rdiv_20 - 1)) % d1) in select((((d1 >= 0) && (rmod_25 >= 0)) || ((d1 < 0) && (rmod_25 <= 0))), rmod_25, (rmod_25 + d1)) < d1) {
        if (let rmod_28: int32 = (let rmod_29: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_21: int32 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_29 >= 0)) || ((d3 < 0) && (rmod_29 <= 0))), rdiv_21, (rdiv_21 - 1)) % d2) in select((((d2 >= 0) && (rmod_28 >= 0)) || ((d2 < 0) && (rmod_28 <= 0))), rmod_28, (rmod_28 + d2)) < d2) {
          if (let rmod_30: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in select((((d3 >= 0) && (rmod_30 >= 0)) || ((d3 < 0) && (rmod_30 <= 0))), rmod_30, (rmod_30 + d3)) < d3) {
            if (let rmod_31: int32 = (let rmod_32: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_22: int32 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_32 >= 0)) || ((d3 < 0) && (rmod_32 <= 0))), rdiv_22, (rdiv_22 - 1)) % d2) in let rdiv_23: int32 = (let rmod_32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_22 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_32 >= 0)) || ((d3 < 0) && (rmod_32 <= 0))), rdiv_22, (rdiv_22 - 1)) / d2) in select((((d2 >= 0) && (rmod_31 >= 0)) || ((d2 < 0) && (rmod_31 <= 0))), rdiv_23, (rdiv_23 - 1)) < (d0*d1)) {
              if (let rmod_33: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_24: int32 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_33 >= 0)) || ((d3 < 0) && (rmod_33 <= 0))), rdiv_24, (rdiv_24 - 1)) < ((d0*d1)*d2)) {
                if (((blockIdx.x*512) + threadIdx.x) < (((d0*d1)*d2)*d3)) {
                  T_softmax_exp[((blockIdx.x*512) + threadIdx.x)] = @tir.call_pure_extern("__expf", ((float32*)placeholder[((((let rmod_34: int32 = (let rmod_35: int32 = (let rmod_36: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_25: int32 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_36 >= 0)) || ((d3 < 0) && (rmod_36 <= 0))), rdiv_25, (rdiv_25 - 1)) % d2) in let rdiv_26: int32 = (let rmod_36 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_25 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_36 >= 0)) || ((d3 < 0) && (rmod_36 <= 0))), rdiv_25, (rdiv_25 - 1)) / d2) in select((((d2 >= 0) && (rmod_35 >= 0)) || ((d2 < 0) && (rmod_35 <= 0))), rdiv_26, (rdiv_26 - 1)) % d1) in let rdiv_27: int32 = (let rmod_35 = (let rmod_36 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_25 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_36 >= 0)) || ((d3 < 0) && (rmod_36 <= 0))), rdiv_25, (rdiv_25 - 1)) % d2) in let rdiv_26 = (let rmod_36 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_25 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_36 >= 0)) || ((d3 < 0) && (rmod_36 <= 0))), rdiv_25, (rdiv_25 - 1)) / d2) in select((((d2 >= 0) && (rmod_35 >= 0)) || ((d2 < 0) && (rmod_35 <= 0))), rdiv_26, (rdiv_26 - 1)) / d1) in select((((d1 >= 0) && (rmod_34 >= 0)) || ((d1 < 0) && (rmod_34 <= 0))), rdiv_27, (rdiv_27 - 1))*stride) + (let rmod_37: int32 = (let rmod_38: int32 = (let rmod_39: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_28: int32 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_39 >= 0)) || ((d3 < 0) && (rmod_39 <= 0))), rdiv_28, (rdiv_28 - 1)) % d2) in let rdiv_29: int32 = (let rmod_39 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_28 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_39 >= 0)) || ((d3 < 0) && (rmod_39 <= 0))), rdiv_28, (rdiv_28 - 1)) / d2) in select((((d2 >= 0) && (rmod_38 >= 0)) || ((d2 < 0) && (rmod_38 <= 0))), rdiv_29, (rdiv_29 - 1)) % d1) in select((((d1 >= 0) && (rmod_37 >= 0)) || ((d1 < 0) && (rmod_37 <= 0))), rmod_37, (rmod_37 + d1))*stride_1)) + (let rmod_40: int32 = (let rmod_41: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_30: int32 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_41 >= 0)) || ((d3 < 0) && (rmod_41 <= 0))), rdiv_30, (rdiv_30 - 1)) % d2) in select((((d2 >= 0) && (rmod_40 >= 0)) || ((d2 < 0) && (rmod_40 <= 0))), rmod_40, (rmod_40 + d2))*stride_2)) + (let rmod_42: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in select((((d3 >= 0) && (rmod_42 >= 0)) || ((d3 < 0) && (rmod_42 <= 0))), rmod_42, (rmod_42 + d3))*stride_3))] - (float32*)T_softmax_maxelem[let rmod_43: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_31: int32 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_43 >= 0)) || ((d3 < 0) && (rmod_43 <= 0))), rdiv_31, (rdiv_31 - 1))]), dtype=float32)
                }
              }
            }
          }
        }
      }
    }
  }
}

primfn(T_softmax_norm: Pointer(float32), T_softmax_exp_1: Pointer(float32), T_softmax_maxelem_1: Pointer(float32), d0_1: int32, d1_1: int32, d2_1: int32, d3_1: int32, stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32) -> ()
  attr = {"target": meta[Target][0], "tir.noalias": 1, "global_symbol": "fused_nn_softmax_kernel3", "tir.device_thread_axis": [IterVar(blockIdx.x_1: int32, (nullptr), "ThreadIndex", "blockIdx.x"), IterVar(threadIdx.x_1: int32, (nullptr), "ThreadIndex", "threadIdx.x")], "calling_conv": 2} {
  attr [IterVar(blockIdx.x_1, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = @tir.shift_right(((((d0_1*d1_1)*d2_1)*d3_1) + 511), 9, dtype=int32);
  attr [IterVar(threadIdx.x_1, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
  if (blockIdx.x_1 < @tir.shift_right((((d0_1*d1_1)*d2_1)*d3_1), 9, dtype=int32)) {
    if (let rmod_44: int32 = (let rmod_45: int32 = (let rmod_46: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_32: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_46 >= 0)) || ((d3_1 < 0) && (rmod_46 <= 0))), rdiv_32, (rdiv_32 - 1)) % d2_1) in let rdiv_33: int32 = (let rmod_46 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_46 >= 0)) || ((d3_1 < 0) && (rmod_46 <= 0))), rdiv_32, (rdiv_32 - 1)) / d2_1) in select((((d2_1 >= 0) && (rmod_45 >= 0)) || ((d2_1 < 0) && (rmod_45 <= 0))), rdiv_33, (rdiv_33 - 1)) % d1_1) in let rdiv_34: int32 = (let rmod_45 = (let rmod_46 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_46 >= 0)) || ((d3_1 < 0) && (rmod_46 <= 0))), rdiv_32, (rdiv_32 - 1)) % d2_1) in let rdiv_33 = (let rmod_46 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_46 >= 0)) || ((d3_1 < 0) && (rmod_46 <= 0))), rdiv_32, (rdiv_32 - 1)) / d2_1) in select((((d2_1 >= 0) && (rmod_45 >= 0)) || ((d2_1 < 0) && (rmod_45 <= 0))), rdiv_33, (rdiv_33 - 1)) / d1_1) in select((((d1_1 >= 0) && (rmod_44 >= 0)) || ((d1_1 < 0) && (rmod_44 <= 0))), rdiv_34, (rdiv_34 - 1)) < d0_1) {
      if (let rmod_47: int32 = (let rmod_48: int32 = (let rmod_49: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_35: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_49 >= 0)) || ((d3_1 < 0) && (rmod_49 <= 0))), rdiv_35, (rdiv_35 - 1)) % d2_1) in let rdiv_36: int32 = (let rmod_49 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_35 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_49 >= 0)) || ((d3_1 < 0) && (rmod_49 <= 0))), rdiv_35, (rdiv_35 - 1)) / d2_1) in select((((d2_1 >= 0) && (rmod_48 >= 0)) || ((d2_1 < 0) && (rmod_48 <= 0))), rdiv_36, (rdiv_36 - 1)) % d1_1) in select((((d1_1 >= 0) && (rmod_47 >= 0)) || ((d1_1 < 0) && (rmod_47 <= 0))), rmod_47, (rmod_47 + d1_1)) < d1_1) {
        if (let rmod_50: int32 = (let rmod_51: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_37: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_51 >= 0)) || ((d3_1 < 0) && (rmod_51 <= 0))), rdiv_37, (rdiv_37 - 1)) % d2_1) in select((((d2_1 >= 0) && (rmod_50 >= 0)) || ((d2_1 < 0) && (rmod_50 <= 0))), rmod_50, (rmod_50 + d2_1)) < d2_1) {
          if (let rmod_52: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in select((((d3_1 >= 0) && (rmod_52 >= 0)) || ((d3_1 < 0) && (rmod_52 <= 0))), rmod_52, (rmod_52 + d3_1)) < d3_1) {
            if (let rmod_53: int32 = (let rmod_54: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_38: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_54 >= 0)) || ((d3_1 < 0) && (rmod_54 <= 0))), rdiv_38, (rdiv_38 - 1)) % d2_1) in let rdiv_39: int32 = (let rmod_54 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_38 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_54 >= 0)) || ((d3_1 < 0) && (rmod_54 <= 0))), rdiv_38, (rdiv_38 - 1)) / d2_1) in select((((d2_1 >= 0) && (rmod_53 >= 0)) || ((d2_1 < 0) && (rmod_53 <= 0))), rdiv_39, (rdiv_39 - 1)) < (d0_1*d1_1)) {
              if (let rmod_55: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_40: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_55 >= 0)) || ((d3_1 < 0) && (rmod_55 <= 0))), rdiv_40, (rdiv_40 - 1)) < ((d0_1*d1_1)*d2_1)) {
                T_softmax_norm[((((let rmod_56: int32 = (let rmod_57: int32 = (let rmod_58: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_41: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_58 >= 0)) || ((d3_1 < 0) && (rmod_58 <= 0))), rdiv_41, (rdiv_41 - 1)) % d2_1) in let rdiv_42: int32 = (let rmod_58 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_41 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_58 >= 0)) || ((d3_1 < 0) && (rmod_58 <= 0))), rdiv_41, (rdiv_41 - 1)) / d2_1) in select((((d2_1 >= 0) && (rmod_57 >= 0)) || ((d2_1 < 0) && (rmod_57 <= 0))), rdiv_42, (rdiv_42 - 1)) % d1_1) in let rdiv_43: int32 = (let rmod_57 = (let rmod_58 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_41 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_58 >= 0)) || ((d3_1 < 0) && (rmod_58 <= 0))), rdiv_41, (rdiv_41 - 1)) % d2_1) in let rdiv_42 = (let rmod_58 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_41 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_58 >= 0)) || ((d3_1 < 0) && (rmod_58 <= 0))), rdiv_41, (rdiv_41 - 1)) / d2_1) in select((((d2_1 >= 0) && (rmod_57 >= 0)) || ((d2_1 < 0) && (rmod_57 <= 0))), rdiv_42, (rdiv_42 - 1)) / d1_1) in select((((d1_1 >= 0) && (rmod_56 >= 0)) || ((d1_1 < 0) && (rmod_56 <= 0))), rdiv_43, (rdiv_43 - 1))*stride_4) + (let rmod_59: int32 = (let rmod_60: int32 = (let rmod_61: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_44: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_61 >= 0)) || ((d3_1 < 0) && (rmod_61 <= 0))), rdiv_44, (rdiv_44 - 1)) % d2_1) in let rdiv_45: int32 = (let rmod_61 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_44 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_61 >= 0)) || ((d3_1 < 0) && (rmod_61 <= 0))), rdiv_44, (rdiv_44 - 1)) / d2_1) in select((((d2_1 >= 0) && (rmod_60 >= 0)) || ((d2_1 < 0) && (rmod_60 <= 0))), rdiv_45, (rdiv_45 - 1)) % d1_1) in select((((d1_1 >= 0) && (rmod_59 >= 0)) || ((d1_1 < 0) && (rmod_59 <= 0))), rmod_59, (rmod_59 + d1_1))*stride_5)) + (let rmod_62: int32 = (let rmod_63: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_46: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_63 >= 0)) || ((d3_1 < 0) && (rmod_63 <= 0))), rdiv_46, (rdiv_46 - 1)) % d2_1) in select((((d2_1 >= 0) && (rmod_62 >= 0)) || ((d2_1 < 0) && (rmod_62 <= 0))), rmod_62, (rmod_62 + d2_1))*stride_6)) + (let rmod_64: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in select((((d3_1 >= 0) && (rmod_64 >= 0)) || ((d3_1 < 0) && (rmod_64 <= 0))), rmod_64, (rmod_64 + d3_1))*stride_7))] = ((float32*)T_softmax_exp_1[((blockIdx.x_1*512) + threadIdx.x_1)] / (float32*)T_softmax_maxelem_1[let rmod_65: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_47: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_65 >= 0)) || ((d3_1 < 0) && (rmod_65 <= 0))), rdiv_47, (rdiv_47 - 1))])
              }
            }
          }
        }
      }
    }
  } else {
    if (let rmod_66: int32 = (let rmod_67: int32 = (let rmod_68: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_48: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_68 >= 0)) || ((d3_1 < 0) && (rmod_68 <= 0))), rdiv_48, (rdiv_48 - 1)) % d2_1) in let rdiv_49: int32 = (let rmod_68 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_48 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_68 >= 0)) || ((d3_1 < 0) && (rmod_68 <= 0))), rdiv_48, (rdiv_48 - 1)) / d2_1) in select((((d2_1 >= 0) && (rmod_67 >= 0)) || ((d2_1 < 0) && (rmod_67 <= 0))), rdiv_49, (rdiv_49 - 1)) % d1_1) in let rdiv_50: int32 = (let rmod_67 = (let rmod_68 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_48 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_68 >= 0)) || ((d3_1 < 0) && (rmod_68 <= 0))), rdiv_48, (rdiv_48 - 1)) % d2_1) in let rdiv_49 = (let rmod_68 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_48 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_68 >= 0)) || ((d3_1 < 0) && (rmod_68 <= 0))), rdiv_48, (rdiv_48 - 1)) / d2_1) in select((((d2_1 >= 0) && (rmod_67 >= 0)) || ((d2_1 < 0) && (rmod_67 <= 0))), rdiv_49, (rdiv_49 - 1)) / d1_1) in select((((d1_1 >= 0) && (rmod_66 >= 0)) || ((d1_1 < 0) && (rmod_66 <= 0))), rdiv_50, (rdiv_50 - 1)) < d0_1) {
      if (let rmod_69: int32 = (let rmod_70: int32 = (let rmod_71: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_51: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_71 >= 0)) || ((d3_1 < 0) && (rmod_71 <= 0))), rdiv_51, (rdiv_51 - 1)) % d2_1) in let rdiv_52: int32 = (let rmod_71 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_51 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_71 >= 0)) || ((d3_1 < 0) && (rmod_71 <= 0))), rdiv_51, (rdiv_51 - 1)) / d2_1) in select((((d2_1 >= 0) && (rmod_70 >= 0)) || ((d2_1 < 0) && (rmod_70 <= 0))), rdiv_52, (rdiv_52 - 1)) % d1_1) in select((((d1_1 >= 0) && (rmod_69 >= 0)) || ((d1_1 < 0) && (rmod_69 <= 0))), rmod_69, (rmod_69 + d1_1)) < d1_1) {
        if (let rmod_72: int32 = (let rmod_73: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_53: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_73 >= 0)) || ((d3_1 < 0) && (rmod_73 <= 0))), rdiv_53, (rdiv_53 - 1)) % d2_1) in select((((d2_1 >= 0) && (rmod_72 >= 0)) || ((d2_1 < 0) && (rmod_72 <= 0))), rmod_72, (rmod_72 + d2_1)) < d2_1) {
          if (let rmod_74: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in select((((d3_1 >= 0) && (rmod_74 >= 0)) || ((d3_1 < 0) && (rmod_74 <= 0))), rmod_74, (rmod_74 + d3_1)) < d3_1) {
            if (let rmod_75: int32 = (let rmod_76: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_54: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_76 >= 0)) || ((d3_1 < 0) && (rmod_76 <= 0))), rdiv_54, (rdiv_54 - 1)) % d2_1) in let rdiv_55: int32 = (let rmod_76 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_54 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_76 >= 0)) || ((d3_1 < 0) && (rmod_76 <= 0))), rdiv_54, (rdiv_54 - 1)) / d2_1) in select((((d2_1 >= 0) && (rmod_75 >= 0)) || ((d2_1 < 0) && (rmod_75 <= 0))), rdiv_55, (rdiv_55 - 1)) < (d0_1*d1_1)) {
              if (let rmod_77: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_56: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_77 >= 0)) || ((d3_1 < 0) && (rmod_77 <= 0))), rdiv_56, (rdiv_56 - 1)) < ((d0_1*d1_1)*d2_1)) {
                if (((blockIdx.x_1*512) + threadIdx.x_1) < (((d0_1*d1_1)*d2_1)*d3_1)) {
                  T_softmax_norm[((((let rmod_78: int32 = (let rmod_79: int32 = (let rmod_80: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_57: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_80 >= 0)) || ((d3_1 < 0) && (rmod_80 <= 0))), rdiv_57, (rdiv_57 - 1)) % d2_1) in let rdiv_58: int32 = (let rmod_80 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_57 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_80 >= 0)) || ((d3_1 < 0) && (rmod_80 <= 0))), rdiv_57, (rdiv_57 - 1)) / d2_1) in select((((d2_1 >= 0) && (rmod_79 >= 0)) || ((d2_1 < 0) && (rmod_79 <= 0))), rdiv_58, (rdiv_58 - 1)) % d1_1) in let rdiv_59: int32 = (let rmod_79 = (let rmod_80 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_57 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_80 >= 0)) || ((d3_1 < 0) && (rmod_80 <= 0))), rdiv_57, (rdiv_57 - 1)) % d2_1) in let rdiv_58 = (let rmod_80 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_57 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_80 >= 0)) || ((d3_1 < 0) && (rmod_80 <= 0))), rdiv_57, (rdiv_57 - 1)) / d2_1) in select((((d2_1 >= 0) && (rmod_79 >= 0)) || ((d2_1 < 0) && (rmod_79 <= 0))), rdiv_58, (rdiv_58 - 1)) / d1_1) in select((((d1_1 >= 0) && (rmod_78 >= 0)) || ((d1_1 < 0) && (rmod_78 <= 0))), rdiv_59, (rdiv_59 - 1))*stride_4) + (let rmod_81: int32 = (let rmod_82: int32 = (let rmod_83: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_60: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_83 >= 0)) || ((d3_1 < 0) && (rmod_83 <= 0))), rdiv_60, (rdiv_60 - 1)) % d2_1) in let rdiv_61: int32 = (let rmod_83 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_60 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_83 >= 0)) || ((d3_1 < 0) && (rmod_83 <= 0))), rdiv_60, (rdiv_60 - 1)) / d2_1) in select((((d2_1 >= 0) && (rmod_82 >= 0)) || ((d2_1 < 0) && (rmod_82 <= 0))), rdiv_61, (rdiv_61 - 1)) % d1_1) in select((((d1_1 >= 0) && (rmod_81 >= 0)) || ((d1_1 < 0) && (rmod_81 <= 0))), rmod_81, (rmod_81 + d1_1))*stride_5)) + (let rmod_84: int32 = (let rmod_85: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_62: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_85 >= 0)) || ((d3_1 < 0) && (rmod_85 <= 0))), rdiv_62, (rdiv_62 - 1)) % d2_1) in select((((d2_1 >= 0) && (rmod_84 >= 0)) || ((d2_1 < 0) && (rmod_84 <= 0))), rmod_84, (rmod_84 + d2_1))*stride_6)) + (let rmod_86: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in select((((d3_1 >= 0) && (rmod_86 >= 0)) || ((d3_1 < 0) && (rmod_86 <= 0))), rmod_86, (rmod_86 + d3_1))*stride_7))] = ((float32*)T_softmax_exp_1[((blockIdx.x_1*512) + threadIdx.x_1)] / (float32*)T_softmax_maxelem_1[let rmod_87: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_63: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_87 >= 0)) || ((d3_1 < 0) && (rmod_87 <= 0))), rdiv_63, (rdiv_63 - 1))])
                }
              }
            }
          }
        }
      }
    }
  }
}

primfn(T_softmax_maxelem_2: Pointer(float32), placeholder_1: Pointer(float32), d0_2: int32, d1_2: int32, d2_2: int32, d3_2: int32, stride_8: int32, stride_9: int32, stride_10: int32, stride_11: int32) -> ()
  attr = {"target": meta[Target][0], "tir.noalias": 1, "global_symbol": "fused_nn_softmax_kernel0", "tir.device_thread_axis": [IterVar(blockIdx.x_2: int32, (nullptr), "ThreadIndex", "blockIdx.x"), IterVar(threadIdx.x_2: int32, (nullptr), "ThreadIndex", "threadIdx.x")], "calling_conv": 2} {
  attr [IterVar(blockIdx.x_2, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = @tir.shift_right((((d0_2*d1_2)*d2_2) + 511), 9, dtype=int32);
  attr [IterVar(threadIdx.x_2, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
  if (blockIdx.x_2 < @tir.shift_right(((d0_2*d1_2)*d2_2), 9, dtype=int32)) {
    if (let rmod_88: int32 = (let rmod_89: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_64: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_89 >= 0)) || ((d2_2 < 0) && (rmod_89 <= 0))), rdiv_64, (rdiv_64 - 1)) % d1_2) in let rdiv_65: int32 = (let rmod_89 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_64 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_89 >= 0)) || ((d2_2 < 0) && (rmod_89 <= 0))), rdiv_64, (rdiv_64 - 1)) / d1_2) in select((((d1_2 >= 0) && (rmod_88 >= 0)) || ((d1_2 < 0) && (rmod_88 <= 0))), rdiv_65, (rdiv_65 - 1)) < d0_2) {
      if (let rmod_90: int32 = (let rmod_91: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_66: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_91 >= 0)) || ((d2_2 < 0) && (rmod_91 <= 0))), rdiv_66, (rdiv_66 - 1)) % d1_2) in select((((d1_2 >= 0) && (rmod_90 >= 0)) || ((d1_2 < 0) && (rmod_90 <= 0))), rmod_90, (rmod_90 + d1_2)) < d1_2) {
        if (let rmod_92: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in select((((d2_2 >= 0) && (rmod_92 >= 0)) || ((d2_2 < 0) && (rmod_92 <= 0))), rmod_92, (rmod_92 + d2_2)) < d2_2) {
          if (let rmod_93: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_67: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_93 >= 0)) || ((d2_2 < 0) && (rmod_93 <= 0))), rdiv_67, (rdiv_67 - 1)) < (d0_2*d1_2)) {
            T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)] = -3.40282e+38f32
          }
        }
      }
    }
    for (k: int32, 0, d3_2) {
      if (let rmod_94: int32 = (let rmod_95: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_68: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_95 >= 0)) || ((d2_2 < 0) && (rmod_95 <= 0))), rdiv_68, (rdiv_68 - 1)) % d1_2) in let rdiv_69: int32 = (let rmod_95 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_68 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_95 >= 0)) || ((d2_2 < 0) && (rmod_95 <= 0))), rdiv_68, (rdiv_68 - 1)) / d1_2) in select((((d1_2 >= 0) && (rmod_94 >= 0)) || ((d1_2 < 0) && (rmod_94 <= 0))), rdiv_69, (rdiv_69 - 1)) < d0_2) {
        if (let rmod_96: int32 = (let rmod_97: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_70: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_97 >= 0)) || ((d2_2 < 0) && (rmod_97 <= 0))), rdiv_70, (rdiv_70 - 1)) % d1_2) in select((((d1_2 >= 0) && (rmod_96 >= 0)) || ((d1_2 < 0) && (rmod_96 <= 0))), rmod_96, (rmod_96 + d1_2)) < d1_2) {
          if (let rmod_98: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in select((((d2_2 >= 0) && (rmod_98 >= 0)) || ((d2_2 < 0) && (rmod_98 <= 0))), rmod_98, (rmod_98 + d2_2)) < d2_2) {
            if (let rmod_99: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_71: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_99 >= 0)) || ((d2_2 < 0) && (rmod_99 <= 0))), rdiv_71, (rdiv_71 - 1)) < (d0_2*d1_2)) {
              T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)] = max((float32*)T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)], (float32*)placeholder_1[((((let rmod_100: int32 = (let rmod_101: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_72: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_101 >= 0)) || ((d2_2 < 0) && (rmod_101 <= 0))), rdiv_72, (rdiv_72 - 1)) % d1_2) in let rdiv_73: int32 = (let rmod_101 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_72 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_101 >= 0)) || ((d2_2 < 0) && (rmod_101 <= 0))), rdiv_72, (rdiv_72 - 1)) / d1_2) in select((((d1_2 >= 0) && (rmod_100 >= 0)) || ((d1_2 < 0) && (rmod_100 <= 0))), rdiv_73, (rdiv_73 - 1))*stride_8) + (let rmod_102: int32 = (let rmod_103: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_74: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_103 >= 0)) || ((d2_2 < 0) && (rmod_103 <= 0))), rdiv_74, (rdiv_74 - 1)) % d1_2) in select((((d1_2 >= 0) && (rmod_102 >= 0)) || ((d1_2 < 0) && (rmod_102 <= 0))), rmod_102, (rmod_102 + d1_2))*stride_9)) + (let rmod_104: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in select((((d2_2 >= 0) && (rmod_104 >= 0)) || ((d2_2 < 0) && (rmod_104 <= 0))), rmod_104, (rmod_104 + d2_2))*stride_10)) + (k*stride_11))])
            }
          }
        }
      }
    }
  } else {
    if (let rmod_105: int32 = (let rmod_106: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_75: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_106 >= 0)) || ((d2_2 < 0) && (rmod_106 <= 0))), rdiv_75, (rdiv_75 - 1)) % d1_2) in let rdiv_76: int32 = (let rmod_106 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_75 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_106 >= 0)) || ((d2_2 < 0) && (rmod_106 <= 0))), rdiv_75, (rdiv_75 - 1)) / d1_2) in select((((d1_2 >= 0) && (rmod_105 >= 0)) || ((d1_2 < 0) && (rmod_105 <= 0))), rdiv_76, (rdiv_76 - 1)) < d0_2) {
      if (let rmod_107: int32 = (let rmod_108: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_77: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_108 >= 0)) || ((d2_2 < 0) && (rmod_108 <= 0))), rdiv_77, (rdiv_77 - 1)) % d1_2) in select((((d1_2 >= 0) && (rmod_107 >= 0)) || ((d1_2 < 0) && (rmod_107 <= 0))), rmod_107, (rmod_107 + d1_2)) < d1_2) {
        if (let rmod_109: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in select((((d2_2 >= 0) && (rmod_109 >= 0)) || ((d2_2 < 0) && (rmod_109 <= 0))), rmod_109, (rmod_109 + d2_2)) < d2_2) {
          if (let rmod_110: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_78: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_110 >= 0)) || ((d2_2 < 0) && (rmod_110 <= 0))), rdiv_78, (rdiv_78 - 1)) < (d0_2*d1_2)) {
            if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0_2*d1_2)*d2_2)) {
              T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)] = -3.40282e+38f32
            }
          }
        }
      }
    }
    for (k_1: int32, 0, d3_2) {
      if (let rmod_111: int32 = (let rmod_112: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_79: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_112 >= 0)) || ((d2_2 < 0) && (rmod_112 <= 0))), rdiv_79, (rdiv_79 - 1)) % d1_2) in let rdiv_80: int32 = (let rmod_112 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_79 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_112 >= 0)) || ((d2_2 < 0) && (rmod_112 <= 0))), rdiv_79, (rdiv_79 - 1)) / d1_2) in select((((d1_2 >= 0) && (rmod_111 >= 0)) || ((d1_2 < 0) && (rmod_111 <= 0))), rdiv_80, (rdiv_80 - 1)) < d0_2) {
        if (let rmod_113: int32 = (let rmod_114: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_81: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_114 >= 0)) || ((d2_2 < 0) && (rmod_114 <= 0))), rdiv_81, (rdiv_81 - 1)) % d1_2) in select((((d1_2 >= 0) && (rmod_113 >= 0)) || ((d1_2 < 0) && (rmod_113 <= 0))), rmod_113, (rmod_113 + d1_2)) < d1_2) {
          if (let rmod_115: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in select((((d2_2 >= 0) && (rmod_115 >= 0)) || ((d2_2 < 0) && (rmod_115 <= 0))), rmod_115, (rmod_115 + d2_2)) < d2_2) {
            if (let rmod_116: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_82: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_116 >= 0)) || ((d2_2 < 0) && (rmod_116 <= 0))), rdiv_82, (rdiv_82 - 1)) < (d0_2*d1_2)) {
              if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0_2*d1_2)*d2_2)) {
                T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)] = max((float32*)T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)], (float32*)placeholder_1[((((let rmod_117: int32 = (let rmod_118: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_83: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_118 >= 0)) || ((d2_2 < 0) && (rmod_118 <= 0))), rdiv_83, (rdiv_83 - 1)) % d1_2) in let rdiv_84: int32 = (let rmod_118 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_83 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_118 >= 0)) || ((d2_2 < 0) && (rmod_118 <= 0))), rdiv_83, (rdiv_83 - 1)) / d1_2) in select((((d1_2 >= 0) && (rmod_117 >= 0)) || ((d1_2 < 0) && (rmod_117 <= 0))), rdiv_84, (rdiv_84 - 1))*stride_8) + (let rmod_119: int32 = (let rmod_120: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_85: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_120 >= 0)) || ((d2_2 < 0) && (rmod_120 <= 0))), rdiv_85, (rdiv_85 - 1)) % d1_2) in select((((d1_2 >= 0) && (rmod_119 >= 0)) || ((d1_2 < 0) && (rmod_119 <= 0))), rmod_119, (rmod_119 + d1_2))*stride_9)) + (let rmod_121: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in select((((d2_2 >= 0) && (rmod_121 >= 0)) || ((d2_2 < 0) && (rmod_121 <= 0))), rmod_121, (rmod_121 + d2_2))*stride_10)) + (k_1*stride_11))])
              }
            }
          }
        }
      }
    }
  }
}

primfn(T_softmax_maxelem_3: Pointer(float32), T_softmax_exp_2: Pointer(float32), d0_3: int32, d1_3: int32, d2_3: int32, d3_3: int32) -> ()
  attr = {"target": meta[Target][0], "tir.noalias": 1, "global_symbol": "fused_nn_softmax_kernel2", "tir.device_thread_axis": [IterVar(blockIdx.x_3: int32, (nullptr), "ThreadIndex", "blockIdx.x"), IterVar(threadIdx.x_3: int32, (nullptr), "ThreadIndex", "threadIdx.x")], "calling_conv": 2} {
  attr [IterVar(blockIdx.x_3, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = @tir.shift_right((((d0_3*d1_3)*d2_3) + 511), 9, dtype=int32);
  attr [IterVar(threadIdx.x_3, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
  if (blockIdx.x_3 < @tir.shift_right(((d0_3*d1_3)*d2_3), 9, dtype=int32)) {
    if (let rmod_122: int32 = (let rmod_123: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in let rdiv_86: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) / d2_3) in select((((d2_3 >= 0) && (rmod_123 >= 0)) || ((d2_3 < 0) && (rmod_123 <= 0))), rdiv_86, (rdiv_86 - 1)) % d1_3) in let rdiv_87: int32 = (let rmod_123 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in let rdiv_86 = (((blockIdx.x_3*512) + threadIdx.x_3) / d2_3) in select((((d2_3 >= 0) && (rmod_123 >= 0)) || ((d2_3 < 0) && (rmod_123 <= 0))), rdiv_86, (rdiv_86 - 1)) / d1_3) in select((((d1_3 >= 0) && (rmod_122 >= 0)) || ((d1_3 < 0) && (rmod_122 <= 0))), rdiv_87, (rdiv_87 - 1)) < d0_3) {
      if (let rmod_124: int32 = (let rmod_125: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in let rdiv_88: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) / d2_3) in select((((d2_3 >= 0) && (rmod_125 >= 0)) || ((d2_3 < 0) && (rmod_125 <= 0))), rdiv_88, (rdiv_88 - 1)) % d1_3) in select((((d1_3 >= 0) && (rmod_124 >= 0)) || ((d1_3 < 0) && (rmod_124 <= 0))), rmod_124, (rmod_124 + d1_3)) < d1_3) {
        if (let rmod_126: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in select((((d2_3 >= 0) && (rmod_126 >= 0)) || ((d2_3 < 0) && (rmod_126 <= 0))), rmod_126, (rmod_126 + d2_3)) < d2_3) {
          if (let rmod_127: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in let rdiv_89: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) / d2_3) in select((((d2_3 >= 0) && (rmod_127 >= 0)) || ((d2_3 < 0) && (rmod_127 <= 0))), rdiv_89, (rdiv_89 - 1)) < (d0_3*d1_3)) {
            T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] = 0f32
          }
        }
      }
    }
    for (k_2: int32, 0, d3_3) {
      if (let rmod_128: int32 = (let rmod_129: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in let rdiv_90: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) / d2_3) in select((((d2_3 >= 0) && (rmod_129 >= 0)) || ((d2_3 < 0) && (rmod_129 <= 0))), rdiv_90, (rdiv_90 - 1)) % d1_3) in let rdiv_91: int32 = (let rmod_129 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in let rdiv_90 = (((blockIdx.x_3*512) + threadIdx.x_3) / d2_3) in select((((d2_3 >= 0) && (rmod_129 >= 0)) || ((d2_3 < 0) && (rmod_129 <= 0))), rdiv_90, (rdiv_90 - 1)) / d1_3) in select((((d1_3 >= 0) && (rmod_128 >= 0)) || ((d1_3 < 0) && (rmod_128 <= 0))), rdiv_91, (rdiv_91 - 1)) < d0_3) {
        if (let rmod_130: int32 = (let rmod_131: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in let rdiv_92: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) / d2_3) in select((((d2_3 >= 0) && (rmod_131 >= 0)) || ((d2_3 < 0) && (rmod_131 <= 0))), rdiv_92, (rdiv_92 - 1)) % d1_3) in select((((d1_3 >= 0) && (rmod_130 >= 0)) || ((d1_3 < 0) && (rmod_130 <= 0))), rmod_130, (rmod_130 + d1_3)) < d1_3) {
          if (let rmod_132: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in select((((d2_3 >= 0) && (rmod_132 >= 0)) || ((d2_3 < 0) && (rmod_132 <= 0))), rmod_132, (rmod_132 + d2_3)) < d2_3) {
            if (let rmod_133: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in let rdiv_93: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) / d2_3) in select((((d2_3 >= 0) && (rmod_133 >= 0)) || ((d2_3 < 0) && (rmod_133 <= 0))), rdiv_93, (rdiv_93 - 1)) < (d0_3*d1_3)) {
              T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] = ((float32*)T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] + (float32*)T_softmax_exp_2[((((blockIdx.x_3*512) + threadIdx.x_3)*d3_3) + k_2)])
            }
          }
        }
      }
    }
  } else {
    if (let rmod_134: int32 = (let rmod_135: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in let rdiv_94: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) / d2_3) in select((((d2_3 >= 0) && (rmod_135 >= 0)) || ((d2_3 < 0) && (rmod_135 <= 0))), rdiv_94, (rdiv_94 - 1)) % d1_3) in let rdiv_95: int32 = (let rmod_135 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in let rdiv_94 = (((blockIdx.x_3*512) + threadIdx.x_3) / d2_3) in select((((d2_3 >= 0) && (rmod_135 >= 0)) || ((d2_3 < 0) && (rmod_135 <= 0))), rdiv_94, (rdiv_94 - 1)) / d1_3) in select((((d1_3 >= 0) && (rmod_134 >= 0)) || ((d1_3 < 0) && (rmod_134 <= 0))), rdiv_95, (rdiv_95 - 1)) < d0_3) {
      if (let rmod_136: int32 = (let rmod_137: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in let rdiv_96: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) / d2_3) in select((((d2_3 >= 0) && (rmod_137 >= 0)) || ((d2_3 < 0) && (rmod_137 <= 0))), rdiv_96, (rdiv_96 - 1)) % d1_3) in select((((d1_3 >= 0) && (rmod_136 >= 0)) || ((d1_3 < 0) && (rmod_136 <= 0))), rmod_136, (rmod_136 + d1_3)) < d1_3) {
        if (let rmod_138: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in select((((d2_3 >= 0) && (rmod_138 >= 0)) || ((d2_3 < 0) && (rmod_138 <= 0))), rmod_138, (rmod_138 + d2_3)) < d2_3) {
          if (let rmod_139: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in let rdiv_97: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) / d2_3) in select((((d2_3 >= 0) && (rmod_139 >= 0)) || ((d2_3 < 0) && (rmod_139 <= 0))), rdiv_97, (rdiv_97 - 1)) < (d0_3*d1_3)) {
            if (((blockIdx.x_3*512) + threadIdx.x_3) < ((d0_3*d1_3)*d2_3)) {
              T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] = 0f32
            }
          }
        }
      }
    }
    for (k_3: int32, 0, d3_3) {
      if (let rmod_140: int32 = (let rmod_141: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in let rdiv_98: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) / d2_3) in select((((d2_3 >= 0) && (rmod_141 >= 0)) || ((d2_3 < 0) && (rmod_141 <= 0))), rdiv_98, (rdiv_98 - 1)) % d1_3) in let rdiv_99: int32 = (let rmod_141 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in let rdiv_98 = (((blockIdx.x_3*512) + threadIdx.x_3) / d2_3) in select((((d2_3 >= 0) && (rmod_141 >= 0)) || ((d2_3 < 0) && (rmod_141 <= 0))), rdiv_98, (rdiv_98 - 1)) / d1_3) in select((((d1_3 >= 0) && (rmod_140 >= 0)) || ((d1_3 < 0) && (rmod_140 <= 0))), rdiv_99, (rdiv_99 - 1)) < d0_3) {
        if (let rmod_142: int32 = (let rmod_143: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in let rdiv_100: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) / d2_3) in select((((d2_3 >= 0) && (rmod_143 >= 0)) || ((d2_3 < 0) && (rmod_143 <= 0))), rdiv_100, (rdiv_100 - 1)) % d1_3) in select((((d1_3 >= 0) && (rmod_142 >= 0)) || ((d1_3 < 0) && (rmod_142 <= 0))), rmod_142, (rmod_142 + d1_3)) < d1_3) {
          if (let rmod_144: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in select((((d2_3 >= 0) && (rmod_144 >= 0)) || ((d2_3 < 0) && (rmod_144 <= 0))), rmod_144, (rmod_144 + d2_3)) < d2_3) {
            if (let rmod_145: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in let rdiv_101: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) / d2_3) in select((((d2_3 >= 0) && (rmod_145 >= 0)) || ((d2_3 < 0) && (rmod_145 <= 0))), rdiv_101, (rdiv_101 - 1)) < (d0_3*d1_3)) {
              if (((blockIdx.x_3*512) + threadIdx.x_3) < ((d0_3*d1_3)*d2_3)) {
                T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] = ((float32*)T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] + (float32*)T_softmax_exp_2[((((blockIdx.x_3*512) + threadIdx.x_3)*d3_3) + k_3)])
              }
            }
          }
        }
      }
    }
  }
}


[14:05:57] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerDeviceStorageAccessInfo
primfn(T_softmax_exp: Pointer(float32), placeholder: Pointer(float32), T_softmax_maxelem: Pointer(float32), d0: int32, d1: int32, d2: int32, d3: int32, stride: int32, stride_1: int32, stride_2: int32, stride_3: int32) -> ()
  attr = {"target": meta[Target][0], "tir.noalias": 1, "global_symbol": "fused_nn_softmax_kernel1", "tir.device_thread_axis": [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x"), IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")], "calling_conv": 2} {
  attr [IterVar(blockIdx.x, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = @tir.shift_right(((((d0*d1)*d2)*d3) + 511), 9, dtype=int32);
  attr [IterVar(threadIdx.x, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
  if (blockIdx.x < @tir.shift_right((((d0*d1)*d2)*d3), 9, dtype=int32)) {
    if (let rmod: int32 = (let rmod_1: int32 = (let rmod_2: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv: int32 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_2 >= 0)) || ((d3 < 0) && (rmod_2 <= 0))), rdiv, (rdiv - 1)) % d2) in let rdiv_1: int32 = (let rmod_2 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_2 >= 0)) || ((d3 < 0) && (rmod_2 <= 0))), rdiv, (rdiv - 1)) / d2) in select((((d2 >= 0) && (rmod_1 >= 0)) || ((d2 < 0) && (rmod_1 <= 0))), rdiv_1, (rdiv_1 - 1)) % d1) in let rdiv_2: int32 = (let rmod_1 = (let rmod_2 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_2 >= 0)) || ((d3 < 0) && (rmod_2 <= 0))), rdiv, (rdiv - 1)) % d2) in let rdiv_1 = (let rmod_2 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_2 >= 0)) || ((d3 < 0) && (rmod_2 <= 0))), rdiv, (rdiv - 1)) / d2) in select((((d2 >= 0) && (rmod_1 >= 0)) || ((d2 < 0) && (rmod_1 <= 0))), rdiv_1, (rdiv_1 - 1)) / d1) in select((((d1 >= 0) && (rmod >= 0)) || ((d1 < 0) && (rmod <= 0))), rdiv_2, (rdiv_2 - 1)) < d0) {
      if (let rmod_3: int32 = (let rmod_4: int32 = (let rmod_5: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_3: int32 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_5 >= 0)) || ((d3 < 0) && (rmod_5 <= 0))), rdiv_3, (rdiv_3 - 1)) % d2) in let rdiv_4: int32 = (let rmod_5 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_3 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_5 >= 0)) || ((d3 < 0) && (rmod_5 <= 0))), rdiv_3, (rdiv_3 - 1)) / d2) in select((((d2 >= 0) && (rmod_4 >= 0)) || ((d2 < 0) && (rmod_4 <= 0))), rdiv_4, (rdiv_4 - 1)) % d1) in select((((d1 >= 0) && (rmod_3 >= 0)) || ((d1 < 0) && (rmod_3 <= 0))), rmod_3, (rmod_3 + d1)) < d1) {
        if (let rmod_6: int32 = (let rmod_7: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_5: int32 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_7 >= 0)) || ((d3 < 0) && (rmod_7 <= 0))), rdiv_5, (rdiv_5 - 1)) % d2) in select((((d2 >= 0) && (rmod_6 >= 0)) || ((d2 < 0) && (rmod_6 <= 0))), rmod_6, (rmod_6 + d2)) < d2) {
          if (let rmod_8: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in select((((d3 >= 0) && (rmod_8 >= 0)) || ((d3 < 0) && (rmod_8 <= 0))), rmod_8, (rmod_8 + d3)) < d3) {
            if (let rmod_9: int32 = (let rmod_10: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_6: int32 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_10 >= 0)) || ((d3 < 0) && (rmod_10 <= 0))), rdiv_6, (rdiv_6 - 1)) % d2) in let rdiv_7: int32 = (let rmod_10 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_6 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_10 >= 0)) || ((d3 < 0) && (rmod_10 <= 0))), rdiv_6, (rdiv_6 - 1)) / d2) in select((((d2 >= 0) && (rmod_9 >= 0)) || ((d2 < 0) && (rmod_9 <= 0))), rdiv_7, (rdiv_7 - 1)) < (d0*d1)) {
              if (let rmod_11: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_8: int32 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_11 >= 0)) || ((d3 < 0) && (rmod_11 <= 0))), rdiv_8, (rdiv_8 - 1)) < ((d0*d1)*d2)) {
                T_softmax_exp[((blockIdx.x*512) + threadIdx.x)] = @tir.call_pure_extern("__expf", ((float32*)placeholder[((((let rmod_12: int32 = (let rmod_13: int32 = (let rmod_14: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_9: int32 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_14 >= 0)) || ((d3 < 0) && (rmod_14 <= 0))), rdiv_9, (rdiv_9 - 1)) % d2) in let rdiv_10: int32 = (let rmod_14 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_9 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_14 >= 0)) || ((d3 < 0) && (rmod_14 <= 0))), rdiv_9, (rdiv_9 - 1)) / d2) in select((((d2 >= 0) && (rmod_13 >= 0)) || ((d2 < 0) && (rmod_13 <= 0))), rdiv_10, (rdiv_10 - 1)) % d1) in let rdiv_11: int32 = (let rmod_13 = (let rmod_14 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_9 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_14 >= 0)) || ((d3 < 0) && (rmod_14 <= 0))), rdiv_9, (rdiv_9 - 1)) % d2) in let rdiv_10 = (let rmod_14 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_9 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_14 >= 0)) || ((d3 < 0) && (rmod_14 <= 0))), rdiv_9, (rdiv_9 - 1)) / d2) in select((((d2 >= 0) && (rmod_13 >= 0)) || ((d2 < 0) && (rmod_13 <= 0))), rdiv_10, (rdiv_10 - 1)) / d1) in select((((d1 >= 0) && (rmod_12 >= 0)) || ((d1 < 0) && (rmod_12 <= 0))), rdiv_11, (rdiv_11 - 1))*stride) + (let rmod_15: int32 = (let rmod_16: int32 = (let rmod_17: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_12: int32 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_17 >= 0)) || ((d3 < 0) && (rmod_17 <= 0))), rdiv_12, (rdiv_12 - 1)) % d2) in let rdiv_13: int32 = (let rmod_17 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_12 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_17 >= 0)) || ((d3 < 0) && (rmod_17 <= 0))), rdiv_12, (rdiv_12 - 1)) / d2) in select((((d2 >= 0) && (rmod_16 >= 0)) || ((d2 < 0) && (rmod_16 <= 0))), rdiv_13, (rdiv_13 - 1)) % d1) in select((((d1 >= 0) && (rmod_15 >= 0)) || ((d1 < 0) && (rmod_15 <= 0))), rmod_15, (rmod_15 + d1))*stride_1)) + (let rmod_18: int32 = (let rmod_19: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_14: int32 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_19 >= 0)) || ((d3 < 0) && (rmod_19 <= 0))), rdiv_14, (rdiv_14 - 1)) % d2) in select((((d2 >= 0) && (rmod_18 >= 0)) || ((d2 < 0) && (rmod_18 <= 0))), rmod_18, (rmod_18 + d2))*stride_2)) + (let rmod_20: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in select((((d3 >= 0) && (rmod_20 >= 0)) || ((d3 < 0) && (rmod_20 <= 0))), rmod_20, (rmod_20 + d3))*stride_3))] - (float32*)T_softmax_maxelem[let rmod_21: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_15: int32 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_21 >= 0)) || ((d3 < 0) && (rmod_21 <= 0))), rdiv_15, (rdiv_15 - 1))]), dtype=float32)
              }
            }
          }
        }
      }
    }
  } else {
    if (let rmod_22: int32 = (let rmod_23: int32 = (let rmod_24: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_16: int32 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_24 >= 0)) || ((d3 < 0) && (rmod_24 <= 0))), rdiv_16, (rdiv_16 - 1)) % d2) in let rdiv_17: int32 = (let rmod_24 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_16 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_24 >= 0)) || ((d3 < 0) && (rmod_24 <= 0))), rdiv_16, (rdiv_16 - 1)) / d2) in select((((d2 >= 0) && (rmod_23 >= 0)) || ((d2 < 0) && (rmod_23 <= 0))), rdiv_17, (rdiv_17 - 1)) % d1) in let rdiv_18: int32 = (let rmod_23 = (let rmod_24 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_16 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_24 >= 0)) || ((d3 < 0) && (rmod_24 <= 0))), rdiv_16, (rdiv_16 - 1)) % d2) in let rdiv_17 = (let rmod_24 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_16 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_24 >= 0)) || ((d3 < 0) && (rmod_24 <= 0))), rdiv_16, (rdiv_16 - 1)) / d2) in select((((d2 >= 0) && (rmod_23 >= 0)) || ((d2 < 0) && (rmod_23 <= 0))), rdiv_17, (rdiv_17 - 1)) / d1) in select((((d1 >= 0) && (rmod_22 >= 0)) || ((d1 < 0) && (rmod_22 <= 0))), rdiv_18, (rdiv_18 - 1)) < d0) {
      if (let rmod_25: int32 = (let rmod_26: int32 = (let rmod_27: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_19: int32 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_27 >= 0)) || ((d3 < 0) && (rmod_27 <= 0))), rdiv_19, (rdiv_19 - 1)) % d2) in let rdiv_20: int32 = (let rmod_27 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_19 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_27 >= 0)) || ((d3 < 0) && (rmod_27 <= 0))), rdiv_19, (rdiv_19 - 1)) / d2) in select((((d2 >= 0) && (rmod_26 >= 0)) || ((d2 < 0) && (rmod_26 <= 0))), rdiv_20, (rdiv_20 - 1)) % d1) in select((((d1 >= 0) && (rmod_25 >= 0)) || ((d1 < 0) && (rmod_25 <= 0))), rmod_25, (rmod_25 + d1)) < d1) {
        if (let rmod_28: int32 = (let rmod_29: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_21: int32 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_29 >= 0)) || ((d3 < 0) && (rmod_29 <= 0))), rdiv_21, (rdiv_21 - 1)) % d2) in select((((d2 >= 0) && (rmod_28 >= 0)) || ((d2 < 0) && (rmod_28 <= 0))), rmod_28, (rmod_28 + d2)) < d2) {
          if (let rmod_30: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in select((((d3 >= 0) && (rmod_30 >= 0)) || ((d3 < 0) && (rmod_30 <= 0))), rmod_30, (rmod_30 + d3)) < d3) {
            if (let rmod_31: int32 = (let rmod_32: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_22: int32 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_32 >= 0)) || ((d3 < 0) && (rmod_32 <= 0))), rdiv_22, (rdiv_22 - 1)) % d2) in let rdiv_23: int32 = (let rmod_32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_22 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_32 >= 0)) || ((d3 < 0) && (rmod_32 <= 0))), rdiv_22, (rdiv_22 - 1)) / d2) in select((((d2 >= 0) && (rmod_31 >= 0)) || ((d2 < 0) && (rmod_31 <= 0))), rdiv_23, (rdiv_23 - 1)) < (d0*d1)) {
              if (let rmod_33: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_24: int32 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_33 >= 0)) || ((d3 < 0) && (rmod_33 <= 0))), rdiv_24, (rdiv_24 - 1)) < ((d0*d1)*d2)) {
                if (((blockIdx.x*512) + threadIdx.x) < (((d0*d1)*d2)*d3)) {
                  T_softmax_exp[((blockIdx.x*512) + threadIdx.x)] = @tir.call_pure_extern("__expf", ((float32*)placeholder[((((let rmod_34: int32 = (let rmod_35: int32 = (let rmod_36: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_25: int32 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_36 >= 0)) || ((d3 < 0) && (rmod_36 <= 0))), rdiv_25, (rdiv_25 - 1)) % d2) in let rdiv_26: int32 = (let rmod_36 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_25 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_36 >= 0)) || ((d3 < 0) && (rmod_36 <= 0))), rdiv_25, (rdiv_25 - 1)) / d2) in select((((d2 >= 0) && (rmod_35 >= 0)) || ((d2 < 0) && (rmod_35 <= 0))), rdiv_26, (rdiv_26 - 1)) % d1) in let rdiv_27: int32 = (let rmod_35 = (let rmod_36 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_25 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_36 >= 0)) || ((d3 < 0) && (rmod_36 <= 0))), rdiv_25, (rdiv_25 - 1)) % d2) in let rdiv_26 = (let rmod_36 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_25 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_36 >= 0)) || ((d3 < 0) && (rmod_36 <= 0))), rdiv_25, (rdiv_25 - 1)) / d2) in select((((d2 >= 0) && (rmod_35 >= 0)) || ((d2 < 0) && (rmod_35 <= 0))), rdiv_26, (rdiv_26 - 1)) / d1) in select((((d1 >= 0) && (rmod_34 >= 0)) || ((d1 < 0) && (rmod_34 <= 0))), rdiv_27, (rdiv_27 - 1))*stride) + (let rmod_37: int32 = (let rmod_38: int32 = (let rmod_39: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_28: int32 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_39 >= 0)) || ((d3 < 0) && (rmod_39 <= 0))), rdiv_28, (rdiv_28 - 1)) % d2) in let rdiv_29: int32 = (let rmod_39 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_28 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_39 >= 0)) || ((d3 < 0) && (rmod_39 <= 0))), rdiv_28, (rdiv_28 - 1)) / d2) in select((((d2 >= 0) && (rmod_38 >= 0)) || ((d2 < 0) && (rmod_38 <= 0))), rdiv_29, (rdiv_29 - 1)) % d1) in select((((d1 >= 0) && (rmod_37 >= 0)) || ((d1 < 0) && (rmod_37 <= 0))), rmod_37, (rmod_37 + d1))*stride_1)) + (let rmod_40: int32 = (let rmod_41: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_30: int32 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_41 >= 0)) || ((d3 < 0) && (rmod_41 <= 0))), rdiv_30, (rdiv_30 - 1)) % d2) in select((((d2 >= 0) && (rmod_40 >= 0)) || ((d2 < 0) && (rmod_40 <= 0))), rmod_40, (rmod_40 + d2))*stride_2)) + (let rmod_42: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in select((((d3 >= 0) && (rmod_42 >= 0)) || ((d3 < 0) && (rmod_42 <= 0))), rmod_42, (rmod_42 + d3))*stride_3))] - (float32*)T_softmax_maxelem[let rmod_43: int32 = (((blockIdx.x*512) + threadIdx.x) % d3) in let rdiv_31: int32 = (((blockIdx.x*512) + threadIdx.x) / d3) in select((((d3 >= 0) && (rmod_43 >= 0)) || ((d3 < 0) && (rmod_43 <= 0))), rdiv_31, (rdiv_31 - 1))]), dtype=float32)
                }
              }
            }
          }
        }
      }
    }
  }
}

primfn(T_softmax_norm: Pointer(float32), T_softmax_exp_1: Pointer(float32), T_softmax_maxelem_1: Pointer(float32), d0_1: int32, d1_1: int32, d2_1: int32, d3_1: int32, stride_4: int32, stride_5: int32, stride_6: int32, stride_7: int32) -> ()
  attr = {"target": meta[Target][0], "tir.noalias": 1, "global_symbol": "fused_nn_softmax_kernel3", "tir.device_thread_axis": [IterVar(blockIdx.x_1: int32, (nullptr), "ThreadIndex", "blockIdx.x"), IterVar(threadIdx.x_1: int32, (nullptr), "ThreadIndex", "threadIdx.x")], "calling_conv": 2} {
  attr [IterVar(blockIdx.x_1, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = @tir.shift_right(((((d0_1*d1_1)*d2_1)*d3_1) + 511), 9, dtype=int32);
  attr [IterVar(threadIdx.x_1, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
  if (blockIdx.x_1 < @tir.shift_right((((d0_1*d1_1)*d2_1)*d3_1), 9, dtype=int32)) {
    if (let rmod_44: int32 = (let rmod_45: int32 = (let rmod_46: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_32: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_46 >= 0)) || ((d3_1 < 0) && (rmod_46 <= 0))), rdiv_32, (rdiv_32 - 1)) % d2_1) in let rdiv_33: int32 = (let rmod_46 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_46 >= 0)) || ((d3_1 < 0) && (rmod_46 <= 0))), rdiv_32, (rdiv_32 - 1)) / d2_1) in select((((d2_1 >= 0) && (rmod_45 >= 0)) || ((d2_1 < 0) && (rmod_45 <= 0))), rdiv_33, (rdiv_33 - 1)) % d1_1) in let rdiv_34: int32 = (let rmod_45 = (let rmod_46 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_46 >= 0)) || ((d3_1 < 0) && (rmod_46 <= 0))), rdiv_32, (rdiv_32 - 1)) % d2_1) in let rdiv_33 = (let rmod_46 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_46 >= 0)) || ((d3_1 < 0) && (rmod_46 <= 0))), rdiv_32, (rdiv_32 - 1)) / d2_1) in select((((d2_1 >= 0) && (rmod_45 >= 0)) || ((d2_1 < 0) && (rmod_45 <= 0))), rdiv_33, (rdiv_33 - 1)) / d1_1) in select((((d1_1 >= 0) && (rmod_44 >= 0)) || ((d1_1 < 0) && (rmod_44 <= 0))), rdiv_34, (rdiv_34 - 1)) < d0_1) {
      if (let rmod_47: int32 = (let rmod_48: int32 = (let rmod_49: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_35: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_49 >= 0)) || ((d3_1 < 0) && (rmod_49 <= 0))), rdiv_35, (rdiv_35 - 1)) % d2_1) in let rdiv_36: int32 = (let rmod_49 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_35 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_49 >= 0)) || ((d3_1 < 0) && (rmod_49 <= 0))), rdiv_35, (rdiv_35 - 1)) / d2_1) in select((((d2_1 >= 0) && (rmod_48 >= 0)) || ((d2_1 < 0) && (rmod_48 <= 0))), rdiv_36, (rdiv_36 - 1)) % d1_1) in select((((d1_1 >= 0) && (rmod_47 >= 0)) || ((d1_1 < 0) && (rmod_47 <= 0))), rmod_47, (rmod_47 + d1_1)) < d1_1) {
        if (let rmod_50: int32 = (let rmod_51: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_37: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_51 >= 0)) || ((d3_1 < 0) && (rmod_51 <= 0))), rdiv_37, (rdiv_37 - 1)) % d2_1) in select((((d2_1 >= 0) && (rmod_50 >= 0)) || ((d2_1 < 0) && (rmod_50 <= 0))), rmod_50, (rmod_50 + d2_1)) < d2_1) {
          if (let rmod_52: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in select((((d3_1 >= 0) && (rmod_52 >= 0)) || ((d3_1 < 0) && (rmod_52 <= 0))), rmod_52, (rmod_52 + d3_1)) < d3_1) {
            if (let rmod_53: int32 = (let rmod_54: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_38: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_54 >= 0)) || ((d3_1 < 0) && (rmod_54 <= 0))), rdiv_38, (rdiv_38 - 1)) % d2_1) in let rdiv_39: int32 = (let rmod_54 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_38 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_54 >= 0)) || ((d3_1 < 0) && (rmod_54 <= 0))), rdiv_38, (rdiv_38 - 1)) / d2_1) in select((((d2_1 >= 0) && (rmod_53 >= 0)) || ((d2_1 < 0) && (rmod_53 <= 0))), rdiv_39, (rdiv_39 - 1)) < (d0_1*d1_1)) {
              if (let rmod_55: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_40: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_55 >= 0)) || ((d3_1 < 0) && (rmod_55 <= 0))), rdiv_40, (rdiv_40 - 1)) < ((d0_1*d1_1)*d2_1)) {
                T_softmax_norm[((((let rmod_56: int32 = (let rmod_57: int32 = (let rmod_58: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_41: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_58 >= 0)) || ((d3_1 < 0) && (rmod_58 <= 0))), rdiv_41, (rdiv_41 - 1)) % d2_1) in let rdiv_42: int32 = (let rmod_58 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_41 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_58 >= 0)) || ((d3_1 < 0) && (rmod_58 <= 0))), rdiv_41, (rdiv_41 - 1)) / d2_1) in select((((d2_1 >= 0) && (rmod_57 >= 0)) || ((d2_1 < 0) && (rmod_57 <= 0))), rdiv_42, (rdiv_42 - 1)) % d1_1) in let rdiv_43: int32 = (let rmod_57 = (let rmod_58 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_41 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_58 >= 0)) || ((d3_1 < 0) && (rmod_58 <= 0))), rdiv_41, (rdiv_41 - 1)) % d2_1) in let rdiv_42 = (let rmod_58 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_41 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_58 >= 0)) || ((d3_1 < 0) && (rmod_58 <= 0))), rdiv_41, (rdiv_41 - 1)) / d2_1) in select((((d2_1 >= 0) && (rmod_57 >= 0)) || ((d2_1 < 0) && (rmod_57 <= 0))), rdiv_42, (rdiv_42 - 1)) / d1_1) in select((((d1_1 >= 0) && (rmod_56 >= 0)) || ((d1_1 < 0) && (rmod_56 <= 0))), rdiv_43, (rdiv_43 - 1))*stride_4) + (let rmod_59: int32 = (let rmod_60: int32 = (let rmod_61: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_44: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_61 >= 0)) || ((d3_1 < 0) && (rmod_61 <= 0))), rdiv_44, (rdiv_44 - 1)) % d2_1) in let rdiv_45: int32 = (let rmod_61 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_44 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_61 >= 0)) || ((d3_1 < 0) && (rmod_61 <= 0))), rdiv_44, (rdiv_44 - 1)) / d2_1) in select((((d2_1 >= 0) && (rmod_60 >= 0)) || ((d2_1 < 0) && (rmod_60 <= 0))), rdiv_45, (rdiv_45 - 1)) % d1_1) in select((((d1_1 >= 0) && (rmod_59 >= 0)) || ((d1_1 < 0) && (rmod_59 <= 0))), rmod_59, (rmod_59 + d1_1))*stride_5)) + (let rmod_62: int32 = (let rmod_63: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_46: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_63 >= 0)) || ((d3_1 < 0) && (rmod_63 <= 0))), rdiv_46, (rdiv_46 - 1)) % d2_1) in select((((d2_1 >= 0) && (rmod_62 >= 0)) || ((d2_1 < 0) && (rmod_62 <= 0))), rmod_62, (rmod_62 + d2_1))*stride_6)) + (let rmod_64: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in select((((d3_1 >= 0) && (rmod_64 >= 0)) || ((d3_1 < 0) && (rmod_64 <= 0))), rmod_64, (rmod_64 + d3_1))*stride_7))] = ((float32*)T_softmax_exp_1[((blockIdx.x_1*512) + threadIdx.x_1)] / (float32*)T_softmax_maxelem_1[let rmod_65: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_47: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_65 >= 0)) || ((d3_1 < 0) && (rmod_65 <= 0))), rdiv_47, (rdiv_47 - 1))])
              }
            }
          }
        }
      }
    }
  } else {
    if (let rmod_66: int32 = (let rmod_67: int32 = (let rmod_68: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_48: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_68 >= 0)) || ((d3_1 < 0) && (rmod_68 <= 0))), rdiv_48, (rdiv_48 - 1)) % d2_1) in let rdiv_49: int32 = (let rmod_68 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_48 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_68 >= 0)) || ((d3_1 < 0) && (rmod_68 <= 0))), rdiv_48, (rdiv_48 - 1)) / d2_1) in select((((d2_1 >= 0) && (rmod_67 >= 0)) || ((d2_1 < 0) && (rmod_67 <= 0))), rdiv_49, (rdiv_49 - 1)) % d1_1) in let rdiv_50: int32 = (let rmod_67 = (let rmod_68 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_48 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_68 >= 0)) || ((d3_1 < 0) && (rmod_68 <= 0))), rdiv_48, (rdiv_48 - 1)) % d2_1) in let rdiv_49 = (let rmod_68 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_48 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_68 >= 0)) || ((d3_1 < 0) && (rmod_68 <= 0))), rdiv_48, (rdiv_48 - 1)) / d2_1) in select((((d2_1 >= 0) && (rmod_67 >= 0)) || ((d2_1 < 0) && (rmod_67 <= 0))), rdiv_49, (rdiv_49 - 1)) / d1_1) in select((((d1_1 >= 0) && (rmod_66 >= 0)) || ((d1_1 < 0) && (rmod_66 <= 0))), rdiv_50, (rdiv_50 - 1)) < d0_1) {
      if (let rmod_69: int32 = (let rmod_70: int32 = (let rmod_71: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_51: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_71 >= 0)) || ((d3_1 < 0) && (rmod_71 <= 0))), rdiv_51, (rdiv_51 - 1)) % d2_1) in let rdiv_52: int32 = (let rmod_71 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_51 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_71 >= 0)) || ((d3_1 < 0) && (rmod_71 <= 0))), rdiv_51, (rdiv_51 - 1)) / d2_1) in select((((d2_1 >= 0) && (rmod_70 >= 0)) || ((d2_1 < 0) && (rmod_70 <= 0))), rdiv_52, (rdiv_52 - 1)) % d1_1) in select((((d1_1 >= 0) && (rmod_69 >= 0)) || ((d1_1 < 0) && (rmod_69 <= 0))), rmod_69, (rmod_69 + d1_1)) < d1_1) {
        if (let rmod_72: int32 = (let rmod_73: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_53: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_73 >= 0)) || ((d3_1 < 0) && (rmod_73 <= 0))), rdiv_53, (rdiv_53 - 1)) % d2_1) in select((((d2_1 >= 0) && (rmod_72 >= 0)) || ((d2_1 < 0) && (rmod_72 <= 0))), rmod_72, (rmod_72 + d2_1)) < d2_1) {
          if (let rmod_74: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in select((((d3_1 >= 0) && (rmod_74 >= 0)) || ((d3_1 < 0) && (rmod_74 <= 0))), rmod_74, (rmod_74 + d3_1)) < d3_1) {
            if (let rmod_75: int32 = (let rmod_76: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_54: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_76 >= 0)) || ((d3_1 < 0) && (rmod_76 <= 0))), rdiv_54, (rdiv_54 - 1)) % d2_1) in let rdiv_55: int32 = (let rmod_76 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_54 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_76 >= 0)) || ((d3_1 < 0) && (rmod_76 <= 0))), rdiv_54, (rdiv_54 - 1)) / d2_1) in select((((d2_1 >= 0) && (rmod_75 >= 0)) || ((d2_1 < 0) && (rmod_75 <= 0))), rdiv_55, (rdiv_55 - 1)) < (d0_1*d1_1)) {
              if (let rmod_77: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_56: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_77 >= 0)) || ((d3_1 < 0) && (rmod_77 <= 0))), rdiv_56, (rdiv_56 - 1)) < ((d0_1*d1_1)*d2_1)) {
                if (((blockIdx.x_1*512) + threadIdx.x_1) < (((d0_1*d1_1)*d2_1)*d3_1)) {
                  T_softmax_norm[((((let rmod_78: int32 = (let rmod_79: int32 = (let rmod_80: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_57: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_80 >= 0)) || ((d3_1 < 0) && (rmod_80 <= 0))), rdiv_57, (rdiv_57 - 1)) % d2_1) in let rdiv_58: int32 = (let rmod_80 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_57 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_80 >= 0)) || ((d3_1 < 0) && (rmod_80 <= 0))), rdiv_57, (rdiv_57 - 1)) / d2_1) in select((((d2_1 >= 0) && (rmod_79 >= 0)) || ((d2_1 < 0) && (rmod_79 <= 0))), rdiv_58, (rdiv_58 - 1)) % d1_1) in let rdiv_59: int32 = (let rmod_79 = (let rmod_80 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_57 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_80 >= 0)) || ((d3_1 < 0) && (rmod_80 <= 0))), rdiv_57, (rdiv_57 - 1)) % d2_1) in let rdiv_58 = (let rmod_80 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_57 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_80 >= 0)) || ((d3_1 < 0) && (rmod_80 <= 0))), rdiv_57, (rdiv_57 - 1)) / d2_1) in select((((d2_1 >= 0) && (rmod_79 >= 0)) || ((d2_1 < 0) && (rmod_79 <= 0))), rdiv_58, (rdiv_58 - 1)) / d1_1) in select((((d1_1 >= 0) && (rmod_78 >= 0)) || ((d1_1 < 0) && (rmod_78 <= 0))), rdiv_59, (rdiv_59 - 1))*stride_4) + (let rmod_81: int32 = (let rmod_82: int32 = (let rmod_83: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_60: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_83 >= 0)) || ((d3_1 < 0) && (rmod_83 <= 0))), rdiv_60, (rdiv_60 - 1)) % d2_1) in let rdiv_61: int32 = (let rmod_83 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_60 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_83 >= 0)) || ((d3_1 < 0) && (rmod_83 <= 0))), rdiv_60, (rdiv_60 - 1)) / d2_1) in select((((d2_1 >= 0) && (rmod_82 >= 0)) || ((d2_1 < 0) && (rmod_82 <= 0))), rdiv_61, (rdiv_61 - 1)) % d1_1) in select((((d1_1 >= 0) && (rmod_81 >= 0)) || ((d1_1 < 0) && (rmod_81 <= 0))), rmod_81, (rmod_81 + d1_1))*stride_5)) + (let rmod_84: int32 = (let rmod_85: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_62: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_85 >= 0)) || ((d3_1 < 0) && (rmod_85 <= 0))), rdiv_62, (rdiv_62 - 1)) % d2_1) in select((((d2_1 >= 0) && (rmod_84 >= 0)) || ((d2_1 < 0) && (rmod_84 <= 0))), rmod_84, (rmod_84 + d2_1))*stride_6)) + (let rmod_86: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in select((((d3_1 >= 0) && (rmod_86 >= 0)) || ((d3_1 < 0) && (rmod_86 <= 0))), rmod_86, (rmod_86 + d3_1))*stride_7))] = ((float32*)T_softmax_exp_1[((blockIdx.x_1*512) + threadIdx.x_1)] / (float32*)T_softmax_maxelem_1[let rmod_87: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) % d3_1) in let rdiv_63: int32 = (((blockIdx.x_1*512) + threadIdx.x_1) / d3_1) in select((((d3_1 >= 0) && (rmod_87 >= 0)) || ((d3_1 < 0) && (rmod_87 <= 0))), rdiv_63, (rdiv_63 - 1))])
                }
              }
            }
          }
        }
      }
    }
  }
}

primfn(T_softmax_maxelem_2: Pointer(float32), placeholder_1: Pointer(float32), d0_2: int32, d1_2: int32, d2_2: int32, d3_2: int32, stride_8: int32, stride_9: int32, stride_10: int32, stride_11: int32) -> ()
  attr = {"target": meta[Target][0], "tir.noalias": 1, "global_symbol": "fused_nn_softmax_kernel0", "tir.device_thread_axis": [IterVar(blockIdx.x_2: int32, (nullptr), "ThreadIndex", "blockIdx.x"), IterVar(threadIdx.x_2: int32, (nullptr), "ThreadIndex", "threadIdx.x")], "calling_conv": 2} {
  attr [IterVar(blockIdx.x_2, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = @tir.shift_right((((d0_2*d1_2)*d2_2) + 511), 9, dtype=int32);
  attr [IterVar(threadIdx.x_2, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
  if (blockIdx.x_2 < @tir.shift_right(((d0_2*d1_2)*d2_2), 9, dtype=int32)) {
    if (let rmod_88: int32 = (let rmod_89: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_64: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_89 >= 0)) || ((d2_2 < 0) && (rmod_89 <= 0))), rdiv_64, (rdiv_64 - 1)) % d1_2) in let rdiv_65: int32 = (let rmod_89 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_64 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_89 >= 0)) || ((d2_2 < 0) && (rmod_89 <= 0))), rdiv_64, (rdiv_64 - 1)) / d1_2) in select((((d1_2 >= 0) && (rmod_88 >= 0)) || ((d1_2 < 0) && (rmod_88 <= 0))), rdiv_65, (rdiv_65 - 1)) < d0_2) {
      if (let rmod_90: int32 = (let rmod_91: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_66: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_91 >= 0)) || ((d2_2 < 0) && (rmod_91 <= 0))), rdiv_66, (rdiv_66 - 1)) % d1_2) in select((((d1_2 >= 0) && (rmod_90 >= 0)) || ((d1_2 < 0) && (rmod_90 <= 0))), rmod_90, (rmod_90 + d1_2)) < d1_2) {
        if (let rmod_92: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in select((((d2_2 >= 0) && (rmod_92 >= 0)) || ((d2_2 < 0) && (rmod_92 <= 0))), rmod_92, (rmod_92 + d2_2)) < d2_2) {
          if (let rmod_93: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_67: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_93 >= 0)) || ((d2_2 < 0) && (rmod_93 <= 0))), rdiv_67, (rdiv_67 - 1)) < (d0_2*d1_2)) {
            T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)] = -3.40282e+38f32
          }
        }
      }
    }
    for (k: int32, 0, d3_2) {
      if (let rmod_94: int32 = (let rmod_95: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_68: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_95 >= 0)) || ((d2_2 < 0) && (rmod_95 <= 0))), rdiv_68, (rdiv_68 - 1)) % d1_2) in let rdiv_69: int32 = (let rmod_95 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_68 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_95 >= 0)) || ((d2_2 < 0) && (rmod_95 <= 0))), rdiv_68, (rdiv_68 - 1)) / d1_2) in select((((d1_2 >= 0) && (rmod_94 >= 0)) || ((d1_2 < 0) && (rmod_94 <= 0))), rdiv_69, (rdiv_69 - 1)) < d0_2) {
        if (let rmod_96: int32 = (let rmod_97: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_70: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_97 >= 0)) || ((d2_2 < 0) && (rmod_97 <= 0))), rdiv_70, (rdiv_70 - 1)) % d1_2) in select((((d1_2 >= 0) && (rmod_96 >= 0)) || ((d1_2 < 0) && (rmod_96 <= 0))), rmod_96, (rmod_96 + d1_2)) < d1_2) {
          if (let rmod_98: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in select((((d2_2 >= 0) && (rmod_98 >= 0)) || ((d2_2 < 0) && (rmod_98 <= 0))), rmod_98, (rmod_98 + d2_2)) < d2_2) {
            if (let rmod_99: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_71: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_99 >= 0)) || ((d2_2 < 0) && (rmod_99 <= 0))), rdiv_71, (rdiv_71 - 1)) < (d0_2*d1_2)) {
              T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)] = max((float32*)T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)], (float32*)placeholder_1[((((let rmod_100: int32 = (let rmod_101: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_72: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_101 >= 0)) || ((d2_2 < 0) && (rmod_101 <= 0))), rdiv_72, (rdiv_72 - 1)) % d1_2) in let rdiv_73: int32 = (let rmod_101 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_72 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_101 >= 0)) || ((d2_2 < 0) && (rmod_101 <= 0))), rdiv_72, (rdiv_72 - 1)) / d1_2) in select((((d1_2 >= 0) && (rmod_100 >= 0)) || ((d1_2 < 0) && (rmod_100 <= 0))), rdiv_73, (rdiv_73 - 1))*stride_8) + (let rmod_102: int32 = (let rmod_103: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_74: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_103 >= 0)) || ((d2_2 < 0) && (rmod_103 <= 0))), rdiv_74, (rdiv_74 - 1)) % d1_2) in select((((d1_2 >= 0) && (rmod_102 >= 0)) || ((d1_2 < 0) && (rmod_102 <= 0))), rmod_102, (rmod_102 + d1_2))*stride_9)) + (let rmod_104: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in select((((d2_2 >= 0) && (rmod_104 >= 0)) || ((d2_2 < 0) && (rmod_104 <= 0))), rmod_104, (rmod_104 + d2_2))*stride_10)) + (k*stride_11))])
            }
          }
        }
      }
    }
  } else {
    if (let rmod_105: int32 = (let rmod_106: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_75: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_106 >= 0)) || ((d2_2 < 0) && (rmod_106 <= 0))), rdiv_75, (rdiv_75 - 1)) % d1_2) in let rdiv_76: int32 = (let rmod_106 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_75 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_106 >= 0)) || ((d2_2 < 0) && (rmod_106 <= 0))), rdiv_75, (rdiv_75 - 1)) / d1_2) in select((((d1_2 >= 0) && (rmod_105 >= 0)) || ((d1_2 < 0) && (rmod_105 <= 0))), rdiv_76, (rdiv_76 - 1)) < d0_2) {
      if (let rmod_107: int32 = (let rmod_108: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_77: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_108 >= 0)) || ((d2_2 < 0) && (rmod_108 <= 0))), rdiv_77, (rdiv_77 - 1)) % d1_2) in select((((d1_2 >= 0) && (rmod_107 >= 0)) || ((d1_2 < 0) && (rmod_107 <= 0))), rmod_107, (rmod_107 + d1_2)) < d1_2) {
        if (let rmod_109: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in select((((d2_2 >= 0) && (rmod_109 >= 0)) || ((d2_2 < 0) && (rmod_109 <= 0))), rmod_109, (rmod_109 + d2_2)) < d2_2) {
          if (let rmod_110: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_78: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_110 >= 0)) || ((d2_2 < 0) && (rmod_110 <= 0))), rdiv_78, (rdiv_78 - 1)) < (d0_2*d1_2)) {
            if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0_2*d1_2)*d2_2)) {
              T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)] = -3.40282e+38f32
            }
          }
        }
      }
    }
    for (k_1: int32, 0, d3_2) {
      if (let rmod_111: int32 = (let rmod_112: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_79: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_112 >= 0)) || ((d2_2 < 0) && (rmod_112 <= 0))), rdiv_79, (rdiv_79 - 1)) % d1_2) in let rdiv_80: int32 = (let rmod_112 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_79 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_112 >= 0)) || ((d2_2 < 0) && (rmod_112 <= 0))), rdiv_79, (rdiv_79 - 1)) / d1_2) in select((((d1_2 >= 0) && (rmod_111 >= 0)) || ((d1_2 < 0) && (rmod_111 <= 0))), rdiv_80, (rdiv_80 - 1)) < d0_2) {
        if (let rmod_113: int32 = (let rmod_114: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_81: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_114 >= 0)) || ((d2_2 < 0) && (rmod_114 <= 0))), rdiv_81, (rdiv_81 - 1)) % d1_2) in select((((d1_2 >= 0) && (rmod_113 >= 0)) || ((d1_2 < 0) && (rmod_113 <= 0))), rmod_113, (rmod_113 + d1_2)) < d1_2) {
          if (let rmod_115: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in select((((d2_2 >= 0) && (rmod_115 >= 0)) || ((d2_2 < 0) && (rmod_115 <= 0))), rmod_115, (rmod_115 + d2_2)) < d2_2) {
            if (let rmod_116: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_82: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_116 >= 0)) || ((d2_2 < 0) && (rmod_116 <= 0))), rdiv_82, (rdiv_82 - 1)) < (d0_2*d1_2)) {
              if (((blockIdx.x_2*512) + threadIdx.x_2) < ((d0_2*d1_2)*d2_2)) {
                T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)] = max((float32*)T_softmax_maxelem_2[((blockIdx.x_2*512) + threadIdx.x_2)], (float32*)placeholder_1[((((let rmod_117: int32 = (let rmod_118: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_83: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_118 >= 0)) || ((d2_2 < 0) && (rmod_118 <= 0))), rdiv_83, (rdiv_83 - 1)) % d1_2) in let rdiv_84: int32 = (let rmod_118 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_83 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_118 >= 0)) || ((d2_2 < 0) && (rmod_118 <= 0))), rdiv_83, (rdiv_83 - 1)) / d1_2) in select((((d1_2 >= 0) && (rmod_117 >= 0)) || ((d1_2 < 0) && (rmod_117 <= 0))), rdiv_84, (rdiv_84 - 1))*stride_8) + (let rmod_119: int32 = (let rmod_120: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in let rdiv_85: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) / d2_2) in select((((d2_2 >= 0) && (rmod_120 >= 0)) || ((d2_2 < 0) && (rmod_120 <= 0))), rdiv_85, (rdiv_85 - 1)) % d1_2) in select((((d1_2 >= 0) && (rmod_119 >= 0)) || ((d1_2 < 0) && (rmod_119 <= 0))), rmod_119, (rmod_119 + d1_2))*stride_9)) + (let rmod_121: int32 = (((blockIdx.x_2*512) + threadIdx.x_2) % d2_2) in select((((d2_2 >= 0) && (rmod_121 >= 0)) || ((d2_2 < 0) && (rmod_121 <= 0))), rmod_121, (rmod_121 + d2_2))*stride_10)) + (k_1*stride_11))])
              }
            }
          }
        }
      }
    }
  }
}

primfn(T_softmax_maxelem_3: Pointer(float32), T_softmax_exp_2: Pointer(float32), d0_3: int32, d1_3: int32, d2_3: int32, d3_3: int32) -> ()
  attr = {"target": meta[Target][0], "tir.noalias": 1, "global_symbol": "fused_nn_softmax_kernel2", "tir.device_thread_axis": [IterVar(blockIdx.x_3: int32, (nullptr), "ThreadIndex", "blockIdx.x"), IterVar(threadIdx.x_3: int32, (nullptr), "ThreadIndex", "threadIdx.x")], "calling_conv": 2} {
  attr [IterVar(blockIdx.x_3, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = @tir.shift_right((((d0_3*d1_3)*d2_3) + 511), 9, dtype=int32);
  attr [IterVar(threadIdx.x_3, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 512;
  if (blockIdx.x_3 < @tir.shift_right(((d0_3*d1_3)*d2_3), 9, dtype=int32)) {
    if (let rmod_122: int32 = (let rmod_123: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in let rdiv_86: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) / d2_3) in select((((d2_3 >= 0) && (rmod_123 >= 0)) || ((d2_3 < 0) && (rmod_123 <= 0))), rdiv_86, (rdiv_86 - 1)) % d1_3) in let rdiv_87: int32 = (let rmod_123 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in let rdiv_86 = (((blockIdx.x_3*512) + threadIdx.x_3) / d2_3) in select((((d2_3 >= 0) && (rmod_123 >= 0)) || ((d2_3 < 0) && (rmod_123 <= 0))), rdiv_86, (rdiv_86 - 1)) / d1_3) in select((((d1_3 >= 0) && (rmod_122 >= 0)) || ((d1_3 < 0) && (rmod_122 <= 0))), rdiv_87, (rdiv_87 - 1)) < d0_3) {
      if (let rmod_124: int32 = (let rmod_125: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in let rdiv_88: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) / d2_3) in select((((d2_3 >= 0) && (rmod_125 >= 0)) || ((d2_3 < 0) && (rmod_125 <= 0))), rdiv_88, (rdiv_88 - 1)) % d1_3) in select((((d1_3 >= 0) && (rmod_124 >= 0)) || ((d1_3 < 0) && (rmod_124 <= 0))), rmod_124, (rmod_124 + d1_3)) < d1_3) {
        if (let rmod_126: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in select((((d2_3 >= 0) && (rmod_126 >= 0)) || ((d2_3 < 0) && (rmod_126 <= 0))), rmod_126, (rmod_126 + d2_3)) < d2_3) {
          if (let rmod_127: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in let rdiv_89: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) / d2_3) in select((((d2_3 >= 0) && (rmod_127 >= 0)) || ((d2_3 < 0) && (rmod_127 <= 0))), rdiv_89, (rdiv_89 - 1)) < (d0_3*d1_3)) {
            T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] = 0f32
          }
        }
      }
    }
    for (k_2: int32, 0, d3_3) {
      if (let rmod_128: int32 = (let rmod_129: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in let rdiv_90: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) / d2_3) in select((((d2_3 >= 0) && (rmod_129 >= 0)) || ((d2_3 < 0) && (rmod_129 <= 0))), rdiv_90, (rdiv_90 - 1)) % d1_3) in let rdiv_91: int32 = (let rmod_129 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in let rdiv_90 = (((blockIdx.x_3*512) + threadIdx.x_3) / d2_3) in select((((d2_3 >= 0) && (rmod_129 >= 0)) || ((d2_3 < 0) && (rmod_129 <= 0))), rdiv_90, (rdiv_90 - 1)) / d1_3) in select((((d1_3 >= 0) && (rmod_128 >= 0)) || ((d1_3 < 0) && (rmod_128 <= 0))), rdiv_91, (rdiv_91 - 1)) < d0_3) {
        if (let rmod_130: int32 = (let rmod_131: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in let rdiv_92: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) / d2_3) in select((((d2_3 >= 0) && (rmod_131 >= 0)) || ((d2_3 < 0) && (rmod_131 <= 0))), rdiv_92, (rdiv_92 - 1)) % d1_3) in select((((d1_3 >= 0) && (rmod_130 >= 0)) || ((d1_3 < 0) && (rmod_130 <= 0))), rmod_130, (rmod_130 + d1_3)) < d1_3) {
          if (let rmod_132: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in select((((d2_3 >= 0) && (rmod_132 >= 0)) || ((d2_3 < 0) && (rmod_132 <= 0))), rmod_132, (rmod_132 + d2_3)) < d2_3) {
            if (let rmod_133: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in let rdiv_93: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) / d2_3) in select((((d2_3 >= 0) && (rmod_133 >= 0)) || ((d2_3 < 0) && (rmod_133 <= 0))), rdiv_93, (rdiv_93 - 1)) < (d0_3*d1_3)) {
              T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] = ((float32*)T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] + (float32*)T_softmax_exp_2[((((blockIdx.x_3*512) + threadIdx.x_3)*d3_3) + k_2)])
            }
          }
        }
      }
    }
  } else {
    if (let rmod_134: int32 = (let rmod_135: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in let rdiv_94: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) / d2_3) in select((((d2_3 >= 0) && (rmod_135 >= 0)) || ((d2_3 < 0) && (rmod_135 <= 0))), rdiv_94, (rdiv_94 - 1)) % d1_3) in let rdiv_95: int32 = (let rmod_135 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in let rdiv_94 = (((blockIdx.x_3*512) + threadIdx.x_3) / d2_3) in select((((d2_3 >= 0) && (rmod_135 >= 0)) || ((d2_3 < 0) && (rmod_135 <= 0))), rdiv_94, (rdiv_94 - 1)) / d1_3) in select((((d1_3 >= 0) && (rmod_134 >= 0)) || ((d1_3 < 0) && (rmod_134 <= 0))), rdiv_95, (rdiv_95 - 1)) < d0_3) {
      if (let rmod_136: int32 = (let rmod_137: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in let rdiv_96: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) / d2_3) in select((((d2_3 >= 0) && (rmod_137 >= 0)) || ((d2_3 < 0) && (rmod_137 <= 0))), rdiv_96, (rdiv_96 - 1)) % d1_3) in select((((d1_3 >= 0) && (rmod_136 >= 0)) || ((d1_3 < 0) && (rmod_136 <= 0))), rmod_136, (rmod_136 + d1_3)) < d1_3) {
        if (let rmod_138: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in select((((d2_3 >= 0) && (rmod_138 >= 0)) || ((d2_3 < 0) && (rmod_138 <= 0))), rmod_138, (rmod_138 + d2_3)) < d2_3) {
          if (let rmod_139: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in let rdiv_97: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) / d2_3) in select((((d2_3 >= 0) && (rmod_139 >= 0)) || ((d2_3 < 0) && (rmod_139 <= 0))), rdiv_97, (rdiv_97 - 1)) < (d0_3*d1_3)) {
            if (((blockIdx.x_3*512) + threadIdx.x_3) < ((d0_3*d1_3)*d2_3)) {
              T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] = 0f32
            }
          }
        }
      }
    }
    for (k_3: int32, 0, d3_3) {
      if (let rmod_140: int32 = (let rmod_141: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in let rdiv_98: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) / d2_3) in select((((d2_3 >= 0) && (rmod_141 >= 0)) || ((d2_3 < 0) && (rmod_141 <= 0))), rdiv_98, (rdiv_98 - 1)) % d1_3) in let rdiv_99: int32 = (let rmod_141 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in let rdiv_98 = (((blockIdx.x_3*512) + threadIdx.x_3) / d2_3) in select((((d2_3 >= 0) && (rmod_141 >= 0)) || ((d2_3 < 0) && (rmod_141 <= 0))), rdiv_98, (rdiv_98 - 1)) / d1_3) in select((((d1_3 >= 0) && (rmod_140 >= 0)) || ((d1_3 < 0) && (rmod_140 <= 0))), rdiv_99, (rdiv_99 - 1)) < d0_3) {
        if (let rmod_142: int32 = (let rmod_143: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in let rdiv_100: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) / d2_3) in select((((d2_3 >= 0) && (rmod_143 >= 0)) || ((d2_3 < 0) && (rmod_143 <= 0))), rdiv_100, (rdiv_100 - 1)) % d1_3) in select((((d1_3 >= 0) && (rmod_142 >= 0)) || ((d1_3 < 0) && (rmod_142 <= 0))), rmod_142, (rmod_142 + d1_3)) < d1_3) {
          if (let rmod_144: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in select((((d2_3 >= 0) && (rmod_144 >= 0)) || ((d2_3 < 0) && (rmod_144 <= 0))), rmod_144, (rmod_144 + d2_3)) < d2_3) {
            if (let rmod_145: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) % d2_3) in let rdiv_101: int32 = (((blockIdx.x_3*512) + threadIdx.x_3) / d2_3) in select((((d2_3 >= 0) && (rmod_145 >= 0)) || ((d2_3 < 0) && (rmod_145 <= 0))), rdiv_101, (rdiv_101 - 1)) < (d0_3*d1_3)) {
              if (((blockIdx.x_3*512) + threadIdx.x_3) < ((d0_3*d1_3)*d2_3)) {
                T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] = ((float32*)T_softmax_maxelem_3[((blockIdx.x_3*512) + threadIdx.x_3)] + (float32*)T_softmax_exp_2[((((blockIdx.x_3*512) + threadIdx.x_3)*d3_3) + k_3)])
              }
            }
          }
        }
      }
    }
  }
}


[14:05:58] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass BindTarget
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}

primfn(placeholder_4: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder_3: Buffer(placeholder_5: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_4: placeholder_3, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_5[k0])
  }
}

primfn(placeholder_7: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder_6: Buffer(placeholder_8: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_7: placeholder_6, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_8[0]*4i64)
}


[14:05:58] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.VerifyMemory
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}

primfn(placeholder_4: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder_3: Buffer(placeholder_5: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_4: placeholder_3, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_5[k0])
  }
}

primfn(placeholder_7: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder_6: Buffer(placeholder_8: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_7: placeholder_6, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_8[0]*4i64)
}


[14:05:58] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.ThreadSync
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}

primfn(placeholder_4: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder_3: Buffer(placeholder_5: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_4: placeholder_3, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_5[k0])
  }
}

primfn(placeholder_7: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder_6: Buffer(placeholder_8: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_7: placeholder_6, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_8[0]*4i64)
}


[14:05:58] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.ThreadSync
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}

primfn(placeholder_4: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder_3: Buffer(placeholder_5: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_4: placeholder_3, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_5[k0])
  }
}

primfn(placeholder_7: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder_6: Buffer(placeholder_8: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_7: placeholder_6, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_8[0]*4i64)
}


[14:05:58] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.InferFragment
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}

primfn(placeholder_4: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder_3: Buffer(placeholder_5: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_4: placeholder_3, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_5[k0])
  }
}

primfn(placeholder_7: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder_6: Buffer(placeholder_8: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_7: placeholder_6, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_8[0]*4i64)
}


[14:05:58] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerThreadAllreduce
primfn(placeholder_1: handle, compute_1: handle) -> ()
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {compute: Buffer(compute_2: Pointer(int64), int64, [4], []),
             placeholder: Buffer(placeholder_2: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_1: placeholder, compute_1: compute} {
  for (i0: int32, 0, 4) {
    compute_2[i0] = (int64*)placeholder_2[i0]
  }
}

primfn(placeholder_4: handle, placeholder_red_1: handle) -> ()
  attr = {"global_symbol": "fused_prod", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {placeholder_red: Buffer(placeholder_red_2: Pointer(int64), int64, [], []),
             placeholder_3: Buffer(placeholder_5: Pointer(int64), int64, [4], [])}
  buffer_map = {placeholder_4: placeholder_3, placeholder_red_1: placeholder_red} {
  placeholder_red_2[0] = 1i64
  for (k0: int32, 0, 4) {
    placeholder_red_2[0] = ((int64*)placeholder_red_2[0]*(int64*)placeholder_5[k0])
  }
}

primfn(placeholder_7: handle, T_multiply_1: handle) -> ()
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True, "target": meta[Target][0]}
  buffers = {T_multiply: Buffer(T_multiply_2: Pointer(int64), int64, [], []),
             placeholder_6: Buffer(placeholder_8: Pointer(int64), int64, [], [])}
  buffer_map = {placeholder_7: placeholder_6, T_multiply_1: T_multiply} {
  T_multiply_2[0] = ((int64*)placeholder_8[0]*4i64)
}


[14:05:58] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.MakePackedAPI
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"global_symbol": "shape_func_nn_softmax_1", "tir.noalias": True, "target": meta[Target][0], "calling_conv": 1} {
  assert((num_args == 2), "shape_func_nn_softmax_1: num_args should be 2")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let compute: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [compute] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "shape_func_nn_softmax_1: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "shape_func_nn_softmax_1: Expect arg[1] to be pointer")
  attr ["default"] "device_id" = dev_id;
  attr ["default"] "device_type" = 1;
  assert((1 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((4 == cast(int32, (int64*)arg0.shape[0])), "Argument arg0.shape[0] has an unsatisfied constraint: (4 == int32(arg0.shape[0]))")
   {
    if !@tir.isnullptr(arg0.strides, dtype=bool) {
      assert((1 == cast(int32, (int64*)arg0.strides[0])), "arg0.strides: expected to be compact array")
      0
    }
    assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
    assert((1 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 1")
    assert((1 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 1")
    assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
    assert((4 == cast(int32, (int64*)arg1.shape[0])), "Argument arg1.shape[0] has an unsatisfied constraint: (4 == int32(arg1.shape[0]))")
     {
      if !@tir.isnullptr(arg1.strides, dtype=bool) {
        assert((1 == cast(int32, (int64*)arg1.strides[0])), "arg1.strides: expected to be compact array")
        0
      }
      assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
      assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
      assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
      attr [0] "compute_scope" = "shape_func_nn_softmax_1_compute_";
      for (i0: int32, 0, 4) {
        compute[i0] = (int64*)placeholder[i0]
      }
    }
  }
}

primfn(args_1: handle, arg_type_ids_1: handle, num_args_1: int32, out_ret_value_1: handle, out_ret_tcode_1: handle, resource_handle_1: handle) -> int32
  attr = {"global_symbol": "fused_prod", "tir.noalias": True, "target": meta[Target][0], "calling_conv": 1} {
  assert((num_args_1 == 2), "fused_prod: num_args should be 2")
  let arg0_1: handle = @tir.tvm_struct_get(args_1, 0, 12, dtype=handle)
  let arg0.code_1: int32 = (int32*)arg_type_ids_1[0]
  let arg1_1: handle = @tir.tvm_struct_get(args_1, 1, 12, dtype=handle)
  let arg1.code_1: int32 = (int32*)arg_type_ids_1[1]
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg0_1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg0.shape_1: handle = @tir.tvm_struct_get(arg0_1, 0, 2, dtype=handle)
  let arg0.strides_1: handle = @tir.tvm_struct_get(arg0_1, 0, 3, dtype=handle)
  let dev_id_1: int32 = @tir.tvm_struct_get(arg0_1, 0, 9, dtype=int32)
  let placeholder_red: Pointer(int64) = @tir.tvm_struct_get(arg1_1, 0, 1, dtype=handle)
  attr [placeholder_red] "storage_alignment" = 128;
  let arg1.shape_1: handle = @tir.tvm_struct_get(arg1_1, 0, 2, dtype=handle)
  let arg1.strides_1: handle = @tir.tvm_struct_get(arg1_1, 0, 3, dtype=handle)
  assert(((((arg0.code_1 == 3) || (arg0.code_1 == 13)) || (arg0.code_1 == 7)) || (arg0.code_1 == 4)), "fused_prod: Expect arg[0] to be pointer")
  assert(((((arg1.code_1 == 3) || (arg1.code_1 == 13)) || (arg1.code_1 == 7)) || (arg1.code_1 == 4)), "fused_prod: Expect arg[1] to be pointer")
  attr ["default"] "device_id" = dev_id_1;
  attr ["default"] "device_type" = 1;
  assert((1 == @tir.tvm_struct_get(arg0_1, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((1 == @tir.tvm_struct_get(arg0_1, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((((@tir.tvm_struct_get(arg0_1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0_1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0_1, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((4 == cast(int32, (int64*)arg0.shape_1[0])), "Argument arg0.shape[0] has an unsatisfied constraint: (4 == int32(arg0.shape[0]))")
   {
    if !@tir.isnullptr(arg0.strides_1, dtype=bool) {
      assert((1 == cast(int32, (int64*)arg0.strides_1[0])), "arg0.strides: expected to be compact array")
      0
    }
    assert((0u64 == @tir.tvm_struct_get(arg0_1, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg0_1, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
    assert((0 == @tir.tvm_struct_get(arg1_1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
    assert((0 == @tir.tvm_struct_get(arg1_1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
    assert((((@tir.tvm_struct_get(arg1_1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1_1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1_1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
    assert((0u64 == @tir.tvm_struct_get(arg1_1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg1_1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
    assert((dev_id_1 == @tir.tvm_struct_get(arg1_1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
    attr [0] "compute_scope" = "fused_prod_compute_" {
      placeholder_red[0] = 1i64
      for (k0: int32, 0, 4) {
        placeholder_red[0] = ((int64*)placeholder_red[0]*(int64*)placeholder_1[k0])
      }
    }
  }
}

primfn(args_2: handle, arg_type_ids_2: handle, num_args_2: int32, out_ret_value_2: handle, out_ret_tcode_2: handle, resource_handle_2: handle) -> int32
  attr = {"global_symbol": "fused_multiply", "tir.noalias": True, "target": meta[Target][0], "calling_conv": 1} {
  assert((num_args_2 == 2), "fused_multiply: num_args should be 2")
  let arg0_2: handle = @tir.tvm_struct_get(args_2, 0, 12, dtype=handle)
  let arg0.code_2: int32 = (int32*)arg_type_ids_2[0]
  let arg1_2: handle = @tir.tvm_struct_get(args_2, 1, 12, dtype=handle)
  let arg1.code_2: int32 = (int32*)arg_type_ids_2[1]
  let placeholder_2: Pointer(int64) = @tir.tvm_struct_get(arg0_2, 0, 1, dtype=handle)
  attr [placeholder_2] "storage_alignment" = 128;
  let arg0.shape_2: handle = @tir.tvm_struct_get(arg0_2, 0, 2, dtype=handle)
  let arg0.strides_2: handle = @tir.tvm_struct_get(arg0_2, 0, 3, dtype=handle)
  let dev_id_2: int32 = @tir.tvm_struct_get(arg0_2, 0, 9, dtype=int32)
  let T_multiply: Pointer(int64) = @tir.tvm_struct_get(arg1_2, 0, 1, dtype=handle)
  attr [T_multiply] "storage_alignment" = 128;
  let arg1.shape_2: handle = @tir.tvm_struct_get(arg1_2, 0, 2, dtype=handle)
  let arg1.strides_2: handle = @tir.tvm_struct_get(arg1_2, 0, 3, dtype=handle)
  assert(((((arg0.code_2 == 3) || (arg0.code_2 == 13)) || (arg0.code_2 == 7)) || (arg0.code_2 == 4)), "fused_multiply: Expect arg[0] to be pointer")
  assert(((((arg1.code_2 == 3) || (arg1.code_2 == 13)) || (arg1.code_2 == 7)) || (arg1.code_2 == 4)), "fused_multiply: Expect arg[1] to be pointer")
  attr ["default"] "device_id" = dev_id_2;
  attr ["default"] "device_type" = 1;
  assert((0 == @tir.tvm_struct_get(arg0_2, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0_2, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0_2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0_2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0_2, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0_2, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0_2, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1_2, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1_2, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1_2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1_2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1_2, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1_2, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1_2, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id_2 == @tir.tvm_struct_get(arg1_2, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  attr [0] "compute_scope" = "fused_multiply_compute_";
  T_multiply[0] = ((int64*)placeholder_2[0]*4i64)
}


[14:05:58] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.SplitHostDevice
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": (nullptr), "tir.noalias": True, "global_symbol": "shape_func_nn_softmax_1", "calling_conv": 1} {
  assert((num_args == 2), "shape_func_nn_softmax_1: num_args should be 2")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let compute: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [compute] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "shape_func_nn_softmax_1: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "shape_func_nn_softmax_1: Expect arg[1] to be pointer")
  attr ["default"] "device_id" = dev_id;
  attr ["default"] "device_type" = 1;
  assert((1 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((4 == cast(int32, (int64*)arg0.shape[0])), "Argument arg0.shape[0] has an unsatisfied constraint: (4 == int32(arg0.shape[0]))")
   {
    if !@tir.isnullptr(arg0.strides, dtype=bool) {
      assert((1 == cast(int32, (int64*)arg0.strides[0])), "arg0.strides: expected to be compact array")
      0
    }
    assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
    assert((1 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 1")
    assert((1 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 1")
    assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
    assert((4 == cast(int32, (int64*)arg1.shape[0])), "Argument arg1.shape[0] has an unsatisfied constraint: (4 == int32(arg1.shape[0]))")
     {
      if !@tir.isnullptr(arg1.strides, dtype=bool) {
        assert((1 == cast(int32, (int64*)arg1.strides[0])), "arg1.strides: expected to be compact array")
        0
      }
      assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
      assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
      assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
      attr [0] "compute_scope" = "shape_func_nn_softmax_1_compute_";
      for (i0: int32, 0, 4) {
        compute[i0] = (int64*)placeholder[i0]
      }
    }
  }
}

primfn(args_1: handle, arg_type_ids_1: handle, num_args_1: int32, out_ret_value_1: handle, out_ret_tcode_1: handle, resource_handle_1: handle) -> int32
  attr = {"target": (nullptr), "tir.noalias": True, "global_symbol": "fused_prod", "calling_conv": 1} {
  assert((num_args_1 == 2), "fused_prod: num_args should be 2")
  let arg0_1: handle = @tir.tvm_struct_get(args_1, 0, 12, dtype=handle)
  let arg0.code_1: int32 = (int32*)arg_type_ids_1[0]
  let arg1_1: handle = @tir.tvm_struct_get(args_1, 1, 12, dtype=handle)
  let arg1.code_1: int32 = (int32*)arg_type_ids_1[1]
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg0_1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg0.shape_1: handle = @tir.tvm_struct_get(arg0_1, 0, 2, dtype=handle)
  let arg0.strides_1: handle = @tir.tvm_struct_get(arg0_1, 0, 3, dtype=handle)
  let dev_id_1: int32 = @tir.tvm_struct_get(arg0_1, 0, 9, dtype=int32)
  let placeholder_red: Pointer(int64) = @tir.tvm_struct_get(arg1_1, 0, 1, dtype=handle)
  attr [placeholder_red] "storage_alignment" = 128;
  let arg1.shape_1: handle = @tir.tvm_struct_get(arg1_1, 0, 2, dtype=handle)
  let arg1.strides_1: handle = @tir.tvm_struct_get(arg1_1, 0, 3, dtype=handle)
  assert(((((arg0.code_1 == 3) || (arg0.code_1 == 13)) || (arg0.code_1 == 7)) || (arg0.code_1 == 4)), "fused_prod: Expect arg[0] to be pointer")
  assert(((((arg1.code_1 == 3) || (arg1.code_1 == 13)) || (arg1.code_1 == 7)) || (arg1.code_1 == 4)), "fused_prod: Expect arg[1] to be pointer")
  attr ["default"] "device_id" = dev_id_1;
  attr ["default"] "device_type" = 1;
  assert((1 == @tir.tvm_struct_get(arg0_1, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((1 == @tir.tvm_struct_get(arg0_1, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((((@tir.tvm_struct_get(arg0_1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0_1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0_1, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((4 == cast(int32, (int64*)arg0.shape_1[0])), "Argument arg0.shape[0] has an unsatisfied constraint: (4 == int32(arg0.shape[0]))")
   {
    if !@tir.isnullptr(arg0.strides_1, dtype=bool) {
      assert((1 == cast(int32, (int64*)arg0.strides_1[0])), "arg0.strides: expected to be compact array")
      0
    }
    assert((0u64 == @tir.tvm_struct_get(arg0_1, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg0_1, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
    assert((0 == @tir.tvm_struct_get(arg1_1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
    assert((0 == @tir.tvm_struct_get(arg1_1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
    assert((((@tir.tvm_struct_get(arg1_1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1_1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1_1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
    assert((0u64 == @tir.tvm_struct_get(arg1_1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg1_1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
    assert((dev_id_1 == @tir.tvm_struct_get(arg1_1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
    attr [0] "compute_scope" = "fused_prod_compute_" {
      placeholder_red[0] = 1i64
      for (k0: int32, 0, 4) {
        placeholder_red[0] = ((int64*)placeholder_red[0]*(int64*)placeholder_1[k0])
      }
    }
  }
}

primfn(args_2: handle, arg_type_ids_2: handle, num_args_2: int32, out_ret_value_2: handle, out_ret_tcode_2: handle, resource_handle_2: handle) -> int32
  attr = {"target": (nullptr), "tir.noalias": True, "global_symbol": "fused_multiply", "calling_conv": 1} {
  assert((num_args_2 == 2), "fused_multiply: num_args should be 2")
  let arg0_2: handle = @tir.tvm_struct_get(args_2, 0, 12, dtype=handle)
  let arg0.code_2: int32 = (int32*)arg_type_ids_2[0]
  let arg1_2: handle = @tir.tvm_struct_get(args_2, 1, 12, dtype=handle)
  let arg1.code_2: int32 = (int32*)arg_type_ids_2[1]
  let placeholder_2: Pointer(int64) = @tir.tvm_struct_get(arg0_2, 0, 1, dtype=handle)
  attr [placeholder_2] "storage_alignment" = 128;
  let arg0.shape_2: handle = @tir.tvm_struct_get(arg0_2, 0, 2, dtype=handle)
  let arg0.strides_2: handle = @tir.tvm_struct_get(arg0_2, 0, 3, dtype=handle)
  let dev_id_2: int32 = @tir.tvm_struct_get(arg0_2, 0, 9, dtype=int32)
  let T_multiply: Pointer(int64) = @tir.tvm_struct_get(arg1_2, 0, 1, dtype=handle)
  attr [T_multiply] "storage_alignment" = 128;
  let arg1.shape_2: handle = @tir.tvm_struct_get(arg1_2, 0, 2, dtype=handle)
  let arg1.strides_2: handle = @tir.tvm_struct_get(arg1_2, 0, 3, dtype=handle)
  assert(((((arg0.code_2 == 3) || (arg0.code_2 == 13)) || (arg0.code_2 == 7)) || (arg0.code_2 == 4)), "fused_multiply: Expect arg[0] to be pointer")
  assert(((((arg1.code_2 == 3) || (arg1.code_2 == 13)) || (arg1.code_2 == 7)) || (arg1.code_2 == 4)), "fused_multiply: Expect arg[1] to be pointer")
  attr ["default"] "device_id" = dev_id_2;
  attr ["default"] "device_type" = 1;
  assert((0 == @tir.tvm_struct_get(arg0_2, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0_2, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0_2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0_2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0_2, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0_2, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0_2, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1_2, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1_2, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1_2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1_2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1_2, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1_2, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1_2, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id_2 == @tir.tvm_struct_get(arg1_2, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  attr [0] "compute_scope" = "fused_multiply_compute_";
  T_multiply[0] = ((int64*)placeholder_2[0]*4i64)
}


[14:05:58] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass Filter
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": (nullptr), "tir.noalias": True, "global_symbol": "shape_func_nn_softmax_1", "calling_conv": 1} {
  assert((num_args == 2), "shape_func_nn_softmax_1: num_args should be 2")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let compute: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [compute] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "shape_func_nn_softmax_1: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "shape_func_nn_softmax_1: Expect arg[1] to be pointer")
  attr ["default"] "device_id" = dev_id;
  attr ["default"] "device_type" = 1;
  assert((1 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((4 == cast(int32, (int64*)arg0.shape[0])), "Argument arg0.shape[0] has an unsatisfied constraint: (4 == int32(arg0.shape[0]))")
   {
    if !@tir.isnullptr(arg0.strides, dtype=bool) {
      assert((1 == cast(int32, (int64*)arg0.strides[0])), "arg0.strides: expected to be compact array")
      0
    }
    assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
    assert((1 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 1")
    assert((1 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 1")
    assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
    assert((4 == cast(int32, (int64*)arg1.shape[0])), "Argument arg1.shape[0] has an unsatisfied constraint: (4 == int32(arg1.shape[0]))")
     {
      if !@tir.isnullptr(arg1.strides, dtype=bool) {
        assert((1 == cast(int32, (int64*)arg1.strides[0])), "arg1.strides: expected to be compact array")
        0
      }
      assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
      assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
      assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
      attr [0] "compute_scope" = "shape_func_nn_softmax_1_compute_";
      for (i0: int32, 0, 4) {
        compute[i0] = (int64*)placeholder[i0]
      }
    }
  }
}

primfn(args_1: handle, arg_type_ids_1: handle, num_args_1: int32, out_ret_value_1: handle, out_ret_tcode_1: handle, resource_handle_1: handle) -> int32
  attr = {"target": (nullptr), "tir.noalias": True, "global_symbol": "fused_prod", "calling_conv": 1} {
  assert((num_args_1 == 2), "fused_prod: num_args should be 2")
  let arg0_1: handle = @tir.tvm_struct_get(args_1, 0, 12, dtype=handle)
  let arg0.code_1: int32 = (int32*)arg_type_ids_1[0]
  let arg1_1: handle = @tir.tvm_struct_get(args_1, 1, 12, dtype=handle)
  let arg1.code_1: int32 = (int32*)arg_type_ids_1[1]
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg0_1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg0.shape_1: handle = @tir.tvm_struct_get(arg0_1, 0, 2, dtype=handle)
  let arg0.strides_1: handle = @tir.tvm_struct_get(arg0_1, 0, 3, dtype=handle)
  let dev_id_1: int32 = @tir.tvm_struct_get(arg0_1, 0, 9, dtype=int32)
  let placeholder_red: Pointer(int64) = @tir.tvm_struct_get(arg1_1, 0, 1, dtype=handle)
  attr [placeholder_red] "storage_alignment" = 128;
  let arg1.shape_1: handle = @tir.tvm_struct_get(arg1_1, 0, 2, dtype=handle)
  let arg1.strides_1: handle = @tir.tvm_struct_get(arg1_1, 0, 3, dtype=handle)
  assert(((((arg0.code_1 == 3) || (arg0.code_1 == 13)) || (arg0.code_1 == 7)) || (arg0.code_1 == 4)), "fused_prod: Expect arg[0] to be pointer")
  assert(((((arg1.code_1 == 3) || (arg1.code_1 == 13)) || (arg1.code_1 == 7)) || (arg1.code_1 == 4)), "fused_prod: Expect arg[1] to be pointer")
  attr ["default"] "device_id" = dev_id_1;
  attr ["default"] "device_type" = 1;
  assert((1 == @tir.tvm_struct_get(arg0_1, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((1 == @tir.tvm_struct_get(arg0_1, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((((@tir.tvm_struct_get(arg0_1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0_1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0_1, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((4 == cast(int32, (int64*)arg0.shape_1[0])), "Argument arg0.shape[0] has an unsatisfied constraint: (4 == int32(arg0.shape[0]))")
   {
    if !@tir.isnullptr(arg0.strides_1, dtype=bool) {
      assert((1 == cast(int32, (int64*)arg0.strides_1[0])), "arg0.strides: expected to be compact array")
      0
    }
    assert((0u64 == @tir.tvm_struct_get(arg0_1, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg0_1, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
    assert((0 == @tir.tvm_struct_get(arg1_1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
    assert((0 == @tir.tvm_struct_get(arg1_1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
    assert((((@tir.tvm_struct_get(arg1_1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1_1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1_1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
    assert((0u64 == @tir.tvm_struct_get(arg1_1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg1_1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
    assert((dev_id_1 == @tir.tvm_struct_get(arg1_1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
    attr [0] "compute_scope" = "fused_prod_compute_" {
      placeholder_red[0] = 1i64
      for (k0: int32, 0, 4) {
        placeholder_red[0] = ((int64*)placeholder_red[0]*(int64*)placeholder_1[k0])
      }
    }
  }
}

primfn(args_2: handle, arg_type_ids_2: handle, num_args_2: int32, out_ret_value_2: handle, out_ret_tcode_2: handle, resource_handle_2: handle) -> int32
  attr = {"target": (nullptr), "tir.noalias": True, "global_symbol": "fused_multiply", "calling_conv": 1} {
  assert((num_args_2 == 2), "fused_multiply: num_args should be 2")
  let arg0_2: handle = @tir.tvm_struct_get(args_2, 0, 12, dtype=handle)
  let arg0.code_2: int32 = (int32*)arg_type_ids_2[0]
  let arg1_2: handle = @tir.tvm_struct_get(args_2, 1, 12, dtype=handle)
  let arg1.code_2: int32 = (int32*)arg_type_ids_2[1]
  let placeholder_2: Pointer(int64) = @tir.tvm_struct_get(arg0_2, 0, 1, dtype=handle)
  attr [placeholder_2] "storage_alignment" = 128;
  let arg0.shape_2: handle = @tir.tvm_struct_get(arg0_2, 0, 2, dtype=handle)
  let arg0.strides_2: handle = @tir.tvm_struct_get(arg0_2, 0, 3, dtype=handle)
  let dev_id_2: int32 = @tir.tvm_struct_get(arg0_2, 0, 9, dtype=int32)
  let T_multiply: Pointer(int64) = @tir.tvm_struct_get(arg1_2, 0, 1, dtype=handle)
  attr [T_multiply] "storage_alignment" = 128;
  let arg1.shape_2: handle = @tir.tvm_struct_get(arg1_2, 0, 2, dtype=handle)
  let arg1.strides_2: handle = @tir.tvm_struct_get(arg1_2, 0, 3, dtype=handle)
  assert(((((arg0.code_2 == 3) || (arg0.code_2 == 13)) || (arg0.code_2 == 7)) || (arg0.code_2 == 4)), "fused_multiply: Expect arg[0] to be pointer")
  assert(((((arg1.code_2 == 3) || (arg1.code_2 == 13)) || (arg1.code_2 == 7)) || (arg1.code_2 == 4)), "fused_multiply: Expect arg[1] to be pointer")
  attr ["default"] "device_id" = dev_id_2;
  attr ["default"] "device_type" = 1;
  assert((0 == @tir.tvm_struct_get(arg0_2, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0_2, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0_2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0_2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0_2, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0_2, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0_2, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1_2, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1_2, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1_2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1_2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1_2, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1_2, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1_2, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id_2 == @tir.tvm_struct_get(arg1_2, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  attr [0] "compute_scope" = "fused_multiply_compute_";
  T_multiply[0] = ((int64*)placeholder_2[0]*4i64)
}


[14:05:58] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass BindTarget
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "shape_func_nn_softmax_1", "calling_conv": 1} {
  assert((num_args == 2), "shape_func_nn_softmax_1: num_args should be 2")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let compute: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [compute] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "shape_func_nn_softmax_1: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "shape_func_nn_softmax_1: Expect arg[1] to be pointer")
  attr ["default"] "device_id" = dev_id;
  attr ["default"] "device_type" = 1;
  assert((1 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((4 == cast(int32, (int64*)arg0.shape[0])), "Argument arg0.shape[0] has an unsatisfied constraint: (4 == int32(arg0.shape[0]))")
   {
    if !@tir.isnullptr(arg0.strides, dtype=bool) {
      assert((1 == cast(int32, (int64*)arg0.strides[0])), "arg0.strides: expected to be compact array")
      0
    }
    assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
    assert((1 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 1")
    assert((1 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 1")
    assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
    assert((4 == cast(int32, (int64*)arg1.shape[0])), "Argument arg1.shape[0] has an unsatisfied constraint: (4 == int32(arg1.shape[0]))")
     {
      if !@tir.isnullptr(arg1.strides, dtype=bool) {
        assert((1 == cast(int32, (int64*)arg1.strides[0])), "arg1.strides: expected to be compact array")
        0
      }
      assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
      assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
      assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
      attr [0] "compute_scope" = "shape_func_nn_softmax_1_compute_";
      for (i0: int32, 0, 4) {
        compute[i0] = (int64*)placeholder[i0]
      }
    }
  }
}

primfn(args_1: handle, arg_type_ids_1: handle, num_args_1: int32, out_ret_value_1: handle, out_ret_tcode_1: handle, resource_handle_1: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_prod", "calling_conv": 1} {
  assert((num_args_1 == 2), "fused_prod: num_args should be 2")
  let arg0_1: handle = @tir.tvm_struct_get(args_1, 0, 12, dtype=handle)
  let arg0.code_1: int32 = (int32*)arg_type_ids_1[0]
  let arg1_1: handle = @tir.tvm_struct_get(args_1, 1, 12, dtype=handle)
  let arg1.code_1: int32 = (int32*)arg_type_ids_1[1]
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg0_1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg0.shape_1: handle = @tir.tvm_struct_get(arg0_1, 0, 2, dtype=handle)
  let arg0.strides_1: handle = @tir.tvm_struct_get(arg0_1, 0, 3, dtype=handle)
  let dev_id_1: int32 = @tir.tvm_struct_get(arg0_1, 0, 9, dtype=int32)
  let placeholder_red: Pointer(int64) = @tir.tvm_struct_get(arg1_1, 0, 1, dtype=handle)
  attr [placeholder_red] "storage_alignment" = 128;
  let arg1.shape_1: handle = @tir.tvm_struct_get(arg1_1, 0, 2, dtype=handle)
  let arg1.strides_1: handle = @tir.tvm_struct_get(arg1_1, 0, 3, dtype=handle)
  assert(((((arg0.code_1 == 3) || (arg0.code_1 == 13)) || (arg0.code_1 == 7)) || (arg0.code_1 == 4)), "fused_prod: Expect arg[0] to be pointer")
  assert(((((arg1.code_1 == 3) || (arg1.code_1 == 13)) || (arg1.code_1 == 7)) || (arg1.code_1 == 4)), "fused_prod: Expect arg[1] to be pointer")
  attr ["default"] "device_id" = dev_id_1;
  attr ["default"] "device_type" = 1;
  assert((1 == @tir.tvm_struct_get(arg0_1, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((1 == @tir.tvm_struct_get(arg0_1, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((((@tir.tvm_struct_get(arg0_1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0_1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0_1, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((4 == cast(int32, (int64*)arg0.shape_1[0])), "Argument arg0.shape[0] has an unsatisfied constraint: (4 == int32(arg0.shape[0]))")
   {
    if !@tir.isnullptr(arg0.strides_1, dtype=bool) {
      assert((1 == cast(int32, (int64*)arg0.strides_1[0])), "arg0.strides: expected to be compact array")
      0
    }
    assert((0u64 == @tir.tvm_struct_get(arg0_1, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg0_1, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
    assert((0 == @tir.tvm_struct_get(arg1_1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
    assert((0 == @tir.tvm_struct_get(arg1_1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
    assert((((@tir.tvm_struct_get(arg1_1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1_1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1_1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
    assert((0u64 == @tir.tvm_struct_get(arg1_1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg1_1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
    assert((dev_id_1 == @tir.tvm_struct_get(arg1_1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
    attr [0] "compute_scope" = "fused_prod_compute_" {
      placeholder_red[0] = 1i64
      for (k0: int32, 0, 4) {
        placeholder_red[0] = ((int64*)placeholder_red[0]*(int64*)placeholder_1[k0])
      }
    }
  }
}

primfn(args_2: handle, arg_type_ids_2: handle, num_args_2: int32, out_ret_value_2: handle, out_ret_tcode_2: handle, resource_handle_2: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_multiply", "calling_conv": 1} {
  assert((num_args_2 == 2), "fused_multiply: num_args should be 2")
  let arg0_2: handle = @tir.tvm_struct_get(args_2, 0, 12, dtype=handle)
  let arg0.code_2: int32 = (int32*)arg_type_ids_2[0]
  let arg1_2: handle = @tir.tvm_struct_get(args_2, 1, 12, dtype=handle)
  let arg1.code_2: int32 = (int32*)arg_type_ids_2[1]
  let placeholder_2: Pointer(int64) = @tir.tvm_struct_get(arg0_2, 0, 1, dtype=handle)
  attr [placeholder_2] "storage_alignment" = 128;
  let arg0.shape_2: handle = @tir.tvm_struct_get(arg0_2, 0, 2, dtype=handle)
  let arg0.strides_2: handle = @tir.tvm_struct_get(arg0_2, 0, 3, dtype=handle)
  let dev_id_2: int32 = @tir.tvm_struct_get(arg0_2, 0, 9, dtype=int32)
  let T_multiply: Pointer(int64) = @tir.tvm_struct_get(arg1_2, 0, 1, dtype=handle)
  attr [T_multiply] "storage_alignment" = 128;
  let arg1.shape_2: handle = @tir.tvm_struct_get(arg1_2, 0, 2, dtype=handle)
  let arg1.strides_2: handle = @tir.tvm_struct_get(arg1_2, 0, 3, dtype=handle)
  assert(((((arg0.code_2 == 3) || (arg0.code_2 == 13)) || (arg0.code_2 == 7)) || (arg0.code_2 == 4)), "fused_multiply: Expect arg[0] to be pointer")
  assert(((((arg1.code_2 == 3) || (arg1.code_2 == 13)) || (arg1.code_2 == 7)) || (arg1.code_2 == 4)), "fused_multiply: Expect arg[1] to be pointer")
  attr ["default"] "device_id" = dev_id_2;
  attr ["default"] "device_type" = 1;
  assert((0 == @tir.tvm_struct_get(arg0_2, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0_2, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0_2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0_2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0_2, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0_2, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0_2, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1_2, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1_2, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1_2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1_2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1_2, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1_2, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1_2, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id_2 == @tir.tvm_struct_get(arg1_2, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  attr [0] "compute_scope" = "fused_multiply_compute_";
  T_multiply[0] = ((int64*)placeholder_2[0]*4i64)
}


[14:05:58] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerTVMBuiltin
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "shape_func_nn_softmax_1", "calling_conv": 1} {
  assert((num_args == 2), "shape_func_nn_softmax_1: num_args should be 2")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let compute: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [compute] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "shape_func_nn_softmax_1: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "shape_func_nn_softmax_1: Expect arg[1] to be pointer")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((4 == cast(int32, (int64*)arg0.shape[0])), "Argument arg0.shape[0] has an unsatisfied constraint: (4 == int32(arg0.shape[0]))")
   {
    if !@tir.isnullptr(arg0.strides, dtype=bool) {
      assert((1 == cast(int32, (int64*)arg0.strides[0])), "arg0.strides: expected to be compact array")
      0
    }
    assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
    assert((1 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 1")
    assert((1 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 1")
    assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
    assert((4 == cast(int32, (int64*)arg1.shape[0])), "Argument arg1.shape[0] has an unsatisfied constraint: (4 == int32(arg1.shape[0]))")
     {
      if !@tir.isnullptr(arg1.strides, dtype=bool) {
        assert((1 == cast(int32, (int64*)arg1.strides[0])), "arg1.strides: expected to be compact array")
        0
      }
      assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
      assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
      assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
      attr [0] "compute_scope" = "shape_func_nn_softmax_1_compute_";
      for (i0: int32, 0, 4) {
        compute[i0] = (int64*)placeholder[i0]
      }
    }
  }
}

primfn(args_1: handle, arg_type_ids_1: handle, num_args_1: int32, out_ret_value_1: handle, out_ret_tcode_1: handle, resource_handle_1: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_prod", "calling_conv": 1} {
  assert((num_args_1 == 2), "fused_prod: num_args should be 2")
  let arg0_1: handle = @tir.tvm_struct_get(args_1, 0, 12, dtype=handle)
  let arg0.code_1: int32 = (int32*)arg_type_ids_1[0]
  let arg1_1: handle = @tir.tvm_struct_get(args_1, 1, 12, dtype=handle)
  let arg1.code_1: int32 = (int32*)arg_type_ids_1[1]
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg0_1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg0.shape_1: handle = @tir.tvm_struct_get(arg0_1, 0, 2, dtype=handle)
  let arg0.strides_1: handle = @tir.tvm_struct_get(arg0_1, 0, 3, dtype=handle)
  let dev_id_1: int32 = @tir.tvm_struct_get(arg0_1, 0, 9, dtype=int32)
  let placeholder_red: Pointer(int64) = @tir.tvm_struct_get(arg1_1, 0, 1, dtype=handle)
  attr [placeholder_red] "storage_alignment" = 128;
  let arg1.shape_1: handle = @tir.tvm_struct_get(arg1_1, 0, 2, dtype=handle)
  let arg1.strides_1: handle = @tir.tvm_struct_get(arg1_1, 0, 3, dtype=handle)
  assert(((((arg0.code_1 == 3) || (arg0.code_1 == 13)) || (arg0.code_1 == 7)) || (arg0.code_1 == 4)), "fused_prod: Expect arg[0] to be pointer")
  assert(((((arg1.code_1 == 3) || (arg1.code_1 == 13)) || (arg1.code_1 == 7)) || (arg1.code_1 == 4)), "fused_prod: Expect arg[1] to be pointer")
  assert((1 == @tir.tvm_struct_get(arg0_1, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((1 == @tir.tvm_struct_get(arg0_1, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((((@tir.tvm_struct_get(arg0_1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0_1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0_1, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((4 == cast(int32, (int64*)arg0.shape_1[0])), "Argument arg0.shape[0] has an unsatisfied constraint: (4 == int32(arg0.shape[0]))")
   {
    if !@tir.isnullptr(arg0.strides_1, dtype=bool) {
      assert((1 == cast(int32, (int64*)arg0.strides_1[0])), "arg0.strides: expected to be compact array")
      0
    }
    assert((0u64 == @tir.tvm_struct_get(arg0_1, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg0_1, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
    assert((0 == @tir.tvm_struct_get(arg1_1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
    assert((0 == @tir.tvm_struct_get(arg1_1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
    assert((((@tir.tvm_struct_get(arg1_1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1_1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1_1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
    assert((0u64 == @tir.tvm_struct_get(arg1_1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg1_1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
    assert((dev_id_1 == @tir.tvm_struct_get(arg1_1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
    attr [0] "compute_scope" = "fused_prod_compute_" {
      placeholder_red[0] = 1i64
      for (k0: int32, 0, 4) {
        placeholder_red[0] = ((int64*)placeholder_red[0]*(int64*)placeholder_1[k0])
      }
    }
  }
}

primfn(args_2: handle, arg_type_ids_2: handle, num_args_2: int32, out_ret_value_2: handle, out_ret_tcode_2: handle, resource_handle_2: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_multiply", "calling_conv": 1} {
  assert((num_args_2 == 2), "fused_multiply: num_args should be 2")
  let arg0_2: handle = @tir.tvm_struct_get(args_2, 0, 12, dtype=handle)
  let arg0.code_2: int32 = (int32*)arg_type_ids_2[0]
  let arg1_2: handle = @tir.tvm_struct_get(args_2, 1, 12, dtype=handle)
  let arg1.code_2: int32 = (int32*)arg_type_ids_2[1]
  let placeholder_2: Pointer(int64) = @tir.tvm_struct_get(arg0_2, 0, 1, dtype=handle)
  attr [placeholder_2] "storage_alignment" = 128;
  let arg0.shape_2: handle = @tir.tvm_struct_get(arg0_2, 0, 2, dtype=handle)
  let arg0.strides_2: handle = @tir.tvm_struct_get(arg0_2, 0, 3, dtype=handle)
  let dev_id_2: int32 = @tir.tvm_struct_get(arg0_2, 0, 9, dtype=int32)
  let T_multiply: Pointer(int64) = @tir.tvm_struct_get(arg1_2, 0, 1, dtype=handle)
  attr [T_multiply] "storage_alignment" = 128;
  let arg1.shape_2: handle = @tir.tvm_struct_get(arg1_2, 0, 2, dtype=handle)
  let arg1.strides_2: handle = @tir.tvm_struct_get(arg1_2, 0, 3, dtype=handle)
  assert(((((arg0.code_2 == 3) || (arg0.code_2 == 13)) || (arg0.code_2 == 7)) || (arg0.code_2 == 4)), "fused_multiply: Expect arg[0] to be pointer")
  assert(((((arg1.code_2 == 3) || (arg1.code_2 == 13)) || (arg1.code_2 == 7)) || (arg1.code_2 == 4)), "fused_multiply: Expect arg[1] to be pointer")
  assert((0 == @tir.tvm_struct_get(arg0_2, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0_2, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0_2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0_2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0_2, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0_2, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0_2, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1_2, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1_2, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1_2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1_2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1_2, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1_2, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1_2, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id_2 == @tir.tvm_struct_get(arg1_2, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  attr [0] "compute_scope" = "fused_multiply_compute_";
  T_multiply[0] = ((int64*)placeholder_2[0]*4i64)
}


[14:05:58] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerCustomDatatypes
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "shape_func_nn_softmax_1", "calling_conv": 1} {
  assert((num_args == 2), "shape_func_nn_softmax_1: num_args should be 2")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let compute: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [compute] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "shape_func_nn_softmax_1: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "shape_func_nn_softmax_1: Expect arg[1] to be pointer")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((4 == cast(int32, (int64*)arg0.shape[0])), "Argument arg0.shape[0] has an unsatisfied constraint: (4 == int32(arg0.shape[0]))")
   {
    if !@tir.isnullptr(arg0.strides, dtype=bool) {
      assert((1 == cast(int32, (int64*)arg0.strides[0])), "arg0.strides: expected to be compact array")
      0
    }
    assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
    assert((1 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 1")
    assert((1 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 1")
    assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
    assert((4 == cast(int32, (int64*)arg1.shape[0])), "Argument arg1.shape[0] has an unsatisfied constraint: (4 == int32(arg1.shape[0]))")
     {
      if !@tir.isnullptr(arg1.strides, dtype=bool) {
        assert((1 == cast(int32, (int64*)arg1.strides[0])), "arg1.strides: expected to be compact array")
        0
      }
      assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
      assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
      assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
      attr [0] "compute_scope" = "shape_func_nn_softmax_1_compute_";
      for (i0: int32, 0, 4) {
        compute[i0] = (int64*)placeholder[i0]
      }
    }
  }
}

primfn(args_1: handle, arg_type_ids_1: handle, num_args_1: int32, out_ret_value_1: handle, out_ret_tcode_1: handle, resource_handle_1: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_prod", "calling_conv": 1} {
  assert((num_args_1 == 2), "fused_prod: num_args should be 2")
  let arg0_1: handle = @tir.tvm_struct_get(args_1, 0, 12, dtype=handle)
  let arg0.code_1: int32 = (int32*)arg_type_ids_1[0]
  let arg1_1: handle = @tir.tvm_struct_get(args_1, 1, 12, dtype=handle)
  let arg1.code_1: int32 = (int32*)arg_type_ids_1[1]
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg0_1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg0.shape_1: handle = @tir.tvm_struct_get(arg0_1, 0, 2, dtype=handle)
  let arg0.strides_1: handle = @tir.tvm_struct_get(arg0_1, 0, 3, dtype=handle)
  let dev_id_1: int32 = @tir.tvm_struct_get(arg0_1, 0, 9, dtype=int32)
  let placeholder_red: Pointer(int64) = @tir.tvm_struct_get(arg1_1, 0, 1, dtype=handle)
  attr [placeholder_red] "storage_alignment" = 128;
  let arg1.shape_1: handle = @tir.tvm_struct_get(arg1_1, 0, 2, dtype=handle)
  let arg1.strides_1: handle = @tir.tvm_struct_get(arg1_1, 0, 3, dtype=handle)
  assert(((((arg0.code_1 == 3) || (arg0.code_1 == 13)) || (arg0.code_1 == 7)) || (arg0.code_1 == 4)), "fused_prod: Expect arg[0] to be pointer")
  assert(((((arg1.code_1 == 3) || (arg1.code_1 == 13)) || (arg1.code_1 == 7)) || (arg1.code_1 == 4)), "fused_prod: Expect arg[1] to be pointer")
  assert((1 == @tir.tvm_struct_get(arg0_1, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((1 == @tir.tvm_struct_get(arg0_1, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((((@tir.tvm_struct_get(arg0_1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0_1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0_1, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((4 == cast(int32, (int64*)arg0.shape_1[0])), "Argument arg0.shape[0] has an unsatisfied constraint: (4 == int32(arg0.shape[0]))")
   {
    if !@tir.isnullptr(arg0.strides_1, dtype=bool) {
      assert((1 == cast(int32, (int64*)arg0.strides_1[0])), "arg0.strides: expected to be compact array")
      0
    }
    assert((0u64 == @tir.tvm_struct_get(arg0_1, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg0_1, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
    assert((0 == @tir.tvm_struct_get(arg1_1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
    assert((0 == @tir.tvm_struct_get(arg1_1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
    assert((((@tir.tvm_struct_get(arg1_1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1_1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1_1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
    assert((0u64 == @tir.tvm_struct_get(arg1_1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg1_1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
    assert((dev_id_1 == @tir.tvm_struct_get(arg1_1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
    attr [0] "compute_scope" = "fused_prod_compute_" {
      placeholder_red[0] = 1i64
      for (k0: int32, 0, 4) {
        placeholder_red[0] = ((int64*)placeholder_red[0]*(int64*)placeholder_1[k0])
      }
    }
  }
}

primfn(args_2: handle, arg_type_ids_2: handle, num_args_2: int32, out_ret_value_2: handle, out_ret_tcode_2: handle, resource_handle_2: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_multiply", "calling_conv": 1} {
  assert((num_args_2 == 2), "fused_multiply: num_args should be 2")
  let arg0_2: handle = @tir.tvm_struct_get(args_2, 0, 12, dtype=handle)
  let arg0.code_2: int32 = (int32*)arg_type_ids_2[0]
  let arg1_2: handle = @tir.tvm_struct_get(args_2, 1, 12, dtype=handle)
  let arg1.code_2: int32 = (int32*)arg_type_ids_2[1]
  let placeholder_2: Pointer(int64) = @tir.tvm_struct_get(arg0_2, 0, 1, dtype=handle)
  attr [placeholder_2] "storage_alignment" = 128;
  let arg0.shape_2: handle = @tir.tvm_struct_get(arg0_2, 0, 2, dtype=handle)
  let arg0.strides_2: handle = @tir.tvm_struct_get(arg0_2, 0, 3, dtype=handle)
  let dev_id_2: int32 = @tir.tvm_struct_get(arg0_2, 0, 9, dtype=int32)
  let T_multiply: Pointer(int64) = @tir.tvm_struct_get(arg1_2, 0, 1, dtype=handle)
  attr [T_multiply] "storage_alignment" = 128;
  let arg1.shape_2: handle = @tir.tvm_struct_get(arg1_2, 0, 2, dtype=handle)
  let arg1.strides_2: handle = @tir.tvm_struct_get(arg1_2, 0, 3, dtype=handle)
  assert(((((arg0.code_2 == 3) || (arg0.code_2 == 13)) || (arg0.code_2 == 7)) || (arg0.code_2 == 4)), "fused_multiply: Expect arg[0] to be pointer")
  assert(((((arg1.code_2 == 3) || (arg1.code_2 == 13)) || (arg1.code_2 == 7)) || (arg1.code_2 == 4)), "fused_multiply: Expect arg[1] to be pointer")
  assert((0 == @tir.tvm_struct_get(arg0_2, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0_2, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0_2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0_2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0_2, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0_2, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0_2, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1_2, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1_2, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1_2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1_2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1_2, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1_2, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1_2, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id_2 == @tir.tvm_struct_get(arg1_2, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  attr [0] "compute_scope" = "fused_multiply_compute_";
  T_multiply[0] = ((int64*)placeholder_2[0]*4i64)
}


[14:05:58] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerIntrin
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "shape_func_nn_softmax_1", "calling_conv": 1} {
  assert((num_args == 2), "shape_func_nn_softmax_1: num_args should be 2")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let compute: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [compute] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "shape_func_nn_softmax_1: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "shape_func_nn_softmax_1: Expect arg[1] to be pointer")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((4 == cast(int32, (int64*)arg0.shape[0])), "Argument arg0.shape[0] has an unsatisfied constraint: (4 == int32(arg0.shape[0]))")
   {
    if !@tir.isnullptr(arg0.strides, dtype=bool) {
      assert((1 == cast(int32, (int64*)arg0.strides[0])), "arg0.strides: expected to be compact array")
      0
    }
    assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
    assert((1 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 1")
    assert((1 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 1")
    assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
    assert((4 == cast(int32, (int64*)arg1.shape[0])), "Argument arg1.shape[0] has an unsatisfied constraint: (4 == int32(arg1.shape[0]))")
     {
      if !@tir.isnullptr(arg1.strides, dtype=bool) {
        assert((1 == cast(int32, (int64*)arg1.strides[0])), "arg1.strides: expected to be compact array")
        0
      }
      assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
      assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
      assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
      attr [0] "compute_scope" = "shape_func_nn_softmax_1_compute_";
      for (i0: int32, 0, 4) {
        compute[i0] = (int64*)placeholder[i0]
      }
    }
  }
}

primfn(args_1: handle, arg_type_ids_1: handle, num_args_1: int32, out_ret_value_1: handle, out_ret_tcode_1: handle, resource_handle_1: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_prod", "calling_conv": 1} {
  assert((num_args_1 == 2), "fused_prod: num_args should be 2")
  let arg0_1: handle = @tir.tvm_struct_get(args_1, 0, 12, dtype=handle)
  let arg0.code_1: int32 = (int32*)arg_type_ids_1[0]
  let arg1_1: handle = @tir.tvm_struct_get(args_1, 1, 12, dtype=handle)
  let arg1.code_1: int32 = (int32*)arg_type_ids_1[1]
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg0_1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg0.shape_1: handle = @tir.tvm_struct_get(arg0_1, 0, 2, dtype=handle)
  let arg0.strides_1: handle = @tir.tvm_struct_get(arg0_1, 0, 3, dtype=handle)
  let dev_id_1: int32 = @tir.tvm_struct_get(arg0_1, 0, 9, dtype=int32)
  let placeholder_red: Pointer(int64) = @tir.tvm_struct_get(arg1_1, 0, 1, dtype=handle)
  attr [placeholder_red] "storage_alignment" = 128;
  let arg1.shape_1: handle = @tir.tvm_struct_get(arg1_1, 0, 2, dtype=handle)
  let arg1.strides_1: handle = @tir.tvm_struct_get(arg1_1, 0, 3, dtype=handle)
  assert(((((arg0.code_1 == 3) || (arg0.code_1 == 13)) || (arg0.code_1 == 7)) || (arg0.code_1 == 4)), "fused_prod: Expect arg[0] to be pointer")
  assert(((((arg1.code_1 == 3) || (arg1.code_1 == 13)) || (arg1.code_1 == 7)) || (arg1.code_1 == 4)), "fused_prod: Expect arg[1] to be pointer")
  assert((1 == @tir.tvm_struct_get(arg0_1, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((1 == @tir.tvm_struct_get(arg0_1, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((((@tir.tvm_struct_get(arg0_1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0_1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0_1, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((4 == cast(int32, (int64*)arg0.shape_1[0])), "Argument arg0.shape[0] has an unsatisfied constraint: (4 == int32(arg0.shape[0]))")
   {
    if !@tir.isnullptr(arg0.strides_1, dtype=bool) {
      assert((1 == cast(int32, (int64*)arg0.strides_1[0])), "arg0.strides: expected to be compact array")
      0
    }
    assert((0u64 == @tir.tvm_struct_get(arg0_1, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg0_1, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
    assert((0 == @tir.tvm_struct_get(arg1_1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
    assert((0 == @tir.tvm_struct_get(arg1_1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
    assert((((@tir.tvm_struct_get(arg1_1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1_1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1_1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
    assert((0u64 == @tir.tvm_struct_get(arg1_1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg1_1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
    assert((dev_id_1 == @tir.tvm_struct_get(arg1_1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
    attr [0] "compute_scope" = "fused_prod_compute_" {
      placeholder_red[0] = 1i64
      for (k0: int32, 0, 4) {
        placeholder_red[0] = ((int64*)placeholder_red[0]*(int64*)placeholder_1[k0])
      }
    }
  }
}

primfn(args_2: handle, arg_type_ids_2: handle, num_args_2: int32, out_ret_value_2: handle, out_ret_tcode_2: handle, resource_handle_2: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_multiply", "calling_conv": 1} {
  assert((num_args_2 == 2), "fused_multiply: num_args should be 2")
  let arg0_2: handle = @tir.tvm_struct_get(args_2, 0, 12, dtype=handle)
  let arg0.code_2: int32 = (int32*)arg_type_ids_2[0]
  let arg1_2: handle = @tir.tvm_struct_get(args_2, 1, 12, dtype=handle)
  let arg1.code_2: int32 = (int32*)arg_type_ids_2[1]
  let placeholder_2: Pointer(int64) = @tir.tvm_struct_get(arg0_2, 0, 1, dtype=handle)
  attr [placeholder_2] "storage_alignment" = 128;
  let arg0.shape_2: handle = @tir.tvm_struct_get(arg0_2, 0, 2, dtype=handle)
  let arg0.strides_2: handle = @tir.tvm_struct_get(arg0_2, 0, 3, dtype=handle)
  let dev_id_2: int32 = @tir.tvm_struct_get(arg0_2, 0, 9, dtype=int32)
  let T_multiply: Pointer(int64) = @tir.tvm_struct_get(arg1_2, 0, 1, dtype=handle)
  attr [T_multiply] "storage_alignment" = 128;
  let arg1.shape_2: handle = @tir.tvm_struct_get(arg1_2, 0, 2, dtype=handle)
  let arg1.strides_2: handle = @tir.tvm_struct_get(arg1_2, 0, 3, dtype=handle)
  assert(((((arg0.code_2 == 3) || (arg0.code_2 == 13)) || (arg0.code_2 == 7)) || (arg0.code_2 == 4)), "fused_multiply: Expect arg[0] to be pointer")
  assert(((((arg1.code_2 == 3) || (arg1.code_2 == 13)) || (arg1.code_2 == 7)) || (arg1.code_2 == 4)), "fused_multiply: Expect arg[1] to be pointer")
  assert((0 == @tir.tvm_struct_get(arg0_2, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0_2, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0_2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0_2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0_2, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0_2, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0_2, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1_2, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1_2, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1_2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1_2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1_2, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1_2, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1_2, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id_2 == @tir.tvm_struct_get(arg1_2, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  attr [0] "compute_scope" = "fused_multiply_compute_";
  T_multiply[0] = ((int64*)placeholder_2[0]*4i64)
}


[14:05:58] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerDeviceStorageAccessInfo
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "shape_func_nn_softmax_1", "calling_conv": 1} {
  assert((num_args == 2), "shape_func_nn_softmax_1: num_args should be 2")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let compute: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [compute] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "shape_func_nn_softmax_1: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "shape_func_nn_softmax_1: Expect arg[1] to be pointer")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((4 == cast(int32, (int64*)arg0.shape[0])), "Argument arg0.shape[0] has an unsatisfied constraint: (4 == int32(arg0.shape[0]))")
   {
    if !@tir.isnullptr(arg0.strides, dtype=bool) {
      assert((1 == cast(int32, (int64*)arg0.strides[0])), "arg0.strides: expected to be compact array")
      0
    }
    assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
    assert((1 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 1")
    assert((1 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 1")
    assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
    assert((4 == cast(int32, (int64*)arg1.shape[0])), "Argument arg1.shape[0] has an unsatisfied constraint: (4 == int32(arg1.shape[0]))")
     {
      if !@tir.isnullptr(arg1.strides, dtype=bool) {
        assert((1 == cast(int32, (int64*)arg1.strides[0])), "arg1.strides: expected to be compact array")
        0
      }
      assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
      assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
      assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
      attr [0] "compute_scope" = "shape_func_nn_softmax_1_compute_";
      for (i0: int32, 0, 4) {
        compute[i0] = (int64*)placeholder[i0]
      }
    }
  }
}

primfn(args_1: handle, arg_type_ids_1: handle, num_args_1: int32, out_ret_value_1: handle, out_ret_tcode_1: handle, resource_handle_1: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_prod", "calling_conv": 1} {
  assert((num_args_1 == 2), "fused_prod: num_args should be 2")
  let arg0_1: handle = @tir.tvm_struct_get(args_1, 0, 12, dtype=handle)
  let arg0.code_1: int32 = (int32*)arg_type_ids_1[0]
  let arg1_1: handle = @tir.tvm_struct_get(args_1, 1, 12, dtype=handle)
  let arg1.code_1: int32 = (int32*)arg_type_ids_1[1]
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg0_1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg0.shape_1: handle = @tir.tvm_struct_get(arg0_1, 0, 2, dtype=handle)
  let arg0.strides_1: handle = @tir.tvm_struct_get(arg0_1, 0, 3, dtype=handle)
  let dev_id_1: int32 = @tir.tvm_struct_get(arg0_1, 0, 9, dtype=int32)
  let placeholder_red: Pointer(int64) = @tir.tvm_struct_get(arg1_1, 0, 1, dtype=handle)
  attr [placeholder_red] "storage_alignment" = 128;
  let arg1.shape_1: handle = @tir.tvm_struct_get(arg1_1, 0, 2, dtype=handle)
  let arg1.strides_1: handle = @tir.tvm_struct_get(arg1_1, 0, 3, dtype=handle)
  assert(((((arg0.code_1 == 3) || (arg0.code_1 == 13)) || (arg0.code_1 == 7)) || (arg0.code_1 == 4)), "fused_prod: Expect arg[0] to be pointer")
  assert(((((arg1.code_1 == 3) || (arg1.code_1 == 13)) || (arg1.code_1 == 7)) || (arg1.code_1 == 4)), "fused_prod: Expect arg[1] to be pointer")
  assert((1 == @tir.tvm_struct_get(arg0_1, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((1 == @tir.tvm_struct_get(arg0_1, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((((@tir.tvm_struct_get(arg0_1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0_1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0_1, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((4 == cast(int32, (int64*)arg0.shape_1[0])), "Argument arg0.shape[0] has an unsatisfied constraint: (4 == int32(arg0.shape[0]))")
   {
    if !@tir.isnullptr(arg0.strides_1, dtype=bool) {
      assert((1 == cast(int32, (int64*)arg0.strides_1[0])), "arg0.strides: expected to be compact array")
      0
    }
    assert((0u64 == @tir.tvm_struct_get(arg0_1, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg0_1, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
    assert((0 == @tir.tvm_struct_get(arg1_1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
    assert((0 == @tir.tvm_struct_get(arg1_1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
    assert((((@tir.tvm_struct_get(arg1_1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1_1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1_1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
    assert((0u64 == @tir.tvm_struct_get(arg1_1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg1_1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
    assert((dev_id_1 == @tir.tvm_struct_get(arg1_1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
    attr [0] "compute_scope" = "fused_prod_compute_" {
      placeholder_red[0] = 1i64
      for (k0: int32, 0, 4) {
        placeholder_red[0] = ((int64*)placeholder_red[0]*(int64*)placeholder_1[k0])
      }
    }
  }
}

primfn(args_2: handle, arg_type_ids_2: handle, num_args_2: int32, out_ret_value_2: handle, out_ret_tcode_2: handle, resource_handle_2: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_multiply", "calling_conv": 1} {
  assert((num_args_2 == 2), "fused_multiply: num_args should be 2")
  let arg0_2: handle = @tir.tvm_struct_get(args_2, 0, 12, dtype=handle)
  let arg0.code_2: int32 = (int32*)arg_type_ids_2[0]
  let arg1_2: handle = @tir.tvm_struct_get(args_2, 1, 12, dtype=handle)
  let arg1.code_2: int32 = (int32*)arg_type_ids_2[1]
  let placeholder_2: Pointer(int64) = @tir.tvm_struct_get(arg0_2, 0, 1, dtype=handle)
  attr [placeholder_2] "storage_alignment" = 128;
  let arg0.shape_2: handle = @tir.tvm_struct_get(arg0_2, 0, 2, dtype=handle)
  let arg0.strides_2: handle = @tir.tvm_struct_get(arg0_2, 0, 3, dtype=handle)
  let dev_id_2: int32 = @tir.tvm_struct_get(arg0_2, 0, 9, dtype=int32)
  let T_multiply: Pointer(int64) = @tir.tvm_struct_get(arg1_2, 0, 1, dtype=handle)
  attr [T_multiply] "storage_alignment" = 128;
  let arg1.shape_2: handle = @tir.tvm_struct_get(arg1_2, 0, 2, dtype=handle)
  let arg1.strides_2: handle = @tir.tvm_struct_get(arg1_2, 0, 3, dtype=handle)
  assert(((((arg0.code_2 == 3) || (arg0.code_2 == 13)) || (arg0.code_2 == 7)) || (arg0.code_2 == 4)), "fused_multiply: Expect arg[0] to be pointer")
  assert(((((arg1.code_2 == 3) || (arg1.code_2 == 13)) || (arg1.code_2 == 7)) || (arg1.code_2 == 4)), "fused_multiply: Expect arg[1] to be pointer")
  assert((0 == @tir.tvm_struct_get(arg0_2, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0_2, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0_2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0_2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0_2, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0_2, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0_2, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1_2, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1_2, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1_2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1_2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1_2, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1_2, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1_2, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id_2 == @tir.tvm_struct_get(arg1_2, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  attr [0] "compute_scope" = "fused_multiply_compute_";
  T_multiply[0] = ((int64*)placeholder_2[0]*4i64)
}


[14:05:58] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.CombineContextCall
primfn(args: handle, arg_type_ids: handle, num_args: int32, out_ret_value: handle, out_ret_tcode: handle, resource_handle: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "shape_func_nn_softmax_1", "calling_conv": 1} {
  assert((num_args == 2), "shape_func_nn_softmax_1: num_args should be 2")
  let arg0: handle = @tir.tvm_struct_get(args, 0, 12, dtype=handle)
  let arg0.code: int32 = (int32*)arg_type_ids[0]
  let arg1: handle = @tir.tvm_struct_get(args, 1, 12, dtype=handle)
  let arg1.code: int32 = (int32*)arg_type_ids[1]
  let placeholder: Pointer(int64) = @tir.tvm_struct_get(arg0, 0, 1, dtype=handle)
  attr [placeholder] "storage_alignment" = 128;
  let arg0.shape: handle = @tir.tvm_struct_get(arg0, 0, 2, dtype=handle)
  let arg0.strides: handle = @tir.tvm_struct_get(arg0, 0, 3, dtype=handle)
  let dev_id: int32 = @tir.tvm_struct_get(arg0, 0, 9, dtype=int32)
  let compute: Pointer(int64) = @tir.tvm_struct_get(arg1, 0, 1, dtype=handle)
  attr [compute] "storage_alignment" = 128;
  let arg1.shape: handle = @tir.tvm_struct_get(arg1, 0, 2, dtype=handle)
  let arg1.strides: handle = @tir.tvm_struct_get(arg1, 0, 3, dtype=handle)
  assert(((((arg0.code == 3) || (arg0.code == 13)) || (arg0.code == 7)) || (arg0.code == 4)), "shape_func_nn_softmax_1: Expect arg[0] to be pointer")
  assert(((((arg1.code == 3) || (arg1.code == 13)) || (arg1.code == 7)) || (arg1.code == 4)), "shape_func_nn_softmax_1: Expect arg[1] to be pointer")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((1 == @tir.tvm_struct_get(arg0, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((((@tir.tvm_struct_get(arg0, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((4 == cast(int32, (int64*)arg0.shape[0])), "Argument arg0.shape[0] has an unsatisfied constraint: (4 == int32(arg0.shape[0]))")
   {
    if !@tir.isnullptr(arg0.strides, dtype=bool) {
      assert((1 == cast(int32, (int64*)arg0.strides[0])), "arg0.strides: expected to be compact array")
      0
    }
    assert((0u64 == @tir.tvm_struct_get(arg0, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg0, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
    assert((1 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 1")
    assert((1 == @tir.tvm_struct_get(arg1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 1")
    assert((((@tir.tvm_struct_get(arg1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
    assert((4 == cast(int32, (int64*)arg1.shape[0])), "Argument arg1.shape[0] has an unsatisfied constraint: (4 == int32(arg1.shape[0]))")
     {
      if !@tir.isnullptr(arg1.strides, dtype=bool) {
        assert((1 == cast(int32, (int64*)arg1.strides[0])), "arg1.strides: expected to be compact array")
        0
      }
      assert((0u64 == @tir.tvm_struct_get(arg1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
      assert((1 == @tir.tvm_struct_get(arg1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
      assert((dev_id == @tir.tvm_struct_get(arg1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
      attr [0] "compute_scope" = "shape_func_nn_softmax_1_compute_";
      for (i0: int32, 0, 4) {
        compute[i0] = (int64*)placeholder[i0]
      }
    }
  }
}

primfn(args_1: handle, arg_type_ids_1: handle, num_args_1: int32, out_ret_value_1: handle, out_ret_tcode_1: handle, resource_handle_1: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_prod", "calling_conv": 1} {
  assert((num_args_1 == 2), "fused_prod: num_args should be 2")
  let arg0_1: handle = @tir.tvm_struct_get(args_1, 0, 12, dtype=handle)
  let arg0.code_1: int32 = (int32*)arg_type_ids_1[0]
  let arg1_1: handle = @tir.tvm_struct_get(args_1, 1, 12, dtype=handle)
  let arg1.code_1: int32 = (int32*)arg_type_ids_1[1]
  let placeholder_1: Pointer(int64) = @tir.tvm_struct_get(arg0_1, 0, 1, dtype=handle)
  attr [placeholder_1] "storage_alignment" = 128;
  let arg0.shape_1: handle = @tir.tvm_struct_get(arg0_1, 0, 2, dtype=handle)
  let arg0.strides_1: handle = @tir.tvm_struct_get(arg0_1, 0, 3, dtype=handle)
  let dev_id_1: int32 = @tir.tvm_struct_get(arg0_1, 0, 9, dtype=int32)
  let placeholder_red: Pointer(int64) = @tir.tvm_struct_get(arg1_1, 0, 1, dtype=handle)
  attr [placeholder_red] "storage_alignment" = 128;
  let arg1.shape_1: handle = @tir.tvm_struct_get(arg1_1, 0, 2, dtype=handle)
  let arg1.strides_1: handle = @tir.tvm_struct_get(arg1_1, 0, 3, dtype=handle)
  assert(((((arg0.code_1 == 3) || (arg0.code_1 == 13)) || (arg0.code_1 == 7)) || (arg0.code_1 == 4)), "fused_prod: Expect arg[0] to be pointer")
  assert(((((arg1.code_1 == 3) || (arg1.code_1 == 13)) || (arg1.code_1 == 7)) || (arg1.code_1 == 4)), "fused_prod: Expect arg[1] to be pointer")
  assert((1 == @tir.tvm_struct_get(arg0_1, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((1 == @tir.tvm_struct_get(arg0_1, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 1")
  assert((((@tir.tvm_struct_get(arg0_1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0_1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0_1, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((4 == cast(int32, (int64*)arg0.shape_1[0])), "Argument arg0.shape[0] has an unsatisfied constraint: (4 == int32(arg0.shape[0]))")
   {
    if !@tir.isnullptr(arg0.strides_1, dtype=bool) {
      assert((1 == cast(int32, (int64*)arg0.strides_1[0])), "arg0.strides: expected to be compact array")
      0
    }
    assert((0u64 == @tir.tvm_struct_get(arg0_1, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg0_1, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
    assert((0 == @tir.tvm_struct_get(arg1_1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
    assert((0 == @tir.tvm_struct_get(arg1_1, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
    assert((((@tir.tvm_struct_get(arg1_1, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1_1, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1_1, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
    assert((0u64 == @tir.tvm_struct_get(arg1_1, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
    assert((1 == @tir.tvm_struct_get(arg1_1, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
    assert((dev_id_1 == @tir.tvm_struct_get(arg1_1, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
    attr [0] "compute_scope" = "fused_prod_compute_" {
      placeholder_red[0] = 1i64
      for (k0: int32, 0, 4) {
        placeholder_red[0] = ((int64*)placeholder_red[0]*(int64*)placeholder_1[k0])
      }
    }
  }
}

primfn(args_2: handle, arg_type_ids_2: handle, num_args_2: int32, out_ret_value_2: handle, out_ret_tcode_2: handle, resource_handle_2: handle) -> int32
  attr = {"target": meta[Target][0], "tir.noalias": True, "global_symbol": "fused_multiply", "calling_conv": 1} {
  assert((num_args_2 == 2), "fused_multiply: num_args should be 2")
  let arg0_2: handle = @tir.tvm_struct_get(args_2, 0, 12, dtype=handle)
  let arg0.code_2: int32 = (int32*)arg_type_ids_2[0]
  let arg1_2: handle = @tir.tvm_struct_get(args_2, 1, 12, dtype=handle)
  let arg1.code_2: int32 = (int32*)arg_type_ids_2[1]
  let placeholder_2: Pointer(int64) = @tir.tvm_struct_get(arg0_2, 0, 1, dtype=handle)
  attr [placeholder_2] "storage_alignment" = 128;
  let arg0.shape_2: handle = @tir.tvm_struct_get(arg0_2, 0, 2, dtype=handle)
  let arg0.strides_2: handle = @tir.tvm_struct_get(arg0_2, 0, 3, dtype=handle)
  let dev_id_2: int32 = @tir.tvm_struct_get(arg0_2, 0, 9, dtype=int32)
  let T_multiply: Pointer(int64) = @tir.tvm_struct_get(arg1_2, 0, 1, dtype=handle)
  attr [T_multiply] "storage_alignment" = 128;
  let arg1.shape_2: handle = @tir.tvm_struct_get(arg1_2, 0, 2, dtype=handle)
  let arg1.strides_2: handle = @tir.tvm_struct_get(arg1_2, 0, 3, dtype=handle)
  assert(((((arg0.code_2 == 3) || (arg0.code_2 == 13)) || (arg0.code_2 == 7)) || (arg0.code_2 == 4)), "fused_multiply: Expect arg[0] to be pointer")
  assert(((((arg1.code_2 == 3) || (arg1.code_2 == 13)) || (arg1.code_2 == 7)) || (arg1.code_2 == 4)), "fused_multiply: Expect arg[1] to be pointer")
  assert((0 == @tir.tvm_struct_get(arg0_2, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg0_2, 0, 4, dtype=int32)), "arg0.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg0_2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg0_2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg0_2, 0, 7, dtype=uint16) == 1u16)), "arg0.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg0_2, 0, 8, dtype=uint64)), "Argument arg0.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg0, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg0_2, 0, 10, dtype=int32)), "Argument arg0.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg0, 0, 10))")
  assert((0 == @tir.tvm_struct_get(arg1_2, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((0 == @tir.tvm_struct_get(arg1_2, 0, 4, dtype=int32)), "arg1.ndim is expected to equal 0")
  assert((((@tir.tvm_struct_get(arg1_2, 0, 5, dtype=uint8) == 0u8) && (@tir.tvm_struct_get(arg1_2, 0, 6, dtype=uint8) == 64u8)) && (@tir.tvm_struct_get(arg1_2, 0, 7, dtype=uint16) == 1u16)), "arg1.dtype is expected to be int64")
  assert((0u64 == @tir.tvm_struct_get(arg1_2, 0, 8, dtype=uint64)), "Argument arg1.byte_offset has an unsatisfied constraint: ((uint64)0 == tir.tvm_struct_get(arg1, 0, 8))")
  assert((1 == @tir.tvm_struct_get(arg1_2, 0, 10, dtype=int32)), "Argument arg1.device_type has an unsatisfied constraint: (1 == tir.tvm_struct_get(arg1, 0, 10))")
  assert((dev_id_2 == @tir.tvm_struct_get(arg1_2, 0, 9, dtype=int32)), "Argument arg1.device_id has an unsatisfied constraint: (dev_id == tir.tvm_struct_get(arg1, 0, 9))")
  attr [0] "compute_scope" = "fused_multiply_compute_";
  T_multiply[0] = ((int64*)placeholder_2[0]*4i64)
}


[14:05:58] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass Filter

[14:05:58] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass BindTarget

[14:05:58] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerWarpMemory

[14:05:58] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.Simplify

[14:05:58] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerCustomDatatypes

[14:05:58] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerIntrin

[14:05:58] /workspace/home/codes/tvm/src/ir/transform.cc:541: After pass tir.LowerDeviceStorageAccessInfo

[14:05:58] /workspace/home/codes/tvm/src/relay/backend/vm/compiler.cc:1205: CODEGEN END

Raw module: 
def @main(%x: Tensor[(meta[tir.Var][0], meta[tir.Var][1], meta[tir.Var][2], meta[tir.Var][3]), float32]) {
  nn.softmax(%x)
}


Running on (cuda, cuda(0))
Finish in 35.72798 ms
